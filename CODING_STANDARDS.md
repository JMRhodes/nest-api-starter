# https://docs.nestjs.com/ llms-full.txt

## NestJS Framework
- [Introduction](https://docs.nestjs.com/#introduction)
- [Philosophy](https://docs.nestjs.com/#philosophy)
- [Installation](https://docs.nestjs.com/#installation)
- [Alternatives](https://docs.nestjs.com/#alternatives)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/introduction.md "Suggest Edits")

### Introduction

Nest (NestJS) is a framework for building efficient, scalable [Node.js](https://nodejs.org/) server-side applications. It uses progressive JavaScript, is built with and fully supports [TypeScript](http://www.typescriptlang.org/) (yet still enables developers to code in pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

Under the hood, Nest makes use of robust HTTP Server frameworks like [Express](https://expressjs.com/) (the default) and optionally can be configured to use [Fastify](https://github.com/fastify/fastify) as well!

Nest provides a level of abstraction above these common Node.js frameworks (Express/Fastify), but also exposes their APIs directly to the developer. This gives developers the freedom to use the myriad of third-party modules which are available for the underlying platform.

#### Philosophy [\#](https://docs.nestjs.com/\#philosophy)

In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications. This has given rise to awesome projects like [Angular](https://angular.dev/), [React](https://github.com/facebook/react) and [Vue](https://github.com/vuejs/vue), which improve developer productivity and enable the creation of fast, testable, and extensible frontend applications. However, while plenty of superb libraries, helpers, and tools exist for Node (and server-side JavaScript), none of them effectively solve the main problem of **architecture**.

Nest provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications. The architecture is heavily inspired by Angular.

#### Installation [\#](https://docs.nestjs.com/\#installation)

To get started, you can either scaffold the project with the [Nest CLI](https://docs.nestjs.com/cli/overview), or [clone a starter project](https://docs.nestjs.com/#alternatives) (both will produce the same outcome).

To scaffold the project with the Nest CLI, run the following commands. This will create a new project directory, and populate the directory with the initial core Nest files and supporting modules, creating a conventional base structure for your project. Creating a new project with the **Nest CLI** is recommended for first-time users. We'll continue with this approach in [First Steps](https://docs.nestjs.com/first-steps).

```bash

$ npm i -g @nestjs/cli
$ nest new project-name

```

> **Hint** To create a new TypeScript project with stricter feature set, pass the `--strict` flag to the `nest new` command.

#### Alternatives [\#](https://docs.nestjs.com/\#alternatives)

Alternatively, to install the TypeScript starter project with **Git**:

```bash

$ git clone https://github.com/nestjs/typescript-starter.git project
$ cd project
$ npm install
$ npm run start

```

> **Hint** If you'd like to clone the repository without the git history, you can use [degit](https://github.com/Rich-Harris/degit).

Open your browser and navigate to [`http://localhost:3000/`](http://localhost:3000/).

To install the JavaScript flavor of the starter project, use `javascript-starter.git` in the command sequence above.

You can also start a new project from scratch by installing the core and supporting packages. Keep in mind that you'll need to set up the project boilerplate files on your own. At a minimum, you'll need these dependencies: `@nestjs/core`, `@nestjs/common`, `rxjs`, and `reflect-metadata`. Check out this short article on how to create a complete project: [5 steps to create a bare minimum NestJS app from scratch!](https://dev.to/micalevisk/5-steps-to-create-a-bare-minimum-nestjs-app-from-scratch-5c3b).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Logging Techniques
- [Logger](https://docs.nestjs.com/techniques/logger#logger)
- [Basic customization](https://docs.nestjs.com/techniques/logger#basic-customization)
- [JSON logging](https://docs.nestjs.com/techniques/logger#json-logging)
- [Using the logger for application logging](https://docs.nestjs.com/techniques/logger#using-the-logger-for-application-logging)
- [Logs with timestamps](https://docs.nestjs.com/techniques/logger#logs-with-timestamps)
- [Custom implementation](https://docs.nestjs.com/techniques/logger#custom-implementation)
- [Extend built-in logger](https://docs.nestjs.com/techniques/logger#extend-built-in-logger)
- [Dependency injection](https://docs.nestjs.com/techniques/logger#dependency-injection)
- [Injecting a custom logger](https://docs.nestjs.com/techniques/logger#injecting-a-custom-logger)
- [Use external logger](https://docs.nestjs.com/techniques/logger#use-external-logger)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/logger.md "Suggest Edits")

### Logger

Nest comes with a built-in text-based logger which is used during application bootstrapping and several other circumstances such as displaying caught exceptions (i.e., system logging). This functionality is provided via the `Logger` class in the `@nestjs/common` package. You can fully control the behavior of the logging system, including any of the following:

- disable logging entirely
- specify the log level of detail (e.g., display errors, warnings, debug information, etc.)
- configure formatting of log messages (raw, json, colorized, etc.)
- override timestamp in the default logger (e.g., use ISO8601 standard as date format)
- completely override the default logger
- customize the default logger by extending it
- make use of dependency injection to simplify composing and testing your application

You can also make use of the built-in logger, or create your own custom implementation, to log your own application-level events and messages.

If your application requires integration with external logging systems, automatic file-based logging, or forwarding logs to a centralized logging service, you can implement a fully custom logging solution using a Node.js logging library. One popular choice is [Pino](https://github.com/pinojs/pino), known for its high performance and flexibility.

#### Basic customization [\#](https://docs.nestjs.com/techniques/logger\#basic-customization)

To disable logging, set the `logger` property to `false` in the (optional) Nest application options object passed as the second argument to the `NestFactory.create()` method.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: false,
});
await app.listen(process.env.PORT ?? 3000);

```

To enable specific logging levels, set the `logger` property to an array of strings specifying the log levels to display, as follows:

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: ['error', 'warn'],
});
await app.listen(process.env.PORT ?? 3000);

```

Values in the array can be any combination of `'log'`, `'fatal'`, `'error'`, `'warn'`, `'debug'`, and `'verbose'`.

To disable colorized output, pass the `ConsoleLogger` object with the `colors` property set to `false` as the value of the `logger` property.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({
    colors: false,
  }),
});

```

To configure a prefix for each log message, pass the `ConsoleLogger` object with the `prefix` attribute set:

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({
    prefix: 'MyApp', // Default is "Nest"
  }),
});

```

Here are all the available options listed in the table below:

| Option | Description | Default |
| --- | --- | --- |
| `logLevels` | Enabled log levels. | `['log', 'error', 'warn', 'debug', 'verbose']` |
| `timestamp` | If enabled, will print timestamp (time difference) between current and previous log message. Note: This option is not used when `json` is enabled. | `false` |
| `prefix` | A prefix to be used for each log message. Note: This option is not used when `json` is enabled. | `Nest` |
| `json` | If enabled, will print the log message in JSON format. | `false` |
| `colors` | If enabled, will print the log message in color. Default true if json is disabled, false otherwise. | `true` |
| `context` | The context of the logger. | `undefined` |
| `compact` | If enabled, will print the log message in a single line, even if it is an object with multiple properties. If set to a number, the most n inner elements are united on a single line as long as all properties fit into breakLength. Short array elements are also grouped together. | `true` |
| `maxArrayLength` | Specifies the maximum number of Array, TypedArray, Map, Set, WeakMap, and WeakSet elements to include when formatting. Set to null or Infinity to show all elements. Set to 0 or negative to show no elements. Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output. | `100` |
| `maxStringLength` | Specifies the maximum number of characters to include when formatting. Set to null or Infinity to show all elements. Set to 0 or negative to show no characters. Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output. | `10000` |
| `sorted` | If enabled, will sort keys while formatting objects. Can also be a custom sorting function. Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output. | `false` |
| `depth` | Specifies the number of times to recurse while formatting object. This is useful for inspecting large objects. To recurse up to the maximum call stack size pass Infinity or null. Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output. | `5` |
| `showHidden` | If true, object's non-enumerable symbols and properties are included in the formatted result. WeakMap and WeakSet entries are also included as well as user defined prototype properties | `false` |
| `breakLength` | The length at which input values are split across multiple lines. Set to Infinity to format the input as a single line (in combination with "compact" set to true). Default Infinity when "compact" is true, 80 otherwise. Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output. | `Infinity` |

#### JSON logging [\#](https://docs.nestjs.com/techniques/logger\#json-logging)

JSON logging is essential for modern application observability and integration with log management systems. To enable JSON logging in your NestJS application, configure the `ConsoleLogger` object with its `json` property set to `true`. Then, provide this logger configuration as the value for the `logger` property when creating the application instance.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({
    json: true,
  }),
});

```

This configuration outputs logs in a structured JSON format, making it easier to integrate with external systems such as log aggregators and cloud platforms. For example, platforms like **AWS ECS** (Elastic Container Service) natively support JSON logs, enabling advanced features like:

- **Log Filtering**: Easily narrow down logs based on fields like log level, timestamp, or custom metadata.
- **Search and Analysis**: Use query tools to analyze and track trends in your application's behavior.

Additionally, if you're using [NestJS Mau](https://mau.nestjs.com/), JSON logging simplifies the process of viewing logs in a well-organized, structured format, which is especially useful for debugging and performance monitoring.

> **Note** When `json` is set to `true`, the `ConsoleLogger` automatically disables text colorization by setting the `colors` property to `false`. This ensures that the output remains valid JSON, free of formatting artifacts. However, for development purposes, you can override this behavior by explicitly setting `colors` to `true`. This adds colorized JSON logs, which can make log entries more readable during local debugging.

When JSON logging is enabled, the log output will look like this (in a single line):

```json

{
  "level": "log",
  "pid": 19096,
  "timestamp": 1607370779834,
  "message": "Starting Nest application...",
  "context": "NestFactory"
}

```

You can see different variants in this [Pull Request](https://github.com/nestjs/nest/pull/14121).

#### Using the logger for application logging [\#](https://docs.nestjs.com/techniques/logger\#using-the-logger-for-application-logging)

We can combine several of the techniques above to provide consistent behavior and formatting across both Nest system logging and our own application event/message logging.

A good practice is to instantiate `Logger` class from `@nestjs/common` in each of our services. We can supply our service name as the `context` argument in the `Logger` constructor, like so:

content\_copy

```typescript

import { Logger, Injectable } from '@nestjs/common';

@Injectable()
class MyService {
  private readonly logger = new Logger(MyService.name);

  doSomething() {
    this.logger.log('Doing something...');
  }
}

```

In the default logger implementation, `context` is printed in the square brackets, like `NestFactory` in the example below:

```bash

[Nest] 19096   - 12/08/2019, 7:12:59 AM   [NestFactory] Starting Nest application...

```

If we supply a custom logger via `app.useLogger()`, it will actually be used by Nest internally. That means that our code remains implementation agnostic, while we can easily substitute the default logger for our custom one by calling `app.useLogger()`.

That way if we follow the steps from the previous section and call `app.useLogger(app.get(MyLogger))`, the following calls to `this.logger.log()` from `MyService` would result in calls to method `log` from `MyLogger` instance.

This should be suitable for most cases. But if you need more customization (like adding and calling custom methods), move to the next section.

#### Logs with timestamps [\#](https://docs.nestjs.com/techniques/logger\#logs-with-timestamps)

To enable timestamp logging for every logged message, you can use the optional `timestamp: true` setting when creating the logger instance.

content\_copy

```typescript

import { Logger, Injectable } from '@nestjs/common';

@Injectable()
class MyService {
  private readonly logger = new Logger(MyService.name, { timestamp: true });

  doSomething() {
    this.logger.log('Doing something with timestamp here ->');
  }
}

```

This will produce output in the following format:

```bash

[Nest] 19096   - 04/19/2024, 7:12:59 AM   [MyService] Doing something with timestamp here +5ms

```

Note the `+5ms` at the end of the line. For each log statement, the time difference from the previous message is calculated and displayed at the end of the line.

#### Custom implementation [\#](https://docs.nestjs.com/techniques/logger\#custom-implementation)

You can provide a custom logger implementation to be used by Nest for system logging by setting the value of the `logger` property to an object that fulfills the `LoggerService` interface. For example, you can tell Nest to use the built-in global JavaScript `console` object (which implements the `LoggerService` interface), as follows:

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: console,
});
await app.listen(process.env.PORT ?? 3000);

```

Implementing your own custom logger is straightforward. Simply implement each of the methods of the `LoggerService` interface as shown below.

content\_copy

```typescript

import { LoggerService, Injectable } from '@nestjs/common';

@Injectable()
export class MyLogger implements LoggerService {
  /**
   * Write a 'log' level log.
   */
  log(message: any, ...optionalParams: any[]) {}

  /**
   * Write a 'fatal' level log.
   */
  fatal(message: any, ...optionalParams: any[]) {}

  /**
   * Write an 'error' level log.
   */
  error(message: any, ...optionalParams: any[]) {}

  /**
   * Write a 'warn' level log.
   */
  warn(message: any, ...optionalParams: any[]) {}

  /**
   * Write a 'debug' level log.
   */
  debug?(message: any, ...optionalParams: any[]) {}

  /**
   * Write a 'verbose' level log.
   */
  verbose?(message: any, ...optionalParams: any[]) {}
}

```

You can then supply an instance of `MyLogger` via the `logger` property of the Nest application options object.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  logger: new MyLogger(),
});
await app.listen(process.env.PORT ?? 3000);

```

This technique, while simple, doesn't utilize dependency injection for the `MyLogger` class. This can pose some challenges, particularly for testing, and limit the reusability of `MyLogger`. For a better solution, see the [Dependency Injection](https://docs.nestjs.com/techniques/logger#dependency-injection) section below.

#### Extend built-in logger [\#](https://docs.nestjs.com/techniques/logger\#extend-built-in-logger)

Rather than writing a logger from scratch, you may be able to meet your needs by extending the built-in `ConsoleLogger` class and overriding selected behavior of the default implementation.

content\_copy

```typescript

import { ConsoleLogger } from '@nestjs/common';

export class MyLogger extends ConsoleLogger {
  error(message: any, stack?: string, context?: string) {
    // add your tailored logic here
    super.error(...arguments);
  }
}

```

You can use such an extended logger in your feature modules as described in the [Using the logger for application logging](https://docs.nestjs.com/techniques/logger#using-the-logger-for-application-logging) section below.

You can tell Nest to use your extended logger for system logging by passing an instance of it via the `logger` property of the application options object (as shown in the [Custom implementation](https://docs.nestjs.com/techniques/logger#custom-logger-implementation) section above), or by using the technique shown in the [Dependency Injection](https://docs.nestjs.com/techniques/logger#dependency-injection) section below. If you do so, you should take care to call `super`, as shown in the sample code above, to delegate the specific log method call to the parent (built-in) class so that Nest can rely on the built-in features it expects.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Dependency injection [\#](https://docs.nestjs.com/techniques/logger\#dependency-injection)

For more advanced logging functionality, you'll want to take advantage of dependency injection. For example, you may want to inject a `ConfigService` into your logger to customize it, and in turn inject your custom logger into other controllers and/or providers. To enable dependency injection for your custom logger, create a class that implements `LoggerService` and register that class as a provider in some module. For example, you can

1. Define a `MyLogger` class that either extends the built-in `ConsoleLogger` or completely overrides it, as shown in previous sections. Be sure to implement the `LoggerService` interface.
2. Create a `LoggerModule` as shown below, and provide `MyLogger` from that module.

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { MyLogger } from './my-logger.service';

@Module({
  providers: [MyLogger],
  exports: [MyLogger],
})
export class LoggerModule {}

```

With this construct, you are now providing your custom logger for use by any other module. Because your `MyLogger` class is part of a module, it can use dependency injection (for example, to inject a `ConfigService`). There's one more technique needed to provide this custom logger for use by Nest for system logging (e.g., for bootstrapping and error handling).

Because application instantiation ( `NestFactory.create()`) happens outside the context of any module, it doesn't participate in the normal Dependency Injection phase of initialization. So we must ensure that at least one application module imports the `LoggerModule` to trigger Nest to instantiate a singleton instance of our `MyLogger` class.

We can then instruct Nest to use the same singleton instance of `MyLogger` with the following construction:

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  bufferLogs: true,
});
app.useLogger(app.get(MyLogger));
await app.listen(process.env.PORT ?? 3000);

```

> **Note** In the example above, we set the `bufferLogs` to `true` to make sure all logs will be buffered until a custom logger is attached ( `MyLogger` in this case) and the application initialisation process either completes or fails. If the initialisation process fails, Nest will fallback to the original `ConsoleLogger` to print out any reported error messages. Also, you can set the `autoFlushLogs` to `false` (default `true`) to manually flush logs (using the `Logger.flush()` method).

Here we use the `get()` method on the `NestApplication` instance to retrieve the singleton instance of the `MyLogger` object. This technique is essentially a way to "inject" an instance of a logger for use by Nest. The `app.get()` call retrieves the singleton instance of `MyLogger`, and depends on that instance being first injected in another module, as described above.

You can also inject this `MyLogger` provider in your feature classes, thus ensuring consistent logging behavior across both Nest system logging and application logging. See [Using the logger for application logging](https://docs.nestjs.com/techniques/logger#using-the-logger-for-application-logging) and [Injecting a custom logger](https://docs.nestjs.com/techniques/logger#injecting-a-custom-logger) below for more information.

#### Injecting a custom logger [\#](https://docs.nestjs.com/techniques/logger\#injecting-a-custom-logger)

To start, extend the built-in logger with code like the following. We supply the `scope` option as configuration metadata for the `ConsoleLogger` class, specifying a [transient](https://docs.nestjs.com/fundamentals/injection-scopes) scope, to ensure that we'll have a unique instance of the `MyLogger` in each feature module. In this example, we do not extend the individual `ConsoleLogger` methods (like `log()`, `warn()`, etc.), though you may choose to do so.

content\_copy

```typescript

import { Injectable, Scope, ConsoleLogger } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class MyLogger extends ConsoleLogger {
  customLog() {
    this.log('Please feed the cat!');
  }
}

```

Next, create a `LoggerModule` with a construction like this:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { MyLogger } from './my-logger.service';

@Module({
  providers: [MyLogger],
  exports: [MyLogger],
})
export class LoggerModule {}

```

Next, import the `LoggerModule` into your feature module. Since we extended default `Logger` we have the convenience of using `setContext` method. So we can start using the context-aware custom logger, like this:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { MyLogger } from './my-logger.service';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  constructor(private myLogger: MyLogger) {
    // Due to transient scope, CatsService has its own unique instance of MyLogger,
    // so setting context here will not affect other instances in other services
    this.myLogger.setContext('CatsService');
  }

  findAll(): Cat[] {
    // You can call all the default methods
    this.myLogger.warn('About to return cats!');
    // And your custom methods
    this.myLogger.customLog();
    return this.cats;
  }
}

```

Finally, instruct Nest to use an instance of the custom logger in your `main.ts` file as shown below. Of course in this example, we haven't actually customized the logger behavior (by extending the `Logger` methods like `log()`, `warn()`, etc.), so this step isn't actually needed. But it **would** be needed if you added custom logic to those methods and wanted Nest to use the same implementation.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  bufferLogs: true,
});
app.useLogger(new MyLogger());
await app.listen(process.env.PORT ?? 3000);

```

> **Hint** Alternatively, instead of setting `bufferLogs` to `true`, you could temporarily disable the logger with `logger: false` instruction. Be mindful that if you supply `logger: false` to `NestFactory.create`, nothing will be logged until you call `useLogger`, so you may miss some important initialization errors. If you don't mind that some of your initial messages will be logged with the default logger, you can just omit the `logger: false` option.

#### Use external logger [\#](https://docs.nestjs.com/techniques/logger\#use-external-logger)

Production applications often have specific logging requirements, including advanced filtering, formatting and centralized logging. Nest's built-in logger is used for monitoring Nest system behavior, and can also be useful for basic formatted text logging in your feature modules while in development, but production applications often take advantage of dedicated logging modules like [Winston](https://github.com/winstonjs/winston). As with any standard Node.js application, you can take full advantage of such modules in Nest.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Passport Authentication
- [Passport (authentication)](https://docs.nestjs.com/recipes/passport#passport-authentication)
- [Authentication requirements](https://docs.nestjs.com/recipes/passport#authentication-requirements)
- [Implementing Passport strategies](https://docs.nestjs.com/recipes/passport#implementing-passport-strategies)
- [Implementing Passport local](https://docs.nestjs.com/recipes/passport#implementing-passport-local)
- [Built-in Passport Guards](https://docs.nestjs.com/recipes/passport#built-in-passport-guards)
- [Login route](https://docs.nestjs.com/recipes/passport#login-route)
- [Logout route](https://docs.nestjs.com/recipes/passport#logout-route)
- [JWT functionality](https://docs.nestjs.com/recipes/passport#jwt-functionality)
- [Implementing Passport JWT](https://docs.nestjs.com/recipes/passport#implementing-passport-jwt)
- [Implement protected route and JWT strategy guards](https://docs.nestjs.com/recipes/passport#implement-protected-route-and-jwt-strategy-guards)
- [Extending guards](https://docs.nestjs.com/recipes/passport#extending-guards)
- [Enable authentication globally](https://docs.nestjs.com/recipes/passport#enable-authentication-globally)
- [Request-scoped strategies](https://docs.nestjs.com/recipes/passport#request-scoped-strategies)
- [Customize Passport](https://docs.nestjs.com/recipes/passport#customize-passport)
- [Named strategies](https://docs.nestjs.com/recipes/passport#named-strategies)
- [GraphQL](https://docs.nestjs.com/recipes/passport#graphql)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/passport.md "Suggest Edits")

### Passport (authentication)

[Passport](https://github.com/jaredhanson/passport) is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a **Nest** application using the `@nestjs/passport` module. At a high level, Passport executes a series of steps to:

- Authenticate a user by verifying their "credentials" (such as username/password, JSON Web Token ( [JWT](https://jwt.io/)), or identity token from an Identity Provider)
- Manage authenticated state (by issuing a portable token, such as a JWT, or creating an [Express session](https://github.com/expressjs/session))
- Attach information about the authenticated user to the `Request` object for further use in route handlers

Passport has a rich ecosystem of [strategies](http://www.passportjs.org/) that implement various authentication mechanisms. While simple in concept, the set of Passport strategies you can choose from is large and presents a lot of variety. Passport abstracts these varied steps into a standard pattern, and the `@nestjs/passport` module wraps and standardizes this pattern into familiar Nest constructs.

In this chapter, we'll implement a complete end-to-end authentication solution for a RESTful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example.

#### Authentication requirements [\#](https://docs.nestjs.com/recipes/passport\#authentication-requirements)

Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a [bearer token in an authorization header](https://tools.ietf.org/html/rfc6750) on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT.

We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request.

First we need to install the required packages. Passport provides a strategy called [passport-local](https://github.com/jaredhanson/passport-local) that implements a username/password authentication mechanism, which suits our needs for this portion of our use case.

```bash

$ npm install --save @nestjs/passport passport passport-local
$ npm install --save-dev @types/passport-local

```

> **Notice** For **any** Passport strategy you choose, you'll always need the `@nestjs/passport` and `passport` packages. Then, you'll need to install the strategy-specific package (e.g., `passport-jwt` or `passport-local`) that implements the particular authentication strategy you are building. In addition, you can also install the type definitions for any Passport strategy, as shown above with `@types/passport-local`, which provides assistance while writing TypeScript code.

#### Implementing Passport strategies [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-strategies)

We're now ready to implement the authentication feature. We'll start with an overview of the process used for **any** Passport strategy. It's helpful to think of Passport as a mini framework in itself. The elegance of the framework is that it abstracts the authentication process into a few basic steps that you customize based on the strategy you're implementing. It's like a framework because you configure it by supplying customization parameters (as plain JSON objects) and custom code in the form of callback functions, which Passport calls at the appropriate time. The `@nestjs/passport` module wraps this framework in a Nest style package, making it easy to integrate into a Nest application. We'll use `@nestjs/passport` below, but first let's consider how **vanilla Passport** works.

In vanilla Passport, you configure a strategy by providing two things:

1. A set of options that are specific to that strategy. For example, in a JWT strategy, you might provide a secret to sign tokens.
2. A "verify callback", which is where you tell Passport how to interact with your user store (where you manage user accounts). Here, you verify whether a user exists (and/or create a new user), and whether their credentials are valid. The Passport library expects this callback to return a full user if the validation succeeds, or a null if it fails (failure is defined as either the user is not found, or, in the case of passport-local, the password does not match).

With `@nestjs/passport`, you configure a Passport strategy by extending the `PassportStrategy` class. You pass the strategy options (item 1 above) by calling the `super()` method in your subclass, optionally passing in an options object. You provide the verify callback (item 2 above) by implementing a `validate()` method in your subclass.

We'll start by generating an `AuthModule` and in it, an `AuthService`:

```bash

$ nest g module auth
$ nest g service auth

```

As we implement the `AuthService`, we'll find it useful to encapsulate user operations in a `UsersService`, so let's generate that module and service now:

```bash

$ nest g module users
$ nest g service users

```

Replace the default contents of these generated files as shown below. For our sample app, the `UsersService` simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.).

content\_copy users/users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';

// This should be a real class/interface representing a user entity
export type User = any;

@Injectable()
export class UsersService {
  private readonly users = [\
    {\
      userId: 1,\
      username: 'john',\
      password: 'changeme',\
    },\
    {\
      userId: 2,\
      username: 'maria',\
      password: 'guess',\
    },\
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find(user => user.username === username);
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  constructor() {
    this.users = [\
      {\
        userId: 1,\
        username: 'john',\
        password: 'changeme',\
      },\
      {\
        userId: 2,\
        username: 'maria',\
        password: 'guess',\
      },\
    ];
  }

  async findOne(username) {
    return this.users.find(user => user.username === username);
  }
}

```

In the `UsersModule`, the only change needed is to add the `UsersService` to the exports array of the `@Module` decorator so that it is visible outside this module (we'll soon use it in our `AuthService`).

content\_copy users/users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

Our `AuthService` has the job of retrieving a user and verifying the password. We create a `validateUser()` method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. We'll be calling into the `validateUser()` method from our Passport local strategy in a moment.

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
@Dependencies(UsersService)
export class AuthService {
  constructor(usersService) {
    this.usersService = usersService;
  }

  async validateUser(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }
}

```

> **Warning** Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like [bcrypt](https://github.com/kelektiv/node.bcrypt.js#readme), with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the **incoming** password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. **Don't do this in your real app!**

Now, we update our `AuthModule` to import the `UsersModule`.

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
})
export class AuthModule {}

```

#### Implementing Passport local [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-local)

Now we can implement our Passport **local authentication strategy**. Create a file called `local.strategy.ts` in the `auth` folder, and add the following code:

content\_copy auth/local.strategy.ts

JS  TS

```typescript

import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

```

```typescript

import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException, Dependencies } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
@Dependencies(AuthService)
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(authService) {
    super();
    this.authService = authService;
  }

  async validate(username, password) {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

```

We've followed the recipe described earlier for all Passport strategies. In our use case with passport-local, there are no configuration options, so our constructor simply calls `super()`, without an options object.

> **Hint** We can pass an options object in the call to `super()` to customize the behavior of the passport strategy. In this example, the passport-local strategy by default expects properties called `username` and `password` in the request body. Pass an options object to specify different property names, for example: `super({ usernameField: 'email' })`. See the [Passport documentation](http://www.passportjs.org/docs/configure/) for more information.

We've also implemented the `validate()` method. For each strategy, Passport will call the verify function (implemented with the `validate()` method in `@nestjs/passport`) using an appropriate strategy-specific set of parameters. For the local-strategy, Passport expects a `validate()` method with the following signature: `validate(username: string, password:string): any`.

Most of the validation work is done in our `AuthService` (with the help of our `UsersService`), so this method is quite straightforward. The `validate()` method for **any** Passport strategy will follow a similar pattern, varying only in the details of how credentials are represented. If a user is found and the credentials are valid, the user is returned so Passport can complete its tasks (e.g., creating the `user` property on the `Request` object), and the request handling pipeline can continue. If it's not found, we throw an exception and let our [exceptions layer](https://docs.nestjs.com/exception-filters) handle it.

Typically, the only significant difference in the `validate()` method for each strategy is **how** you determine if a user exists and is valid. For example, in a JWT strategy, depending on requirements, we may evaluate whether the `userId` carried in the decoded token matches a record in our user database, or matches a list of revoked tokens. Hence, this pattern of sub-classing and implementing strategy-specific validation is consistent, elegant and extensible.

We need to configure our `AuthModule` to use the Passport features we just defined. Update `auth.module.ts` to look like this:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [UsersModule, PassportModule],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [UsersModule, PassportModule],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

#### Built-in Passport Guards [\#](https://docs.nestjs.com/recipes/passport\#built-in-passport-guards)

The [Guards](https://docs.nestjs.com/guards) chapter describes the primary function of Guards: to determine whether a request will be handled by the route handler or not. That remains true, and we'll use that standard capability soon. However, in the context of using the `@nestjs/passport` module, we will also introduce a slight new wrinkle that may at first be confusing, so let's discuss that now. Consider that your app can exist in two states, from an authentication perspective:

1. the user/client is **not** logged in (is not authenticated)
2. the user/client **is** logged in (is authenticated)

In the first case (user is not logged in), we need to perform two distinct functions:

- Restrict the routes an unauthenticated user can access (i.e., deny access to restricted routes). We'll use Guards in their familiar capacity to handle this function, by placing a Guard on the protected routes. As you may anticipate, we'll be checking for the presence of a valid JWT in this Guard, so we'll work on this Guard later, once we are successfully issuing JWTs.

- Initiate the **authentication step** itself when a previously unauthenticated user attempts to login. This is the step where we'll **issue** a JWT to a valid user. Thinking about this for a moment, we know we'll need to `POST` username/password credentials to initiate authentication, so we'll set up a `POST /auth/login` route to handle that. This raises the question: how exactly do we invoke the passport-local strategy in that route?


The answer is straightforward: by using another, slightly different type of Guard. The `@nestjs/passport` module provides us with a built-in Guard that does this for us. This Guard invokes the Passport strategy and kicks off the steps described above (retrieving credentials, running the verify function, creating the `user` property, etc).

The second case enumerated above (logged in user) simply relies on the standard type of Guard we already discussed to enable access to protected routes for logged in users.

## Learn the right way!

- 19 chapters
- Authn & Authz
- Official certificate
- Deep-dive sessions

[Purchase the Authentication course](https://courses.nestjs.com/#authentication "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Login route [\#](https://docs.nestjs.com/recipes/passport\#login-route)

With the strategy in place, we can now implement a bare-bones `/auth/login` route, and apply the built-in Guard to initiate the passport-local flow.

Open the `app.controller.ts` file and replace its contents with the following:

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Request, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AppController {
  @UseGuards(AuthGuard('local'))
  @Post('auth/login')
  async login(@Request() req) {
    return req.user;
  }
}

```

```typescript

import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AppController {
  @UseGuards(AuthGuard('local'))
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return req.user;
  }
}

```

With `@UseGuards(AuthGuard('local'))` we are using an `AuthGuard` that `@nestjs/passport` **automatically provisioned** for us when we extended the passport-local strategy. Let's break that down. Our Passport local strategy has a default name of `'local'`. We reference that name in the `@UseGuards()` decorator to associate it with code supplied by the `passport-local` package. This is used to disambiguate which strategy to invoke in case we have multiple Passport strategies in our app (each of which may provision a strategy-specific `AuthGuard`). While we only have one such strategy so far, we'll shortly add a second, so this is needed for disambiguation.

In order to test our route we'll have our `/auth/login` route simply return the user for now. This also lets us demonstrate another Passport feature: Passport automatically creates a `user` object, based on the value we return from the `validate()` method, and assigns it to the `Request` object as `req.user`. Later, we'll replace this with code to create and return a JWT instead.

Since these are API routes, we'll test them using the commonly available [cURL](https://curl.haxx.se/) library. You can test with any of the `user` objects hard-coded in the `UsersService`.

```bash

$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"userId":1,"username":"john"}

```

While this works, passing the strategy name directly to the `AuthGuard()` introduces magic strings in the codebase. Instead, we recommend creating your own class, as shown below:

content\_copy auth/local-auth.guard.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

```

Now, we can update the `/auth/login` route handler and use the `LocalAuthGuard` instead:

content\_copy

```typescript

@UseGuards(LocalAuthGuard)
@Post('auth/login')
async login(@Request() req) {
  return req.user;
}

```

#### Logout route [\#](https://docs.nestjs.com/recipes/passport\#logout-route)

To log out, we can create an additional route that invokes `req.logout()` to clear the user's session. This is a typical approach used in session-based authentication, but it does not apply to JWTs.

content\_copy

```typescript

@UseGuards(LocalAuthGuard)
@Post('auth/logout')
async logout(@Request() req) {
  return req.logout();
}

```

#### JWT functionality [\#](https://docs.nestjs.com/recipes/passport\#jwt-functionality)

We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:

- Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT.
- Create API routes which are protected based on the presence of a valid JWT as a bearer token

We'll need to install a couple more packages to support our JWT requirements:

```bash

$ npm install --save @nestjs/jwt passport-jwt
$ npm install --save-dev @types/passport-jwt

```

The `@nestjs/jwt` package (see more [here](https://github.com/nestjs/jwt)) is a utility package that helps with JWT manipulation. The `passport-jwt` package is the Passport package that implements the JWT strategy and `@types/passport-jwt` provides the TypeScript type definitions.

Let's take a closer look at how a `POST /auth/login` request is handled. We've decorated the route using the built-in `AuthGuard` provided by the passport-local strategy. This means that:

1. The route handler **will only be invoked if the user has been validated**
2. The `req` parameter will contain a `user` property (populated by Passport during the passport-local authentication flow)

With this in mind, we can now finally generate a real JWT, and return it in this route. To keep our services cleanly modularized, we'll handle generating the JWT in the `authService`. Open the `auth.service.ts` file in the `auth` folder, and add the `login()` method, and import the `JwtService` as shown:

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Dependencies(UsersService, JwtService)
@Injectable()
export class AuthService {
  constructor(usersService, jwtService) {
    this.usersService = usersService;
    this.jwtService = jwtService;
  }

  async validateUser(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}

```

We're using the `@nestjs/jwt` library, which supplies a `sign()` function to generate our JWT from a subset of the `user` object properties, which we then return as a simple object with a single `access_token` property. Note: we choose a property name of `sub` to hold our `userId` value to be consistent with JWT standards. Don't forget to inject the JwtService provider into the `AuthService`.

We now need to update the `AuthModule` to import the new dependencies and configure the `JwtModule`.

First, create `constants.ts` in the `auth` folder, and add the following code:

content\_copy auth/constants.ts

JS  TS

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

We'll use this to share our key between the JWT signing and verifying steps.

> **Warning** **Do not expose this key publicly**. We have done so here to make it clear what the code is doing, but in a production system **you must protect this key** using appropriate measures such as a secrets vault, environment variable, or configuration service.

Now, open `auth.module.ts` in the `auth` folder and update it to look like this:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

We configure the `JwtModule` using `register()`, passing in a configuration object. See [here](https://github.com/nestjs/jwt/blob/master/README.md) for more on the Nest `JwtModule` and [here](https://github.com/auth0/node-jsonwebtoken#usage) for more details on the available configuration options.

Now we can update the `/auth/login` route to return a JWT.

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Request, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }
}

```

```typescript

import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return this.authService.login(req.user);
  }
}

```

Let's go ahead and test our routes using cURL again. You can test with any of the `user` objects hard-coded in the `UsersService`.

```bash

$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
$ # Note: above JWT truncated

```

#### Implementing Passport JWT [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-jwt)

We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. Passport can help us here too. It provides the [passport-jwt](https://github.com/mikenicholson/passport-jwt) strategy for securing RESTful endpoints with JSON Web Tokens. Start by creating a file called `jwt.strategy.ts` in the `auth` folder, and add the following code:

content\_copy auth/jwt.strategy.ts

JS  TS

```typescript

import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { jwtConstants } from './constants';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}

```

```typescript

import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { jwtConstants } from './constants';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload) {
    return { userId: payload.sub, username: payload.username };
  }
}

```

With our `JwtStrategy`, we've followed the same recipe described earlier for all Passport strategies. This strategy requires some initialization, so we do that by passing in an options object in the `super()` call. You can read more about the available options [here](https://github.com/mikenicholson/passport-jwt#configure-strategy). In our case, these options are:

- `jwtFromRequest`: supplies the method by which the JWT will be extracted from the `Request`. We will use the standard approach of supplying a bearer token in the Authorization header of our API requests. Other options are described [here](https://github.com/mikenicholson/passport-jwt#extracting-the-jwt-from-the-request).
- `ignoreExpiration`: just to be explicit, we choose the default `false` setting, which delegates the responsibility of ensuring that a JWT has not expired to the Passport module. This means that if our route is supplied with an expired JWT, the request will be denied and a `401 Unauthorized` response sent. Passport conveniently handles this automatically for us.
- `secretOrKey`: we are using the expedient option of supplying a symmetric secret for signing the token. Other options, such as a PEM-encoded public key, may be more appropriate for production apps (see [here](https://github.com/mikenicholson/passport-jwt#configure-strategy) for more information). In any case, as cautioned earlier, **do not expose this secret publicly**.

The `validate()` method deserves some discussion. For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our `validate()` method passing the decoded JSON as its single parameter. Based on the way JWT signing works, **we're guaranteed that we're receiving a valid token** that we have previously signed and issued to a valid user.

As a result of all this, our response to the `validate()` callback is trivial: we simply return an object containing the `userId` and `username` properties. Recall again that Passport will build a `user` object based on the return value of our `validate()` method, and attach it as a property on the `Request` object.

Additionally, you can return an array, where the first value is used to create a `user` object and the second value is used to create an `authInfo` object.

It's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our `validate()` method to extract more information about the user, resulting in a more enriched `user` object being available in our `Request`. This is also the place we may decide to do further token validation, such as looking up the `userId` in a list of revoked tokens, enabling us to perform token revocation. The model we've implemented here in our sample code is a fast, "stateless JWT" model, where each API call is immediately authorized based on the presence of a valid JWT, and a small bit of information about the requester (its `userId` and `username`) is available in our Request pipeline.

Add the new `JwtStrategy` as a provider in the `AuthModule`:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

By importing the same secret used when we signed the JWT, we ensure that the **verify** phase performed by Passport, and the **sign** phase performed in our AuthService, use a common secret.

Finally, we define the `JwtAuthGuard` class which extends the built-in `AuthGuard`:

content\_copy auth/jwt-auth.guard.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

```

#### Implement protected route and JWT strategy guards [\#](https://docs.nestjs.com/recipes/passport\#implement-protected-route-and-jwt-strategy-guards)

We can now implement our protected route and its associated Guard.

Open the `app.controller.ts` file and update it as shown below:

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Get, Request, Post, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './auth/jwt-auth.guard';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}

```

```typescript

import { Controller, Dependencies, Bind, Get, Request, Post, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './auth/jwt-auth.guard';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Dependencies(AuthService)
@Controller()
export class AppController {
  constructor(authService) {
    this.authService = authService;
  }

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  @Bind(Request())
  getProfile(req) {
    return req.user;
  }
}

```

Once again, we're applying the `AuthGuard` that the `@nestjs/passport` module has automatically provisioned for us when we configured the passport-jwt module. This Guard is referenced by its default name, `jwt`. When our `GET /profile` route is hit, the Guard will automatically invoke our passport-jwt custom configured strategy, validate the JWT, and assign the `user` property to the `Request` object.

Ensure the app is running, and test the routes using `cURL`.

```bash

$ # GET /profile
$ curl http://localhost:3000/profile
$ # result -> {"statusCode":401,"message":"Unauthorized"}

$ # POST /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm... }

$ # GET /profile using access_token returned from previous step as bearer code
$ curl http://localhost:3000/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."
$ # result -> {"userId":1,"username":"john"}

```

Note that in the `AuthModule`, we configured the JWT to have an expiration of `60 seconds`. This is probably too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs and the passport-jwt strategy. If you wait 60 seconds after authenticating before attempting a `GET /profile` request, you'll receive a `401 Unauthorized` response. This is because Passport automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application.

We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server.

#### Extending guards [\#](https://docs.nestjs.com/recipes/passport\#extending-guards)

In most cases, using a provided `AuthGuard` class is sufficient. However, there might be use-cases when you would like to simply extend the default error handling or authentication logic. For this, you can extend the built-in class and override methods within a sub-class.

content\_copy

```typescript

import {
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    // Add your custom authentication logic here
    // for example, call super.logIn(request) to establish a session.
    return super.canActivate(context);
  }

  handleRequest(err, user, info) {
    // You can throw an exception based on either "info" or "err" arguments
    if (err || !user) {
      throw err || new UnauthorizedException();
    }
    return user;
  }
}

```

In addition to extending the default error handling and authentication logic, we can allow authentication to go through a chain of strategies. The first strategy to succeed, redirect, or error will halt the chain. Authentication failures will proceed through each strategy in series, ultimately failing if all strategies fail.

content\_copy

```typescript

export class JwtAuthGuard extends AuthGuard(['strategy_jwt_1', 'strategy_jwt_2', '...']) { ... }

```

#### Enable authentication globally [\#](https://docs.nestjs.com/recipes/passport\#enable-authentication-globally)

If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a [global guard](https://docs.nestjs.com/guards#binding-guards) and instead of using `@UseGuards()` decorator on top of each controller, you could simply flag which routes should be public.

First, register the `JwtAuthGuard` as a global guard using the following construction (in any module):

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useClass: JwtAuthGuard,\
  },\
],

```

With this in place, Nest will automatically bind `JwtAuthGuard` to all endpoints.

Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the `SetMetadata` decorator factory function.

content\_copy

```typescript

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

```

In the file above, we exported two constants. One being our metadata key named `IS_PUBLIC_KEY`, and the other being our new decorator itself that we’re going to call `Public` (you can alternatively name it `SkipAuth` or `AllowAnon`, whatever fits your project).

Now that we have a custom `@Public()` decorator, we can use it to decorate any method, as follows:

content\_copy

```typescript

@Public()
@Get()
findAll() {
  return [];
}

```

Lastly, we need the `JwtAuthGuard` to return `true` when the `"isPublic"` metadata is found. For this, we'll use the `Reflector` class (read more [here](https://docs.nestjs.com/guards#putting-it-all-together)).

content\_copy

```typescript

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\
      context.getHandler(),\
      context.getClass(),\
    ]);
    if (isPublic) {
      return true;
    }
    return super.canActivate(context);
  }
}

```

#### Request-scoped strategies [\#](https://docs.nestjs.com/recipes/passport\#request-scoped-strategies)

The passport API is based on registering strategies to the global instance of the library. Therefore strategies are not designed to have request-dependent options or to be dynamically instantiated per request (read more about the [request-scoped](https://docs.nestjs.com/fundamentals/injection-scopes) providers). When you configure your strategy to be request-scoped, Nest will never instantiate it since it's not tied to any specific route. There is no physical way to determine which "request-scoped" strategies should be executed per request.

However, there are ways to dynamically resolve request-scoped providers within the strategy. For this, we leverage the [module reference](https://docs.nestjs.com/fundamentals/module-ref) feature.

First, open the `local.strategy.ts` file and inject the `ModuleRef` in the normal way:

content\_copy

```typescript

constructor(private moduleRef: ModuleRef) {
  super({
    passReqToCallback: true,
  });
}

```

> **Hint** The `ModuleRef` class is imported from the `@nestjs/core` package.

Be sure to set the `passReqToCallback` configuration property to `true`, as shown above.

In the next step, the request instance will be used to obtain the current context identifier, instead of generating a new one (read more about request context [here](https://docs.nestjs.com/fundamentals/module-ref#getting-current-sub-tree)).

Now, inside the `validate()` method of the `LocalStrategy` class, use the `getByRequest()` method of the `ContextIdFactory` class to create a context id based on the request object, and pass this to the `resolve()` call:

content\_copy

```typescript

async validate(
  request: Request,
  username: string,
  password: string,
) {
  const contextId = ContextIdFactory.getByRequest(request);
  // "AuthService" is a request-scoped provider
  const authService = await this.moduleRef.resolve(AuthService, contextId);
  ...
}

```

In the example above, the `resolve()` method will asynchronously return the request-scoped instance of the `AuthService` provider (we assumed that `AuthService` is marked as a request-scoped provider).

#### Customize Passport [\#](https://docs.nestjs.com/recipes/passport\#customize-passport)

Any standard Passport customization options can be passed the same way, using the `register()` method. The available options depend on the strategy being implemented. For example:

content\_copy

```typescript

PassportModule.register({ session: true });

```

You can also pass strategies an options object in their constructors to configure them.
For the local strategy you can pass e.g.:

content\_copy

```typescript

constructor(private authService: AuthService) {
  super({
    usernameField: 'email',
    passwordField: 'password',
  });
}

```

Take a look at the official [Passport Website](http://www.passportjs.org/docs/oauth/) for property names.

#### Named strategies [\#](https://docs.nestjs.com/recipes/passport\#named-strategies)

When implementing a strategy, you can provide a name for it by passing a second argument to the `PassportStrategy` function. If you don't do this, each strategy will have a default name (e.g., 'jwt' for jwt-strategy):

content\_copy

```typescript

export class JwtStrategy extends PassportStrategy(Strategy, 'myjwt')

```

Then, you refer to this via a decorator like `@UseGuards(AuthGuard('myjwt'))`.

#### GraphQL [\#](https://docs.nestjs.com/recipes/passport\#graphql)

In order to use an AuthGuard with [GraphQL](https://docs.nestjs.com/graphql/quick-start), extend the built-in `AuthGuard` class and override the `getRequest()` method.

content\_copy

```typescript

@Injectable()
export class GqlAuthGuard extends AuthGuard('jwt') {
  getRequest(context: ExecutionContext) {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req;
  }
}

```

To get the current authenticated user in your graphql resolver, you can define a `@CurrentUser()` decorator:

content\_copy

```typescript

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext) => {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req.user;
  },
);

```

To use above decorator in your resolver, be sure to include it as a parameter of your query or mutation:

content\_copy

```typescript

@Query(() => User)
@UseGuards(GqlAuthGuard)
whoAmI(@CurrentUser() user: User) {
  return this.usersService.findById(user.id);
}

```

For the passport-local strategy, you'll also need to add the GraphQL context's arguments to the request body so Passport can access them for validation. Otherwise, you'll get an Unauthorized error.

content\_copy

```typescript

@Injectable()
export class GqlLocalAuthGuard extends AuthGuard('local') {
  getRequest(context: ExecutionContext) {
    const gqlExecutionContext = GqlExecutionContext.create(context);
    const gqlContext = gqlExecutionContext.getContext();
    const gqlArgs = gqlExecutionContext.getArgs();

    gqlContext.req.body = { ...gqlContext.req.body, ...gqlArgs };
    return gqlContext.req;
  }
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Guards Overview
- [Guards](https://docs.nestjs.com/guards#guards)
- [Authorization guard](https://docs.nestjs.com/guards#authorization-guard)
- [Execution context](https://docs.nestjs.com/guards#execution-context)
- [Role-based authentication](https://docs.nestjs.com/guards#role-based-authentication)
- [Binding guards](https://docs.nestjs.com/guards#binding-guards)
- [Setting roles per handler](https://docs.nestjs.com/guards#setting-roles-per-handler)
- [Putting it all together](https://docs.nestjs.com/guards#putting-it-all-together)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/guards.md "Suggest Edits")

### Guards

A guard is a class annotated with the `@Injectable()` decorator, which implements the `CanActivate` interface.

![](https://docs.nestjs.com/assets/Guards_1.png)

Guards have a **single responsibility**. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as **authorization**. Authorization (and its cousin, **authentication**, with which it usually collaborates) has typically been handled by [middleware](https://docs.nestjs.com/middleware) in traditional Express applications. Middleware is a fine choice for authentication, since things like token validation and attaching properties to the `request` object are not strongly connected with a particular route context (and its metadata).

But middleware, by its nature, is dumb. It doesn't know which handler will be executed after calling the `next()` function. On the other hand, **Guards** have access to the `ExecutionContext` instance, and thus know exactly what's going to be executed next. They're designed, much like exception filters, pipes, and interceptors, to let you interpose processing logic at exactly the right point in the request/response cycle, and to do so declaratively. This helps keep your code DRY and declarative.

> **Hint** Guards are executed **after** all middleware, but **before** any interceptor or pipe.

#### Authorization guard [\#](https://docs.nestjs.com/guards\#authorization-guard)

As mentioned, **authorization** is a great use case for Guards because specific routes should be available only when the caller (usually a specific authenticated user) has sufficient permissions. The `AuthGuard` that we'll build now assumes an authenticated user (and that, therefore, a token is attached to the request headers). It will extract and validate the token, and use the extracted information to determine whether the request can proceed or not.

content\_copy auth.guard.ts

JS  TS

```typescript

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class AuthGuard {
  async canActivate(context) {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}

```

> **Hint** If you are looking for a real-world example on how to implement an authentication mechanism in your application, visit [this chapter](https://docs.nestjs.com/security/authentication). Likewise, for more sophisticated authorization example, check [this page](https://docs.nestjs.com/security/authorization).

The logic inside the `validateRequest()` function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.

Every guard must implement a `canActivate()` function. This function should return a boolean, indicating whether the current request is allowed or not. It can return the response either synchronously or asynchronously (via a `Promise` or `Observable`). Nest uses the return value to control the next action:

- if it returns `true`, the request will be processed.
- if it returns `false`, Nest will deny the request.

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Execution context [\#](https://docs.nestjs.com/guards\#execution-context)

The `canActivate()` function takes a single argument, the `ExecutionContext` instance. The `ExecutionContext` inherits from `ArgumentsHost`. We saw `ArgumentsHost` previously in the exception filters chapter. In the sample above, we are just using the same helper methods defined on `ArgumentsHost` that we used earlier, to get a reference to the `Request` object. You can refer back to the **Arguments host** section of the [exception filters](https://docs.nestjs.com/exception-filters#arguments-host) chapter for more on this topic.

By extending `ArgumentsHost`, `ExecutionContext` also adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic guards that can work across a broad set of controllers, methods, and execution contexts. Learn more about `ExecutionContext` [here](https://docs.nestjs.com/fundamentals/execution-context).

#### Role-based authentication [\#](https://docs.nestjs.com/guards\#role-based-authentication)

Let's build a more functional guard that permits access only to users with a specific role. We'll start with a basic guard template, and build on it in the coming sections. For now, it allows all requests to proceed:

content\_copy roles.guard.ts

JS  TS

```typescript

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class RolesGuard {
  canActivate(context) {
    return true;
  }
}

```

#### Binding guards [\#](https://docs.nestjs.com/guards\#binding-guards)

Like pipes and exception filters, guards can be **controller-scoped**, method-scoped, or global-scoped. Below, we set up a controller-scoped guard using the `@UseGuards()` decorator. This decorator may take a single argument, or a comma-separated list of arguments. This lets you easily apply the appropriate set of guards with one declaration.

content\_copy

JS  TS

```typescript

@Controller('cats')
@UseGuards(RolesGuard)
export class CatsController {}

```

> **Hint** The `@UseGuards()` decorator is imported from the `@nestjs/common` package.

Above, we passed the `RolesGuard` class (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and exception filters, we can also pass an in-place instance:

content\_copy

JS  TS

```typescript

@Controller('cats')
@UseGuards(new RolesGuard())
export class CatsController {}

```

The construction above attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the `@UseGuards()` decorator at the **method level**.

In order to set up a global guard, use the `useGlobalGuards()` method of the Nest application instance:

content\_copy

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
app.useGlobalGuards(new RolesGuard());

```

> **Notice** In the case of hybrid apps the `useGlobalGuards()` method doesn't set up guards for gateways and microservices by default (see [Hybrid application](https://docs.nestjs.com/faq/hybrid-application) for information on how to change this behavior). For "standard" (non-hybrid) microservice apps, `useGlobalGuards()` does mount the guards globally.

Global guards are used across the whole application, for every controller and every route handler. In terms of dependency injection, global guards registered from outside of any module (with `useGlobalGuards()` as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can set up a guard directly from any module using the following construction:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';

@Module({
  providers: [\
    {\
      provide: APP_GUARD,\
      useClass: RolesGuard,\
    },\
  ],
})
export class AppModule {}

```

> **Hint** When using this approach to perform dependency injection for the guard, note that regardless of the
> module where this construction is employed, the guard is, in fact, global. Where should this be done? Choose the module
> where the guard ( `RolesGuard` in the example above) is defined. Also, `useClass` is not the only way of dealing with
> custom provider registration. Learn more [here](https://docs.nestjs.com/fundamentals/custom-providers).

#### Setting roles per handler [\#](https://docs.nestjs.com/guards\#setting-roles-per-handler)

Our `RolesGuard` is working, but it's not very smart yet. We're not yet taking advantage of the most important guard feature - the [execution context](https://docs.nestjs.com/fundamentals/execution-context). It doesn't yet know about roles, or which roles are allowed for each handler. The `CatsController`, for example, could have different permission schemes for different routes. Some might be available only for an admin user, and others could be open for everyone. How can we match roles to routes in a flexible and reusable way?

This is where **custom metadata** comes into play (learn more [here](https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata)). Nest provides the ability to attach custom **metadata** to route handlers through either decorators created via `Reflector.createDecorator` static method, or the built-in `@SetMetadata()` decorator.

For example, let's create a `@Roles()` decorator using the `Reflector.createDecorator` method that will attach the metadata to the handler. `Reflector` is provided out of the box by the framework and exposed from the `@nestjs/core` package.

content\_copy roles.decorator.ts

JS  TS

```ts

import { Reflector } from '@nestjs/core';

export const Roles = Reflector.createDecorator<string[]>();

```

The `Roles` decorator here is a function that takes a single argument of type `string[]`.

Now, to use this decorator, we simply annotate the handler with it:

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@Roles(['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@Roles(['admin'])
@Bind(Body())
async create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

Here we've attached the `Roles` decorator metadata to the `create()` method, indicating that only users with the `admin` role should be allowed to access this route.

Alternatively, instead of using the `Reflector.createDecorator` method, we could use the built-in `@SetMetadata()` decorator. Learn more about [here](https://docs.nestjs.com/fundamentals/execution-context#low-level-approach).

#### Putting it all together [\#](https://docs.nestjs.com/guards\#putting-it-all-together)

Let's now go back and tie this together with our `RolesGuard`. Currently, it simply returns `true` in all cases, allowing every request to proceed. We want to make the return value conditional based on comparing the **roles assigned to the current user** to the actual roles required by the current route being processed. In order to access the route's role(s) (custom metadata), we'll use the `Reflector` helper class again, as follows:

content\_copy roles.guard.ts

JS  TS

```typescript

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Roles } from './roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get(Roles, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    return matchRoles(roles, user.roles);
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Roles } from './roles.decorator';

@Injectable()
@Dependencies(Reflector)
export class RolesGuard {
  constructor(reflector) {
    this.reflector = reflector;
  }

  canActivate(context) {
    const roles = this.reflector.get(Roles, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    return matchRoles(roles, user.roles);
  }
}

```

> **Hint** In the node.js world, it's common practice to attach the authorized user to the `request` object. Thus, in our sample code above, we are assuming that `request.user` contains the user instance and allowed roles. In your app, you will probably make that association in your custom **authentication guard** (or middleware). Check [this chapter](https://docs.nestjs.com/security/authentication) for more information on this topic.

> **Warning** The logic inside the `matchRoles()` function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.

Refer to the [Reflection and metadata](https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata) section of the **Execution context** chapter for more details on utilizing `Reflector` in a context-sensitive way.

When a user with insufficient privileges requests an endpoint, Nest automatically returns the following response:

content\_copy

```typescript

{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}

```

Note that behind the scenes, when a guard returns `false`, the framework throws a `ForbiddenException`. If you want to return a different error response, you should throw your own specific exception. For example:

content\_copy

```typescript

throw new UnauthorizedException();

```

Any exception thrown by a guard will be handled by the [exceptions layer](https://docs.nestjs.com/exception-filters) (global exceptions filter and any exceptions filters that are applied to the current context).

> **Hint** If you are looking for a real-world example on how to implement authorization, check [this chapter](https://docs.nestjs.com/security/authorization).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Authentication Guide
- [Authentication](https://docs.nestjs.com/security/authentication#authentication)
- [Creating an authentication module](https://docs.nestjs.com/security/authentication#creating-an-authentication-module)
- [Implementing the "Sign in" endpoint](https://docs.nestjs.com/security/authentication#implementing-the-sign-in-endpoint)
- [JWT token](https://docs.nestjs.com/security/authentication#jwt-token)
- [Implementing the authentication guard](https://docs.nestjs.com/security/authentication#implementing-the-authentication-guard)
- [Enable authentication globally](https://docs.nestjs.com/security/authentication#enable-authentication-globally)
- [Passport integration](https://docs.nestjs.com/security/authentication#passport-integration)
- [Example](https://docs.nestjs.com/security/authentication#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/authentication.md "Suggest Edits")

### Authentication

Authentication is an **essential** part of most applications. There are many different approaches and strategies to handle authentication. The approach taken for any project depends on its particular application requirements. This chapter presents several approaches to authentication that can be adapted to a variety of different requirements.

Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a [bearer token](https://tools.ietf.org/html/rfc6750) in an authorization header on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT.

We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request.

#### Creating an authentication module [\#](https://docs.nestjs.com/security/authentication\#creating-an-authentication-module)

We'll start by generating an `AuthModule` and in it, an `AuthService` and an `AuthController`. We'll use the `AuthService` to implement the authentication logic, and the `AuthController` to expose the authentication endpoints.

```bash

$ nest g module auth
$ nest g controller auth
$ nest g service auth

```

As we implement the `AuthService`, we'll find it useful to encapsulate user operations in a `UsersService`, so let's generate that module and service now:

```bash

$ nest g module users
$ nest g service users

```

Replace the default contents of these generated files as shown below. For our sample app, the `UsersService` simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.).

content\_copy users/users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';

// This should be a real class/interface representing a user entity
export type User = any;

@Injectable()
export class UsersService {
  private readonly users = [\
    {\
      userId: 1,\
      username: 'john',\
      password: 'changeme',\
    },\
    {\
      userId: 2,\
      username: 'maria',\
      password: 'guess',\
    },\
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find(user => user.username === username);
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  constructor() {
    this.users = [\
      {\
        userId: 1,\
        username: 'john',\
        password: 'changeme',\
      },\
      {\
        userId: 2,\
        username: 'maria',\
        password: 'guess',\
      },\
    ];
  }

  async findOne(username) {
    return this.users.find(user => user.username === username);
  }
}

```

In the `UsersModule`, the only change needed is to add the `UsersService` to the exports array of the `@Module` decorator so that it is visible outside this module (we'll soon use it in our `AuthService`).

content\_copy users/users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

#### Implementing the "Sign in" endpoint [\#](https://docs.nestjs.com/security/authentication\#implementing-the-sign-in-endpoint)

Our `AuthService` has the job of retrieving a user and verifying the password. We create a `signIn()` method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. This is a common practice when returning user objects, as you don't want to expose sensitive fields like passwords or other security keys.

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}

  async signIn(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const { password, ...result } = user;
    // TODO: Generate a JWT and return it here
    // instead of the user object
    return result;
  }
}

```

```typescript

import { Injectable, Dependencies, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
@Dependencies(UsersService)
export class AuthService {
  constructor(usersService) {
    this.usersService = usersService;
  }

  async signIn(username: string, pass: string) {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const { password, ...result } = user;
    // TODO: Generate a JWT and return it here
    // instead of the user object
    return result;
  }
}

```

> **Warning** Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like [bcrypt](https://github.com/kelektiv/node.bcrypt.js#readme), with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the **incoming** password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. **Don't do this in your real app!**

Now, we update our `AuthModule` to import the `UsersModule`.

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}

```

With this in place, let's open up the `AuthController` and add a `signIn()` method to it. This method will be called by the client to authenticate a user. It will receive the username and password in the request body, and will return a JWT token if the user is authenticated.

content\_copy auth/auth.controller.ts

JS  TS

```typescript

import { Body, Controller, Post, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }
}

```

> **Hint** Ideally, instead of using the `Record<string, any>` type, we should use a DTO class to define the shape of the request body. See the [validation](https://docs.nestjs.com/techniques/validation) chapter for more information.

## Learn the right way!

- 19 chapters
- Authn & Authz
- Official certificate
- Deep-dive sessions

[Purchase the Authentication course](https://courses.nestjs.com/#authentication "Courses | NestJS - A node.js framework built on top of TypeScript")

#### JWT token [\#](https://docs.nestjs.com/security/authentication\#jwt-token)

We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:

- Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT.
- Create API routes which are protected based on the presence of a valid JWT as a bearer token

We'll need to install one additional package to support our JWT requirements:

```bash

$ npm install --save @nestjs/jwt

```

> **Hint** The `@nestjs/jwt` package (see more [here](https://github.com/nestjs/jwt)) is a utility package that helps with JWT manipulation. This includes generating and verifying JWT tokens.

To keep our services cleanly modularized, we'll handle generating the JWT in the `authService`. Open the `auth.service.ts` file in the `auth` folder, inject the `JwtService`, and update the `signIn` method to generate a JWT token as shown below:

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(
    username: string,
    pass: string,
  ): Promise<{ access_token: string }> {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const payload = { sub: user.userId, username: user.username };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}

```

```typescript

import { Injectable, Dependencies, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Dependencies(UsersService, JwtService)
@Injectable()
export class AuthService {
  constructor(usersService, jwtService) {
    this.usersService = usersService;
    this.jwtService = jwtService;
  }

  async signIn(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}

```

We're using the `@nestjs/jwt` library, which supplies a `signAsync()` function to generate our JWT from a subset of the `user` object properties, which we then return as a simple object with a single `access_token` property. Note: we choose a property name of `sub` to hold our `userId` value to be consistent with JWT standards.

We now need to update the `AuthModule` to import the new dependencies and configure the `JwtModule`.

First, create `constants.ts` in the `auth` folder, and add the following code:

content\_copy auth/constants.ts

JS  TS

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

We'll use this to share our key between the JWT signing and verifying steps.

> **Warning** **Do not expose this key publicly**. We have done so here to make it clear what the code is doing, but in a production system **you must protect this key** using appropriate measures such as a secrets vault, environment variable, or configuration service.

Now, open `auth.module.ts` in the `auth` folder and update it to look like this:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    JwtModule.register({\
      global: true,\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    JwtModule.register({\
      global: true,\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}

```

> **Hint** We're registering the `JwtModule` as global to make things easier for us. This means that we don't need to import the `JwtModule` anywhere else in our application.

We configure the `JwtModule` using `register()`, passing in a configuration object. See [here](https://github.com/nestjs/jwt/blob/master/README.md) for more on the Nest `JwtModule` and [here](https://github.com/auth0/node-jsonwebtoken#usage) for more details on the available configuration options.

Let's go ahead and test our routes using cURL again. You can test with any of the `user` objects hard-coded in the `UsersService`.

```bash

$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
$ # Note: above JWT truncated

```

#### Implementing the authentication guard [\#](https://docs.nestjs.com/security/authentication\#implementing-the-authentication-guard)

We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. We'll do this by creating an `AuthGuard` that we can use to protect our routes.

content\_copy auth/auth.guard.ts

JS  TS

```typescript

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { jwtConstants } from './constants';
import { Request } from 'express';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(
        token,
        {
          secret: jwtConstants.secret
        }
      );
      // 💡 We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}

```

We can now implement our protected route and register our `AuthGuard` to protect it.

Open the `auth.controller.ts` file and update it as shown below:

content\_copy auth.controller.ts

JS  TS

```typescript

import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Post,
  Request,
  UseGuards
} from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}

```

We're applying the `AuthGuard` that we just created to the `GET /profile` route so that it will be protected.

Ensure the app is running, and test the routes using `cURL`.

```bash

$ # GET /profile
$ curl http://localhost:3000/auth/profile
{"statusCode":401,"message":"Unauthorized"}

$ # POST /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."}

$ # GET /profile using access_token returned from previous step as bearer code
$ curl http://localhost:3000/auth/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."
{"sub":1,"username":"john","iat":...,"exp":...}

```

Note that in the `AuthModule`, we configured the JWT to have an expiration of `60 seconds`. This is too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs. If you wait 60 seconds after authenticating before attempting a `GET /auth/profile` request, you'll receive a `401 Unauthorized` response. This is because `@nestjs/jwt` automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application.

We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server.

#### Enable authentication globally [\#](https://docs.nestjs.com/security/authentication\#enable-authentication-globally)

If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a [global guard](https://docs.nestjs.com/guards#binding-guards) and instead of using `@UseGuards()` decorator on top of each controller, you could simply flag which routes should be public.

First, register the `AuthGuard` as a global guard using the following construction (in any module, for example, in the `AuthModule`):

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useClass: AuthGuard,\
  },\
],

```

With this in place, Nest will automatically bind `AuthGuard` to all endpoints.

Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the `SetMetadata` decorator factory function.

content\_copy

```typescript

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

```

In the file above, we exported two constants. One being our metadata key named `IS_PUBLIC_KEY`, and the other being our new decorator itself that we’re going to call `Public` (you can alternatively name it `SkipAuth` or `AllowAnon`, whatever fits your project).

Now that we have a custom `@Public()` decorator, we can use it to decorate any method, as follows:

content\_copy

```typescript

@Public()
@Get()
findAll() {
  return [];
}

```

Lastly, we need the `AuthGuard` to return `true` when the `"isPublic"` metadata is found. For this, we'll use the `Reflector` class (read more [here](https://docs.nestjs.com/guards#putting-it-all-together)).

content\_copy

```typescript

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService, private reflector: Reflector) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\
      context.getHandler(),\
      context.getClass(),\
    ]);
    if (isPublic) {
      // 💡 See this condition
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });
      // 💡 We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}

```

#### Passport integration [\#](https://docs.nestjs.com/security/authentication\#passport-integration)

[Passport](https://github.com/jaredhanson/passport) is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a **Nest** application using the `@nestjs/passport` module.

To learn how you can integrate Passport with NestJS, check out this [chapter](https://docs.nestjs.com/recipes/passport).

#### Example [\#](https://docs.nestjs.com/security/authentication\#example)

You can find a complete version of the code in this chapter [here](https://github.com/nestjs/nest/tree/master/sample/19-auth-jwt).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Interceptors Overview
- [Interceptors](https://docs.nestjs.com/interceptors#interceptors)
- [Basics](https://docs.nestjs.com/interceptors#basics)
- [Execution context](https://docs.nestjs.com/interceptors#execution-context)
- [Call handler](https://docs.nestjs.com/interceptors#call-handler)
- [Aspect interception](https://docs.nestjs.com/interceptors#aspect-interception)
- [Binding interceptors](https://docs.nestjs.com/interceptors#binding-interceptors)
- [Response mapping](https://docs.nestjs.com/interceptors#response-mapping)
- [Exception mapping](https://docs.nestjs.com/interceptors#exception-mapping)
- [Stream overriding](https://docs.nestjs.com/interceptors#stream-overriding)
- [More operators](https://docs.nestjs.com/interceptors#more-operators)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/interceptors.md "Suggest Edits")

### Interceptors

An interceptor is a class annotated with the `@Injectable()` decorator and implements the `NestInterceptor` interface.

![](https://docs.nestjs.com/assets/Interceptors_1.png)

Interceptors have a set of useful capabilities which are inspired by the [Aspect Oriented Programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) (AOP) technique. They make it possible to:

- bind extra logic before / after method execution
- transform the result returned from a function
- transform the exception thrown from a function
- extend the basic function behavior
- completely override a function depending on specific conditions (e.g., for caching purposes)

#### Basics [\#](https://docs.nestjs.com/interceptors\#basics)

Each interceptor implements the `intercept()` method, which takes two arguments. The first one is the `ExecutionContext` instance (exactly the same object as for [guards](https://docs.nestjs.com/guards)). The `ExecutionContext` inherits from `ArgumentsHost`. We saw `ArgumentsHost` before in the exception filters chapter. There, we saw that it's a wrapper around arguments that have been passed to the original handler, and contains different arguments arrays based on the type of the application. You can refer back to the [exception filters](https://docs.nestjs.com/exception-filters#arguments-host) for more on this topic.

#### Execution context [\#](https://docs.nestjs.com/interceptors\#execution-context)

By extending `ArgumentsHost`, `ExecutionContext` also adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic interceptors that can work across a broad set of controllers, methods, and execution contexts. Learn more about `ExecutionContext` [here](https://docs.nestjs.com/fundamentals/execution-context).

#### Call handler [\#](https://docs.nestjs.com/interceptors\#call-handler)

The second argument is a `CallHandler`. The `CallHandler` interface implements the `handle()` method, which you can use to invoke the route handler method at some point in your interceptor. If you don't call the `handle()` method in your implementation of the `intercept()` method, the route handler method won't be executed at all.

This approach means that the `intercept()` method effectively **wraps** the request/response stream. As a result, you may implement custom logic **both before and after** the execution of the final route handler. It's clear that you can write code in your `intercept()` method that executes **before** calling `handle()`, but how do you affect what happens afterward? Because the `handle()` method returns an `Observable`, we can use powerful [RxJS](https://github.com/ReactiveX/rxjs) operators to further manipulate the response. Using Aspect Oriented Programming terminology, the invocation of the route handler (i.e., calling `handle()`) is called a [Pointcut](https://en.wikipedia.org/wiki/Pointcut), indicating that it's the point at which our additional logic is inserted.

Consider, for example, an incoming `POST /cats` request. This request is destined for the `create()` handler defined inside the `CatsController`. If an interceptor which does not call the `handle()` method is called anywhere along the way, the `create()` method won't be executed. Once `handle()` is called (and its `Observable` has been returned), the `create()` handler will be triggered. And once the response stream is received via the `Observable`, additional operations can be performed on the stream, and a final result returned to the caller.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Aspect interception [\#](https://docs.nestjs.com/interceptors\#aspect-interception)

The first use case we'll look at is to use an interceptor to log user interaction (e.g., storing user calls, asynchronously dispatching events or calculating a timestamp). We show a simple `LoggingInterceptor` below:

content\_copy logging.interceptor.ts

JS  TS

```typescript

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() => console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor {
  intercept(context, next) {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() => console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}

```

> **Hint** The `NestInterceptor<T, R>` is a generic interface in which `T` indicates the type of an `Observable<T>` (supporting the response stream), and `R` is the type of the value wrapped by `Observable<R>`.

> **Notice** Interceptors, like controllers, providers, guards, and so on, can **inject dependencies** through their `constructor`.

Since `handle()` returns an RxJS `Observable`, we have a wide choice of operators we can use to manipulate the stream. In the example above, we used the `tap()` operator, which invokes our anonymous logging function upon graceful or exceptional termination of the observable stream, but doesn't otherwise interfere with the response cycle.

#### Binding interceptors [\#](https://docs.nestjs.com/interceptors\#binding-interceptors)

In order to set up the interceptor, we use the `@UseInterceptors()` decorator imported from the `@nestjs/common` package. Like [pipes](https://docs.nestjs.com/pipes) and [guards](https://docs.nestjs.com/guards), interceptors can be controller-scoped, method-scoped, or global-scoped.

content\_copy cats.controller.ts

JS  TS

```typescript

@UseInterceptors(LoggingInterceptor)
export class CatsController {}

```

> **Hint** The `@UseInterceptors()` decorator is imported from the `@nestjs/common` package.

Using the above construction, each route handler defined in `CatsController` will use `LoggingInterceptor`. When someone calls the `GET /cats` endpoint, you'll see the following output in your standard output:

content\_copy

```typescript

Before...
After... 1ms

```

Note that we passed the `LoggingInterceptor` class (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes, guards, and exception filters, we can also pass an in-place instance:

content\_copy cats.controller.ts

JS  TS

```typescript

@UseInterceptors(new LoggingInterceptor())
export class CatsController {}

```

As mentioned, the construction above attaches the interceptor to every handler declared by this controller. If we want to restrict the interceptor's scope to a single method, we simply apply the decorator at the **method level**.

In order to set up a global interceptor, we use the `useGlobalInterceptors()` method of the Nest application instance:

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
app.useGlobalInterceptors(new LoggingInterceptor());

```

Global interceptors are used across the whole application, for every controller and every route handler. In terms of dependency injection, global interceptors registered from outside of any module (with `useGlobalInterceptors()`, as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can set up an interceptor **directly from any module** using the following construction:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';

@Module({
  providers: [\
    {\
      provide: APP_INTERCEPTOR,\
      useClass: LoggingInterceptor,\
    },\
  ],
})
export class AppModule {}

```

> **Hint** When using this approach to perform dependency injection for the interceptor, note that regardless of the
> module where this construction is employed, the interceptor is, in fact, global. Where should this be done? Choose the module
> where the interceptor ( `LoggingInterceptor` in the example above) is defined. Also, `useClass` is not the only way of dealing with custom provider registration. Learn more [here](https://docs.nestjs.com/fundamentals/custom-providers).

#### Response mapping [\#](https://docs.nestjs.com/interceptors\#response-mapping)

We already know that `handle()` returns an `Observable`. The stream contains the value **returned** from the route handler, and thus we can easily mutate it using RxJS's `map()` operator.

> **Warning** The response mapping feature doesn't work with the library-specific response strategy (using the `@Res()` object directly is forbidden).

Let's create the `TransformInterceptor`, which will modify each response in a trivial way to demonstrate the process. It will use RxJS's `map()` operator to assign the response object to the `data` property of a newly created object, returning the new object to the client.

content\_copy transform.interceptor.ts

JS  TS

```typescript

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {
    return next.handle().pipe(map(data => ({ data })));
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor {
  intercept(context, next) {
    return next.handle().pipe(map(data => ({ data })));
  }
}

```

> **Hint** Nest interceptors work with both synchronous and asynchronous `intercept()` methods. You can simply switch the method to `async` if necessary.

With the above construction, when someone calls the `GET /cats` endpoint, the response would look like the following (assuming that route handler returns an empty array `[]`):

```json

{
  "data": []
}

```

Interceptors have great value in creating re-usable solutions to requirements that occur across an entire application.
For example, imagine we need to transform each occurrence of a `null` value to an empty string `''`. We can do it using one line of code and bind the interceptor globally so that it will automatically be used by each registered handler.

content\_copy

JS  TS

```typescript

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class ExcludeNullInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(map(value => value === null ? '' : value ));
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { map } from 'rxjs/operators';

@Injectable()
export class ExcludeNullInterceptor {
  intercept(context, next) {
    return next
      .handle()
      .pipe(map(value => value === null ? '' : value ));
  }
}

```

#### Exception mapping [\#](https://docs.nestjs.com/interceptors\#exception-mapping)

Another interesting use-case is to take advantage of RxJS's `catchError()` operator to override thrown exceptions:

content\_copy errors.interceptor.ts

JS  TS

```typescript

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  BadGatewayException,
  CallHandler,
} from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(
        catchError(err => throwError(() => new BadGatewayException())),
      );
  }
}

```

```typescript

import { Injectable, BadGatewayException } from '@nestjs/common';
import { throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ErrorsInterceptor {
  intercept(context, next) {
    return next
      .handle()
      .pipe(
        catchError(err => throwError(() => new BadGatewayException())),
      );
  }
}

```

#### Stream overriding [\#](https://docs.nestjs.com/interceptors\#stream-overriding)

There are several reasons why we may sometimes want to completely prevent calling the handler and return a different value instead. An obvious example is to implement a cache to improve response time. Let's take a look at a simple **cache interceptor** that returns its response from a cache. In a realistic example, we'd want to consider other factors like TTL, cache invalidation, cache size, etc., but that's beyond the scope of this discussion. Here we'll provide a basic example that demonstrates the main concept.

content\_copy cache.interceptor.ts

JS  TS

```typescript

import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable, of } from 'rxjs';

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const isCached = true;
    if (isCached) {
      return of([]);
    }
    return next.handle();
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { of } from 'rxjs';

@Injectable()
export class CacheInterceptor {
  intercept(context, next) {
    const isCached = true;
    if (isCached) {
      return of([]);
    }
    return next.handle();
  }
}

```

Our `CacheInterceptor` has a hardcoded `isCached` variable and a hardcoded response `[]` as well. The key point to note is that we return a new stream here, created by the RxJS `of()` operator, therefore the route handler **won't be called** at all. When someone calls an endpoint that makes use of `CacheInterceptor`, the response (a hardcoded, empty array) will be returned immediately. In order to create a generic solution, you can take advantage of `Reflector` and create a custom decorator. The `Reflector` is well described in the [guards](https://docs.nestjs.com/guards) chapter.

#### More operators [\#](https://docs.nestjs.com/interceptors\#more-operators)

The possibility of manipulating the stream using RxJS operators gives us many capabilities. Let's consider another common use case. Imagine you would like to handle **timeouts** on route requests. When your endpoint doesn't return anything after a period of time, you want to terminate with an error response. The following construction enables this:

content\_copy timeout.interceptor.ts

JS  TS

```typescript

import { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from '@nestjs/common';
import { Observable, throwError, TimeoutError } from 'rxjs';
import { catchError, timeout } from 'rxjs/operators';

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      timeout(5000),
      catchError(err => {
        if (err instanceof TimeoutError) {
          return throwError(() => new RequestTimeoutException());
        }
        return throwError(() => err);
      }),
    );
  };
};

```

```typescript

import { Injectable, RequestTimeoutException } from '@nestjs/common';
import { Observable, throwError, TimeoutError } from 'rxjs';
import { catchError, timeout } from 'rxjs/operators';

@Injectable()
export class TimeoutInterceptor {
  intercept(context, next) {
    return next.handle().pipe(
      timeout(5000),
      catchError(err => {
        if (err instanceof TimeoutError) {
          return throwError(() => new RequestTimeoutException());
        }
        return throwError(() => err);
      }),
    );
  };
};

```

After 5 seconds, request processing will be canceled. You can also add custom logic before throwing `RequestTimeoutException` (e.g. release resources).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Queues Guide
- [Queues](https://docs.nestjs.com/techniques/queues#queues)
- [BullMQ installation](https://docs.nestjs.com/techniques/queues#bullmq-installation)
- [Named configurations](https://docs.nestjs.com/techniques/queues#named-configurations)
- [Producers](https://docs.nestjs.com/techniques/queues#producers)
- [Job options](https://docs.nestjs.com/techniques/queues#job-options)
- [Consumers](https://docs.nestjs.com/techniques/queues#consumers)
- [Request-scoped consumers](https://docs.nestjs.com/techniques/queues#request-scoped-consumers)
- [Event listeners](https://docs.nestjs.com/techniques/queues#event-listeners)
- [Queue management](https://docs.nestjs.com/techniques/queues#queue-management)
- [Separate processes](https://docs.nestjs.com/techniques/queues#separate-processes)
- [Async configuration](https://docs.nestjs.com/techniques/queues#async-configuration)
- [Manual registration](https://docs.nestjs.com/techniques/queues#manual-registration)
- [Bull installation](https://docs.nestjs.com/techniques/queues#bull-installation)
- [Named configurations](https://docs.nestjs.com/techniques/queues#named-configurations-1)
- [Producers](https://docs.nestjs.com/techniques/queues#producers-1)
- [Named jobs](https://docs.nestjs.com/techniques/queues#named-jobs)
- [Job options](https://docs.nestjs.com/techniques/queues#job-options-1)
- [Consumers](https://docs.nestjs.com/techniques/queues#consumers-1)
- [Request-scoped consumers](https://docs.nestjs.com/techniques/queues#request-scoped-consumers-1)
- [Event listeners](https://docs.nestjs.com/techniques/queues#event-listeners-1)
- [Queue management](https://docs.nestjs.com/techniques/queues#queue-management-1)
- [Separate processes](https://docs.nestjs.com/techniques/queues#separate-processes-1)
- [Async configuration](https://docs.nestjs.com/techniques/queues#async-configuration-1)
- [Example](https://docs.nestjs.com/techniques/queues#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/queues.md "Suggest Edits")

### Queues

Queues are a powerful design pattern that help you deal with common application scaling and performance challenges. Some examples of problems that Queues can help you solve are:

- Smooth out processing peaks. For example, if users can initiate resource-intensive tasks at arbitrary times, you can add these tasks to a queue instead of performing them synchronously. Then you can have worker processes pull tasks from the queue in a controlled manner. You can easily add new Queue consumers to scale up the back-end task handling as the application scales up.
- Break up monolithic tasks that may otherwise block the Node.js event loop. For example, if a user request requires CPU intensive work like audio transcoding, you can delegate this task to other processes, freeing up user-facing processes to remain responsive.
- Provide a reliable communication channel across various services. For example, you can queue tasks (jobs) in one process or service, and consume them in another. You can be notified (by listening for status events) upon completion, error or other state changes in the job life cycle from any process or service. When Queue producers or consumers fail, their state is preserved and task handling can restart automatically when nodes are restarted.

Nest provides the `@nestjs/bullmq` package for BullMQ integration and `@nestjs/bull` package for Bull integration. Both packages are abstractions/wrappers on top of their respective libraries, which were developed by the same team. Bull is currently in maintenance mode, with the team focusing on fixing bugs, while BullMQ is actively developed, featuring a modern TypeScript implementation and a different set of features. If Bull meets your requirements, it remains a reliable and battle-tested choice. The Nest packages make it easy to integrate both, BullMQ or Bull Queues, into your Nest application in a friendly way.

Both BullMQ and Bull use [Redis](https://redis.io/) to persist job data, so you'll need to have Redis installed on your system. Because they are Redis-backed, your Queue architecture can be completely distributed and platform-independent. For example, you can have some Queue [producers](https://docs.nestjs.com/techniques/queues#producers) and [consumers](https://docs.nestjs.com/techniques/queues#consumers) and [listeners](https://docs.nestjs.com/techniques/queues#event-listeners) running in Nest on one (or several) nodes, and other producers, consumers and listeners running on other Node.js platforms on other network nodes.

This chapter covers the `@nestjs/bullmq` and `@nestjs/bull` packages. We also recommend reading the [BullMQ](https://docs.bullmq.io/) and [Bull](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md) documentation for more background and specific implementation details.

#### BullMQ installation [\#](https://docs.nestjs.com/techniques/queues\#bullmq-installation)

To begin using BullMQ, we first install the required dependencies.

```bash

$ npm install --save @nestjs/bullmq bullmq

```

Once the installation process is complete, we can import the `BullModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';

@Module({
  imports: [\
    BullModule.forRoot({\
      connection: {\
        host: 'localhost',\
        port: 6379,\
      },\
    }),\
  ],
})
export class AppModule {}

```

The `forRoot()` method is used to register a `bullmq` package configuration object that will be used by all queues registered in the application (unless specified otherwise). For your reference, the following are a few of the properties within a configuration object:

- `connection: ConnectionOptions` \- Options to configure the Redis connection. See [Connections](https://docs.bullmq.io/guide/connections) for more information. Optional.
- `prefix: string` \- Prefix for all queue keys. Optional.
- `defaultJobOptions: JobOpts` \- Options to control the default settings for new jobs. See [JobOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd) for more information. Optional.
- `settings: AdvancedSettings` \- Advanced Queue configuration settings. These should usually not be changed. See [AdvancedSettings](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue) for more information. Optional.
- `extraOptions` \- Extra options for module init. See [Manual Registration](https://docs.nestjs.com/techniques/queues#manual-registration)

All the options are optional, providing detailed control over queue behavior. These are passed directly to the BullMQ `Queue` constructor. Read more about these options and other options [here](https://api.docs.bullmq.io/interfaces/v4.QueueOptions.html).

To register a queue, import the `BullModule.registerQueue()` dynamic module, as follows:

content\_copy

```typescript

BullModule.registerQueue({
  name: 'audio',
});

```

> **Hint** Create multiple queues by passing multiple comma-separated configuration objects to the `registerQueue()` method.

The `registerQueue()` method is used to instantiate and/or register queues. Queues are shared across modules and processes that connect to the same underlying Redis database with the same credentials. Each queue is unique by its name property. A queue name is used as both an injection token (for injecting the queue into controllers/providers), and as an argument to decorators to associate consumer classes and listeners with queues.

You can also override some of the pre-configured options for a specific queue, as follows:

content\_copy

```typescript

BullModule.registerQueue({
  name: 'audio',
  connection: {
    port: 6380,
  },
});

```

BullMQ also supports parent - child relationships between jobs. This functionality enables the creation of flows where jobs are the node of trees of arbitrary depth. To read more about them check [here](https://docs.bullmq.io/guide/flows).

To add a flow, you can do the following:

content\_copy

```typescript

BullModule.registerFlowProducer({
  name: 'flowProducerName',
});

```

Since jobs are persisted in Redis, each time a specific named queue is instantiated (e.g., when an app is started/restarted), it attempts to process any old jobs that may exist from a previous unfinished session.

Each queue can have one or many producers, consumers, and listeners. Consumers retrieve jobs from the queue in a specific order: FIFO (the default), LIFO, or according to priorities. Controlling queue processing order is discussed [here](https://docs.nestjs.com/techniques/queues#consumers).

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Named configurations [\#](https://docs.nestjs.com/techniques/queues\#named-configurations)

If your queues connect to multiple different Redis instances, you can use a technique called **named configurations**. This feature allows you to register several configurations under specified keys, which then you can refer to in the queue options.

For example, assuming that you have an additional Redis instance (apart from the default one) used by a few queues registered in your application, you can register its configuration as follows:

content\_copy

```typescript

BullModule.forRoot('alternative-config', {
  connection: {
    port: 6381,
  },
});

```

In the example above, `'alternative-config'` is just a configuration key (it can be any arbitrary string).

With this in place, you can now point to this configuration in the `registerQueue()` options object:

content\_copy

```typescript

BullModule.registerQueue({
  configKey: 'alternative-config',
  name: 'video',
});

```

#### Producers [\#](https://docs.nestjs.com/techniques/queues\#producers)

Job producers add jobs to queues. Producers are typically application services (Nest [providers](https://docs.nestjs.com/providers)). To add jobs to a queue, first inject the queue into the service as follows:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { Queue } from 'bullmq';
import { InjectQueue } from '@nestjs/bullmq';

@Injectable()
export class AudioService {
  constructor(@InjectQueue('audio') private audioQueue: Queue) {}
}

```

> **Hint** The `@InjectQueue()` decorator identifies the queue by its name, as provided in the `registerQueue()` method call (e.g., `'audio'`).

Now, add a job by calling the queue's `add()` method, passing a user-defined job object. Jobs are represented as serializable JavaScript objects (since that is how they are stored in the Redis database). The shape of the job you pass is arbitrary; use it to represent the semantics of your job object. You also need to give it a name. This allows you to create specialized [consumers](https://docs.nestjs.com/techniques/queues#consumers) that will only process jobs with a given name.

content\_copy

```typescript

const job = await this.audioQueue.add('transcode', {
  foo: 'bar',
});

```

#### Job options [\#](https://docs.nestjs.com/techniques/queues\#job-options)

Jobs can have additional options associated with them. Pass an options object after the `job` argument in the `Queue.add()` method. Some of the job options properties are:

- `priority`: `number` \- Optional priority value. Ranges from 1 (highest priority) to MAX\_INT (lowest priority). Note that using priorities has a slight impact on performance, so use them with caution.
- `delay`: `number` \- An amount of time (milliseconds) to wait until this job can be processed. Note that for accurate delays, both server and clients should have their clocks synchronized.
- `attempts`: `number` \- The total number of attempts to try the job until it completes.
- `repeat`: `RepeatOpts` \- Repeat job according to a cron specification. See [RepeatOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd).
- `backoff`: `number | BackoffOpts` \- Backoff setting for automatic retries if the job fails. See [BackoffOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd).
- `lifo`: `boolean` \- If true, adds the job to the right end of the queue instead of the left (default false).
- `jobId`: `number` \| `string` \- Override the job ID - by default, the job ID is a unique
integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added.
- `removeOnComplete`: `boolean | number` \- If true, removes the job when it successfully completes. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the completed set.
- `removeOnFail`: `boolean | number` \- If true, removes the job when it fails after all attempts. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the failed set.
- `stackTraceLimit`: `number` \- Limits the amount of stack trace lines that will be recorded in the stacktrace.

Here are a few examples of customizing jobs with job options.

To delay the start of a job, use the `delay` configuration property.

content\_copy

```typescript

const job = await this.audioQueue.add(
  'transcode',
  {
    foo: 'bar',
  },
  { delay: 3000 }, // 3 seconds delayed
);

```

To add a job to the right end of the queue (process the job as **LIFO** (Last In First Out)), set the `lifo` property of the configuration object to `true`.

content\_copy

```typescript

const job = await this.audioQueue.add(
  'transcode',
  {
    foo: 'bar',
  },
  { lifo: true },
);

```

To prioritize a job, use the `priority` property.

content\_copy

```typescript

const job = await this.audioQueue.add(
  'transcode',
  {
    foo: 'bar',
  },
  { priority: 2 },
);

```

For a full list of options, check the API documentation [here](https://api.docs.bullmq.io/types/v4.JobsOptions.html) and [here](https://api.docs.bullmq.io/interfaces/v4.BaseJobOptions.html).

#### Consumers [\#](https://docs.nestjs.com/techniques/queues\#consumers)

A consumer is a **class** defining methods that either process jobs added into the queue, or listen for events on the queue, or both. Declare a consumer class using the `@Processor()` decorator as follows:

content\_copy

```typescript

import { Processor } from '@nestjs/bullmq';

@Processor('audio')
export class AudioConsumer {}

```

> **Hint** Consumers must be registered as `providers` so the `@nestjs/bullmq` package can pick them up.

Where the decorator's string argument (e.g., `'audio'`) is the name of the queue to be associated with the class methods.

content\_copy

```typescript

import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';

@Processor('audio')
export class AudioConsumer extends WorkerHost {
  async process(job: Job<any, any, string>): Promise<any> {
    let progress = 0;
    for (let i = 0; i < 100; i++) {
      await doSomething(job.data);
      progress += 1;
      await job.updateProgress(progress);
    }
    return {};
  }
}

```

The process method is called whenever the worker is idle and there are jobs to process in the queue. This handler method receives the `job` object as its only argument. The value returned by the handler method is stored in the job object and can be accessed later on, for example in a listener for the completed event.

`Job` objects have multiple methods that allow you to interact with their state. For example, the above code uses the `updateProgress()` method to update the job's progress. See [here](https://api.docs.bullmq.io/classes/v4.Job.html) for the complete `Job` object API reference.

In the older version, Bull, you could designate that a job handler method will handle **only** jobs of a certain type (jobs with a specific `name`) by passing that `name` to the `@Process()` decorator as shown below.

> **Warning** This doesn't work with BullMQ, keep reading.

content\_copy

```typescript

@Process('transcode')
async transcode(job: Job<unknown>) { ... }

```

This behavior is not supported in BullMQ due to confusions it generated. Instead, you need switch cases to call different services or logic for each job name:

content\_copy

```typescript

import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';

@Processor('audio')
export class AudioConsumer extends WorkerHost {
  async process(job: Job<any, any, string>): Promise<any> {
    switch (job.name) {
      case 'transcode': {
        let progress = 0;
        for (i = 0; i < 100; i++) {
          await doSomething(job.data);
          progress += 1;
          await job.progress(progress);
        }
        return {};
      }
      case 'concatenate': {
        await doSomeLogic2();
        break;
      }
    }
  }
}

```

This is covered in the [named processor](https://docs.bullmq.io/patterns/named-processor) section of the BullMQ documentation.

#### Request-scoped consumers [\#](https://docs.nestjs.com/techniques/queues\#request-scoped-consumers)

When a consumer is flagged as request-scoped (learn more about the injection scopes [here](https://docs.nestjs.com/fundamentals/injection-scopes#provider-scope)), a new instance of the class will be created exclusively for each job. The instance will be garbage-collected after the job has completed.

content\_copy

```typescript

@Processor({
  name: 'audio',
  scope: Scope.REQUEST,
})

```

Since request-scoped consumer classes are instantiated dynamically and scoped to a single job, you can inject a `JOB_REF` through the constructor using a standard approach.

content\_copy

```typescript

constructor(@Inject(JOB_REF) jobRef: Job) {
  console.log(jobRef);
}

```

> **Hint** The `JOB_REF` token is imported from the `@nestjs/bullmq` package.

#### Event listeners [\#](https://docs.nestjs.com/techniques/queues\#event-listeners)

BullMQ generates a set of useful events when queue and/or job state changes occur. These events can be subscribed to at the Worker level using the `@OnWorkerEvent(event)` decorator, or at the Queue level with a dedicated listener class and the `@OnQueueEvent(event)` decorator.

Worker events must be declared within a [consumer](https://docs.nestjs.com/techniques/queues#consumers) class (i.e., within a class decorated with the `@Processor()` decorator). To listen for an event, use the `@OnWorkerEvent(event)` decorator with the event you want to be handled. For example, to listen to the event emitted when a job enters the active state in the `audio` queue, use the following construct:

content\_copy

```typescript

import { Processor, Process, OnWorkerEvent } from '@nestjs/bullmq';
import { Job } from 'bullmq';

@Processor('audio')
export class AudioConsumer {
  @OnWorkerEvent('active')
  onActive(job: Job) {
    console.log(
      `Processing job ${job.id} of type ${job.name} with data ${job.data}...`,
    );
  }

  // ...
}

```

You can see the complete list of events and their arguments as properties of WorkerListener [here](https://api.docs.bullmq.io/interfaces/v4.WorkerListener.html).

QueueEvent listeners must use the `@QueueEventsListener(queue)` decorator and extend the `QueueEventsHost` class provided by `@nestjs/bullmq`. To listen for an event, use the `@OnQueueEvent(event)` decorator with the event you want to be handled. For example, to listen to the event emitted when a job enters the active state in the `audio` queue, use the following construct:

content\_copy

```typescript

import {
  QueueEventsHost,
  QueueEventsListener,
  OnQueueEvent,
} from '@nestjs/bullmq';

@QueueEventsListener('audio')
export class AudioEventsListener extends QueueEventsHost {
  @OnQueueEvent('active')
  onActive(job: { jobId: string; prev?: string }) {
    console.log(`Processing job ${job.jobId}...`);
  }

  // ...
}

```

> **Hint** QueueEvent Listeners must be registered as `providers` so the `@nestjs/bullmq` package can pick them up.

You can see the complete list of events and their arguments as properties of QueueEventsListener [here](https://api.docs.bullmq.io/interfaces/v4.QueueEventsListener.html).

#### Queue management [\#](https://docs.nestjs.com/techniques/queues\#queue-management)

Queues have an API that allows you to perform management functions like pausing and resuming, retrieving the count of jobs in various states, and several more. You can find the full queue API [here](https://api.docs.bullmq.io/classes/v4.Queue.html). Invoke any of these methods directly on the `Queue` object, as shown below with the pause/resume examples.

Pause a queue with the `pause()` method call. A paused queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized.

content\_copy

```typescript

await audioQueue.pause();

```

To resume a paused queue, use the `resume()` method, as follows:

content\_copy

```typescript

await audioQueue.resume();

```

#### Separate processes [\#](https://docs.nestjs.com/techniques/queues\#separate-processes)

Job handlers can also be run in a separate (forked) process ( [source](https://docs.bullmq.io/guide/workers/sandboxed-processors)). This has several advantages:

- The process is sandboxed so if it crashes it does not affect the worker.
- You can run blocking code without affecting the queue (jobs will not stall).
- Much better utilization of multi-core CPUs.
- Less connections to redis.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { join } from 'path';

@Module({
  imports: [\
    BullModule.registerQueue({\
      name: 'audio',\
      processors: [join(__dirname, 'processor.js')],\
    }),\
  ],
})
export class AppModule {}

```

> **Warning** Please note that because your function is being executed in a forked process, Dependency Injection (and IoC container) won't be available. That means that your processor function will need to contain (or create) all instances of external dependencies it needs.

#### Async configuration [\#](https://docs.nestjs.com/techniques/queues\#async-configuration)

You may want to pass `bullmq` options asynchronously instead of statically. In this case, use the `forRootAsync()` method which provides several ways to deal with async configuration. Likewise, if you want to pass queue options asynchronously, use the `registerQueueAsync()` method.

One approach is to use a factory function:

content\_copy

```typescript

BullModule.forRootAsync({
  useFactory: () => ({
    connection: {
      host: 'localhost',
      port: 6379,
    },
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

BullModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) => ({
    connection: {
      host: configService.get('QUEUE_HOST'),
      port: configService.get('QUEUE_PORT'),
    },
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

BullModule.forRootAsync({
  useClass: BullConfigService,
});

```

The construction above will instantiate `BullConfigService` inside `BullModule` and use it to provide an options object by calling `createSharedConfiguration()`. Note that this means that the `BullConfigService` has to implement the `SharedBullConfigurationFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
class BullConfigService implements SharedBullConfigurationFactory {
  createSharedConfiguration(): BullModuleOptions {
    return {
      connection: {
        host: 'localhost',
        port: 6379,
      },
    };
  }
}

```

In order to prevent the creation of `BullConfigService` inside `BullModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

BullModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `BullModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

Likewise, if you want to pass queue options asynchronously, use the `registerQueueAsync()` method, just keep in mind to specify the `name` attribute outside the factory function.

content\_copy

```typescript

BullModule.registerQueueAsync({
  name: 'audio',
  useFactory: () => ({
    redis: {
      host: 'localhost',
      port: 6379,
    },
  }),
});

```

#### Manual registration [\#](https://docs.nestjs.com/techniques/queues\#manual-registration)

By default, `BullModule` automatically registers BullMQ components (queues, processors, and event listener services) in the `onModuleInit` lifecycle function. However, in some cases, this behavior may not be ideal. To prevent automatic registration, enable `manualRegistration` in `BullModule` like this:

content\_copy

```typescript

BullModule.forRoot({
  extraOptions: {
    manualRegistration: true,
  },
});

```

To register these components manually, inject `BullRegistrar` and call the `register` function, ideally within `OnModuleInit` or `OnApplicationBootstrap`.

content\_copy

```typescript

import { Injectable, OnModuleInit } from '@nestjs/common';
import { BullRegistrar } from '@nestjs/bullmq';

@Injectable()
export class AudioService implements OnModuleInit {
  constructor(private bullRegistrar: BullRegistrar) {}

  onModuleInit() {
    if (yourConditionHere) {
      this.bullRegistrar.register();
    }
  }
}

```

Unless you call the `BullRegistrar#register` function, no BullMQ components will work—meaning no jobs will be processed.

#### Bull installation [\#](https://docs.nestjs.com/techniques/queues\#bull-installation)

> **Note** If you decided to use BullMQ, skip this section and the following chapters.

To begin using Bull, we first install the required dependencies.

```bash

$ npm install --save @nestjs/bull bull

```

Once the installation process is complete, we can import the `BullModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';

@Module({
  imports: [\
    BullModule.forRoot({\
      redis: {\
        host: 'localhost',\
        port: 6379,\
      },\
    }),\
  ],
})
export class AppModule {}

```

The `forRoot()` method is used to register a `bull` package configuration object that will be used by all queues registered in the application (unless specified otherwise). A configuration object consists of the following properties:

- `limiter: RateLimiter` \- Options to control the rate at which the queue's jobs are processed. See [RateLimiter](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue) for more information. Optional.
- `redis: RedisOpts` \- Options to configure the Redis connection. See [RedisOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue) for more information. Optional.
- `prefix: string` \- Prefix for all queue keys. Optional.
- `defaultJobOptions: JobOpts` \- Options to control the default settings for new jobs. See [JobOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd) for more information. Optional. **Note: These do not take effect if you schedule jobs via a FlowProducer. See [bullmq#1034](https://github.com/taskforcesh/bullmq/issues/1034) for explanation.**
- `settings: AdvancedSettings` \- Advanced Queue configuration settings. These should usually not be changed. See [AdvancedSettings](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue) for more information. Optional.

All the options are optional, providing detailed control over queue behavior. These are passed directly to the Bull `Queue` constructor. Read more about these options [here](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue).

To register a queue, import the `BullModule.registerQueue()` dynamic module, as follows:

content\_copy

```typescript

BullModule.registerQueue({
  name: 'audio',
});

```

> **Hint** Create multiple queues by passing multiple comma-separated configuration objects to the `registerQueue()` method.

The `registerQueue()` method is used to instantiate and/or register queues. Queues are shared across modules and processes that connect to the same underlying Redis database with the same credentials. Each queue is unique by its name property. A queue name is used as both an injection token (for injecting the queue into controllers/providers), and as an argument to decorators to associate consumer classes and listeners with queues.

You can also override some of the pre-configured options for a specific queue, as follows:

content\_copy

```typescript

BullModule.registerQueue({
  name: 'audio',
  redis: {
    port: 6380,
  },
});

```

Since jobs are persisted in Redis, each time a specific named queue is instantiated (e.g., when an app is started/restarted), it attempts to process any old jobs that may exist from a previous unfinished session.

Each queue can have one or many producers, consumers, and listeners. Consumers retrieve jobs from the queue in a specific order: FIFO (the default), LIFO, or according to priorities. Controlling queue processing order is discussed [here](https://docs.nestjs.com/techniques/queues#consumers).

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Named configurations [\#](https://docs.nestjs.com/techniques/queues\#named-configurations-1)

If your queues connect to multiple Redis instances, you can use a technique called **named configurations**. This feature allows you to register several configurations under specified keys, which then you can refer to in the queue options.

For example, assuming that you have an additional Redis instance (apart from the default one) used by a few queues registered in your application, you can register its configuration as follows:

content\_copy

```typescript

BullModule.forRoot('alternative-config', {
  redis: {
    port: 6381,
  },
});

```

In the example above, `'alternative-config'` is just a configuration key (it can be any arbitrary string).

With this in place, you can now point to this configuration in the `registerQueue()` options object:

content\_copy

```typescript

BullModule.registerQueue({
  configKey: 'alternative-config',
  name: 'video',
});

```

#### Producers [\#](https://docs.nestjs.com/techniques/queues\#producers-1)

Job producers add jobs to queues. Producers are typically application services (Nest [providers](https://docs.nestjs.com/providers)). To add jobs to a queue, first inject the queue into the service as follows:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { Queue } from 'bull';
import { InjectQueue } from '@nestjs/bull';

@Injectable()
export class AudioService {
  constructor(@InjectQueue('audio') private audioQueue: Queue) {}
}

```

> **Hint** The `@InjectQueue()` decorator identifies the queue by its name, as provided in the `registerQueue()` method call (e.g., `'audio'`).

Now, add a job by calling the queue's `add()` method, passing a user-defined job object. Jobs are represented as serializable JavaScript objects (since that is how they are stored in the Redis database). The shape of the job you pass is arbitrary; use it to represent the semantics of your job object.

content\_copy

```typescript

const job = await this.audioQueue.add({
  foo: 'bar',
});

```

#### Named jobs [\#](https://docs.nestjs.com/techniques/queues\#named-jobs)

Jobs may have unique names. This allows you to create specialized [consumers](https://docs.nestjs.com/techniques/queues#consumers) that will only process jobs with a given name.

content\_copy

```typescript

const job = await this.audioQueue.add('transcode', {
  foo: 'bar',
});

```

> **Warning** When using named jobs, you must create processors for each unique name added to a queue, or the queue will complain that you are missing a processor for the given job. See [here](https://docs.nestjs.com/techniques/queues#consumers) for more information on consuming named jobs.

#### Job options [\#](https://docs.nestjs.com/techniques/queues\#job-options-1)

Jobs can have additional options associated with them. Pass an options object after the `job` argument in the `Queue.add()` method. Job options properties are:

- `priority`: `number` \- Optional priority value. Ranges from 1 (highest priority) to MAX\_INT (lowest priority). Note that using priorities has a slight impact on performance, so use them with caution.
- `delay`: `number` \- An amount of time (milliseconds) to wait until this job can be processed. Note that for accurate delays, both server and clients should have their clocks synchronized.
- `attempts`: `number` \- The total number of attempts to try the job until it completes.
- `repeat`: `RepeatOpts` \- Repeat job according to a cron specification. See [RepeatOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd).
- `backoff`: `number | BackoffOpts` \- Backoff setting for automatic retries if the job fails. See [BackoffOpts](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queueadd).
- `lifo`: `boolean` \- If true, adds the job to the right end of the queue instead of the left (default false).
- `timeout`: `number` \- The number of milliseconds after which the job should fail with a timeout error.
- `jobId`: `number` \| `string` \- Override the job ID - by default, the job ID is a unique
integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added.
- `removeOnComplete`: `boolean | number` \- If true, removes the job when it successfully completes. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the completed set.
- `removeOnFail`: `boolean | number` \- If true, removes the job when it fails after all attempts. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the failed set.
- `stackTraceLimit`: `number` \- Limits the amount of stack trace lines that will be recorded in the stacktrace.

Here are a few examples of customizing jobs with job options.

To delay the start of a job, use the `delay` configuration property.

content\_copy

```typescript

const job = await this.audioQueue.add(
  {
    foo: 'bar',
  },
  { delay: 3000 }, // 3 seconds delayed
);

```

To add a job to the right end of the queue (process the job as **LIFO** (Last In First Out)), set the `lifo` property of the configuration object to `true`.

content\_copy

```typescript

const job = await this.audioQueue.add(
  {
    foo: 'bar',
  },
  { lifo: true },
);

```

To prioritize a job, use the `priority` property.

content\_copy

```typescript

const job = await this.audioQueue.add(
  {
    foo: 'bar',
  },
  { priority: 2 },
);

```

#### Consumers [\#](https://docs.nestjs.com/techniques/queues\#consumers-1)

A consumer is a **class** defining methods that either process jobs added into the queue, or listen for events on the queue, or both. Declare a consumer class using the `@Processor()` decorator as follows:

content\_copy

```typescript

import { Processor } from '@nestjs/bull';

@Processor('audio')
export class AudioConsumer {}

```

> **Hint** Consumers must be registered as `providers` so the `@nestjs/bull` package can pick them up.

Where the decorator's string argument (e.g., `'audio'`) is the name of the queue to be associated with the class methods.

Within a consumer class, declare job handlers by decorating handler methods with the `@Process()` decorator.

content\_copy

```typescript

import { Processor, Process } from '@nestjs/bull';
import { Job } from 'bull';

@Processor('audio')
export class AudioConsumer {
  @Process()
  async transcode(job: Job<unknown>) {
    let progress = 0;
    for (let i = 0; i < 100; i++) {
      await doSomething(job.data);
      progress += 1;
      await job.progress(progress);
    }
    return {};
  }
}

```

The decorated method (e.g., `transcode()`) is called whenever the worker is idle and there are jobs to process in the queue. This handler method receives the `job` object as its only argument. The value returned by the handler method is stored in the job object and can be accessed later on, for example in a listener for the completed event.

`Job` objects have multiple methods that allow you to interact with their state. For example, the above code uses the `progress()` method to update the job's progress. See [here](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#job) for the complete `Job` object API reference.

You can designate that a job handler method will handle **only** jobs of a certain type (jobs with a specific `name`) by passing that `name` to the `@Process()` decorator as shown below. You can have multiple `@Process()` handlers in a given consumer class, corresponding to each job type ( `name`). When you use named jobs, be sure to have a handler corresponding to each name.

content\_copy

```typescript

@Process('transcode')
async transcode(job: Job<unknown>) { ... }

```

> **Warning** When defining multiple consumers for the same queue, the `concurrency` option in `@Process({ concurrency: 1 })` won't take effect. The minimum `concurrency` will match the number of consumers defined. This also applies even if `@Process()` handlers use a different `name` to handle named jobs.

#### Request-scoped consumers [\#](https://docs.nestjs.com/techniques/queues\#request-scoped-consumers-1)

When a consumer is flagged as request-scoped (learn more about the injection scopes [here](https://docs.nestjs.com/fundamentals/injection-scopes#provider-scope)), a new instance of the class will be created exclusively for each job. The instance will be garbage-collected after the job has completed.

content\_copy

```typescript

@Processor({
  name: 'audio',
  scope: Scope.REQUEST,
})

```

Since request-scoped consumer classes are instantiated dynamically and scoped to a single job, you can inject a `JOB_REF` through the constructor using a standard approach.

content\_copy

```typescript

constructor(@Inject(JOB_REF) jobRef: Job) {
  console.log(jobRef);
}

```

> **Hint** The `JOB_REF` token is imported from the `@nestjs/bull` package.

#### Event listeners [\#](https://docs.nestjs.com/techniques/queues\#event-listeners-1)

Bull generates a set of useful events when queue and/or job state changes occur. Nest provides a set of decorators that allow subscribing to a core set of standard events. These are exported from the `@nestjs/bull` package.

Event listeners must be declared within a [consumer](https://docs.nestjs.com/techniques/queues#consumers) class (i.e., within a class decorated with the `@Processor()` decorator). To listen for an event, use one of the decorators in the table below to declare a handler for the event. For example, to listen to the event emitted when a job enters the active state in the `audio` queue, use the following construct:

content\_copy

```typescript

import { Processor, Process, OnQueueActive } from '@nestjs/bull';
import { Job } from 'bull';

@Processor('audio')
export class AudioConsumer {

  @OnQueueActive()
  onActive(job: Job) {
    console.log(
      `Processing job ${job.id} of type ${job.name} with data ${job.data}...`,
    );
  }
  ...

```

Since Bull operates in a distributed (multi-node) environment, it defines the concept of event locality. This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes. A **local** event is one that is produced when an action or state change is triggered on a queue in the local process. In other words, when your event producers and consumers are local to a single process, all events happening on queues are local.

When a queue is shared across multiple processes, we encounter the possibility of **global** events. For a listener in one process to receive an event notification triggered by another process, it must register for a global event.

Event handlers are invoked whenever their corresponding event is emitted. The handler is called with the signature shown in the table below, providing access to information relevant to the event. We discuss one key difference between local and global event handler signatures below.

| Local event listeners | Global event listeners | Handler method signature / When fired |
| --- | --- | --- |
| `@OnQueueError()` | `@OnGlobalQueueError()` | `handler(error: Error)` \- An error occurred. `error` contains the triggering error. |
| `@OnQueueWaiting()` | `@OnGlobalQueueWaiting()` | `handler(jobId: number | string)` \- A Job is waiting to be processed as soon as a worker is idling. `jobId` contains the id for the job that has entered this state. |
| `@OnQueueActive()` | `@OnGlobalQueueActive()` | `handler(job: Job)` \- Job `job` has started. |
| `@OnQueueStalled()` | `@OnGlobalQueueStalled()` | `handler(job: Job)` \- Job `job` has been marked as stalled. This is useful for debugging job workers that crash or pause the event loop. |
| `@OnQueueProgress()` | `@OnGlobalQueueProgress()` | `handler(job: Job, progress: number)` \- Job `job`'s progress was updated to value `progress`. |
| `@OnQueueCompleted()` | `@OnGlobalQueueCompleted()` | `handler(job: Job, result: any)` Job `job` successfully completed with a result `result`. |
| `@OnQueueFailed()` | `@OnGlobalQueueFailed()` | `handler(job: Job, err: Error)` Job `job` failed with reason `err`. |
| `@OnQueuePaused()` | `@OnGlobalQueuePaused()` | `handler()` The queue has been paused. |
| `@OnQueueResumed()` | `@OnGlobalQueueResumed()` | `handler(job: Job)` The queue has been resumed. |
| `@OnQueueCleaned()` | `@OnGlobalQueueCleaned()` | `handler(jobs: Job[], type: string)` Old jobs have been cleaned from the queue. `jobs` is an array of cleaned jobs, and `type` is the type of jobs cleaned. |
| `@OnQueueDrained()` | `@OnGlobalQueueDrained()` | `handler()` Emitted whenever the queue has processed all the waiting jobs (even if there can be some delayed jobs not yet processed). |
| `@OnQueueRemoved()` | `@OnGlobalQueueRemoved()` | `handler(job: Job)` Job `job` was successfully removed. |

When listening for global events, the method signatures can be slightly different from their local counterpart. Specifically, any method signature that receives `job` objects in the local version, instead receives a `jobId` ( `number`) in the global version. To get a reference to the actual `job` object in such a case, use the `Queue#getJob` method. This call should be awaited, and therefore the handler should be declared `async`. For example:

content\_copy

```typescript

@OnGlobalQueueCompleted()
async onGlobalCompleted(jobId: number, result: any) {
  const job = await this.immediateQueue.getJob(jobId);
  console.log('(Global) on completed: job ', job.id, ' -> result: ', result);
}

```

> **Hint** To access the `Queue` object (to make a `getJob()` call), you must of course inject it. Also, the Queue must be registered in the module where you are injecting it.

In addition to the specific event listener decorators, you can also use the generic `@OnQueueEvent()` decorator in combination with either `BullQueueEvents` or `BullQueueGlobalEvents` enums. Read more about events [here](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#events).

#### Queue management [\#](https://docs.nestjs.com/techniques/queues\#queue-management-1)

Queue's have an API that allows you to perform management functions like pausing and resuming, retrieving the count of jobs in various states, and several more. You can find the full queue API [here](https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue). Invoke any of these methods directly on the `Queue` object, as shown below with the pause/resume examples.

Pause a queue with the `pause()` method call. A paused queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized.

content\_copy

```typescript

await audioQueue.pause();

```

To resume a paused queue, use the `resume()` method, as follows:

content\_copy

```typescript

await audioQueue.resume();

```

#### Separate processes [\#](https://docs.nestjs.com/techniques/queues\#separate-processes-1)

Job handlers can also be run in a separate (forked) process ( [source](https://github.com/OptimalBits/bull#separate-processes)). This has several advantages:

- The process is sandboxed so if it crashes it does not affect the worker.
- You can run blocking code without affecting the queue (jobs will not stall).
- Much better utilization of multi-core CPUs.
- Less connections to redis.

content\_copy app.module.ts

JS  TS

```ts

import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { join } from 'path';

@Module({
  imports: [\
    BullModule.registerQueue({\
      name: 'audio',\
      processors: [join(__dirname, 'processor.js')],\
    }),\
  ],
})
export class AppModule {}

```

Please note that because your function is being executed in a forked process, Dependency Injection (and IoC container) won't be available. That means that your processor function will need to contain (or create) all instances of external dependencies it needs.

content\_copy processor.ts

JS  TS

```ts

import { Job, DoneCallback } from 'bull';

export default function (job: Job, cb: DoneCallback) {
  console.log(`[${process.pid}] ${JSON.stringify(job.data)}`);
  cb(null, 'It works');
}

```

#### Async configuration [\#](https://docs.nestjs.com/techniques/queues\#async-configuration-1)

You may want to pass `bull` options asynchronously instead of statically. In this case, use the `forRootAsync()` method which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

BullModule.forRootAsync({
  useFactory: () => ({
    redis: {
      host: 'localhost',
      port: 6379,
    },
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

BullModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) => ({
    redis: {
      host: configService.get('QUEUE_HOST'),
      port: configService.get('QUEUE_PORT'),
    },
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

BullModule.forRootAsync({
  useClass: BullConfigService,
});

```

The construction above will instantiate `BullConfigService` inside `BullModule` and use it to provide an options object by calling `createSharedConfiguration()`. Note that this means that the `BullConfigService` has to implement the `SharedBullConfigurationFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
class BullConfigService implements SharedBullConfigurationFactory {
  createSharedConfiguration(): BullModuleOptions {
    return {
      redis: {
        host: 'localhost',
        port: 6379,
      },
    };
  }
}

```

In order to prevent the creation of `BullConfigService` inside `BullModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

BullModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `BullModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

Likewise, if you want to pass queue options asynchronously, use the `registerQueueAsync()` method, just keep in mind to specify the `name` attribute outside the factory function.

content\_copy

```typescript

BullModule.registerQueueAsync({
  name: 'audio',
  useFactory: () => ({
    redis: {
      host: 'localhost',
      port: 6379,
    },
  }),
});

```

#### Example [\#](https://docs.nestjs.com/techniques/queues\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/26-queues).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Migration Guide
- [Migration guide](https://docs.nestjs.com/migration-guide#migration-guide)
- [Upgrading packages](https://docs.nestjs.com/migration-guide#upgrading-packages)
- [Express v5](https://docs.nestjs.com/migration-guide#express-v5)
- [Query parameters parsing](https://docs.nestjs.com/migration-guide#query-parameters-parsing)
- [Fastify v5](https://docs.nestjs.com/migration-guide#fastify-v5)
- [Fastify CORS](https://docs.nestjs.com/migration-guide#fastify-cors)
- [Fastify middleware registration](https://docs.nestjs.com/migration-guide#fastify-middleware-registration)
- [Module resolution algorithm](https://docs.nestjs.com/migration-guide#module-resolution-algorithm)
- [Reflector type inference](https://docs.nestjs.com/migration-guide#reflector-type-inference)
- [Lifecycle hooks execution order](https://docs.nestjs.com/migration-guide#lifecycle-hooks-execution-order)
- [Middleware registration order](https://docs.nestjs.com/migration-guide#middleware-registration-order)
- [Cache module](https://docs.nestjs.com/migration-guide#cache-module)
- [Config module](https://docs.nestjs.com/migration-guide#config-module)
- [Terminus module](https://docs.nestjs.com/migration-guide#terminus-module)
- [Node.js v16 and v18 no longer supported](https://docs.nestjs.com/migration-guide#nodejs-v16-and-v18-no-longer-supported)
- [Mau official deployment platform](https://docs.nestjs.com/migration-guide#mau-official-deployment-platform)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/migration.md "Suggest Edits")

### Migration guide

This article offers a comprehensive guide for migrating from NestJS version 10 to version 11. To explore the new features introduced in v11, take a look at [this article](https://trilon.io/blog/announcing-nestjs-11-whats-new). While the update includes a few minor breaking changes, they are unlikely to impact most users. You can review the complete list of changes [here](https://github.com/nestjs/nest/releases/tag/v11.0.0).

#### Upgrading packages [\#](https://docs.nestjs.com/migration-guide\#upgrading-packages)

Although you can manually upgrade your packages, we recommend using [npm-check-updates (ncu)](https://npmjs.com/package/npm-check-updates) for a more streamlined process.

#### Express v5 [\#](https://docs.nestjs.com/migration-guide\#express-v5)

After years of development, Express v5 was officially released in 2024 and became a stable version in 2025. With NestJS 11, Express v5 is now the default version integrated into the framework. While this update is seamless for most users, it’s important to be aware that Express v5 introduces some breaking changes. For detailed guidance, refer to the [Express v5 migration guide](https://expressjs.com/en/guide/migrating-5.html).

One of the most notable updates in Express v5 is the revised path route matching algorithm. The following changes have been introduced to how path strings are matched with incoming requests:

- The wildcard `*` must have a name, matching the behavior of parameters: use `/*splat` or `/{*splat}` instead of `/*`. `splat` is simply the name of the wildcard parameter and has no special meaning. You can name it anything you like, for example, `*wildcard`
- The optional character `?` is no longer supported, use braces instead: `/:file{.:ext}`.
- Regexp characters are not supported.
- Some characters have been reserved to avoid confusion during upgrade `(()[]?+!)`, use `\` to escape them.
- Parameter names now support valid JavaScript identifiers, or quoted like `:"this"`.

That said, routes that previously worked in Express v4 may not work in Express v5. For example:

content\_copy

```typescript

@Get('users/*')
findAll() {
  // In NestJS 11, this will be automatically converted to a valid Express v5 route.
  // While it may still work, it's no longer advisable to use this wildcard syntax in Express v5.
  return 'This route should not work in Express v5';
}

```

To fix this issue, you can update the route to use a named wildcard:

content\_copy

```typescript

@Get('users/*splat')
findAll() {
  return 'This route will work in Express v5';
}

```

> **Warning** Note that `*splat` is a named wildcard that matches any path without the root path. If you need to match the root path as well ( `/users`), you can use `/users/{*splat}`, wrapping the wildcard in braces (optional group). Note that `splat` is simply the name of the wildcard parameter and has no special meaning. You can name it anything you like, for example, `*wildcard`.

Similarly, if you have a middleware that runs on all routes, you may need to update the path to use a named wildcard:

content\_copy

```typescript

// In NestJS 11, this will be automatically converted to a valid Express v5 route.
// While it may still work, it's no longer advisable to use this wildcard syntax in Express v5.
forRoutes('*'); // <-- This should not work in Express v5

```

Instead, you can update the path to use a named wildcard:

content\_copy

```typescript

forRoutes('{*splat}'); // <-- This will work in Express v5

```

Note that `{*splat}` is a named wildcard that matches any path including the root path. Outer braces make path optional.

#### Query parameters parsing [\#](https://docs.nestjs.com/migration-guide\#query-parameters-parsing)

> **Note** This change only applies to Express v5.

In Express v5, query parameters are no longer parsed using the `qs` library by default. Instead, the `simple` parser is used, which does not support nested objects or arrays.

As a result, query strings like these:

```plaintext

?filter[where][name]=John&filter[where][age]=30
?item[]=1&item[]=2

```

will no longer be parsed as expected. To revert to the previous behavior, you can configure Express to use the `extended` parser (the default in Express v4) by setting the `query parser` option to `extended`:

content\_copy

```typescript

import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule); // <-- Make sure to use <NestExpressApplication>
  app.set('query parser', 'extended'); // <-- Add this line
  await app.listen(3000);
}
bootstrap();

```

#### Fastify v5 [\#](https://docs.nestjs.com/migration-guide\#fastify-v5)

`@nestjs/platform-fastify` v11 now finally supports Fastify v5. This update should be seamless for most users; however, Fastify v5 introduces a few breaking changes, though these are unlikely to affect the majority of NestJS users. For more detailed information, refer to the [Fastify v5 migration guide](https://fastify.dev/docs/v5.1.x/Guides/Migration-Guide-V5/).

> **Hint** There have been no changes to path matching in Fastify v5 (except for middleware, see the section below), so you can continue using the wildcard syntax as you did before. The behavior remains the same, and routes defined with wildcards (like `*`) will still work as expected.

#### Fastify CORS [\#](https://docs.nestjs.com/migration-guide\#fastify-cors)

By default, only [CORS-safelisted methods](https://fetch.spec.whatwg.org/#methods) are allowed. If you need to enable additional methods (such as `PUT`, `PATCH`, or `DELETE`), you must explicitly define them in the `methods` option.

content\_copy

```typescript

const methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']; // OR comma-delimited string 'GET,POST,PUT,PATH,DELETE'

const app = await NestFactory.create<NestFastifyApplication>(
  AppModule,
  new FastifyAdapter(),
  { cors: { methods } },
);

// OR alternatively, you can use the `enableCors` method
const app = await NestFactory.create<NestFastifyApplication>(
  AppModule,
  new FastifyAdapter(),
);
app.enableCors({ methods });

```

#### Fastify middleware registration [\#](https://docs.nestjs.com/migration-guide\#fastify-middleware-registration)

NestJS 11 now uses the latest version of the [path-to-regexp](https://www.npmjs.com/package/path-to-regexp) package to match **middleware paths** in `@nestjs/platform-fastify`. As a result, the `(.*)` syntax for matching all paths is no longer supported. Instead, you should use named wildcards.

For example, if you have a middleware that applies to all routes:

content\_copy

```typescript

// In NestJS 11, this will automatically be converted to a valid route, even if you don't update it.
.forRoutes('(.*)');

```

You'll need to update it to use a named wildcard instead:

content\_copy

```typescript

.forRoutes('*splat');

```

Where `splat` is just an arbitrary name for the wildcard parameter. You can name it anything you like.

#### Module resolution algorithm [\#](https://docs.nestjs.com/migration-guide\#module-resolution-algorithm)

Starting with NestJS 11, the module resolution algorithm has been improved to enhance performance and reduce memory usage for most applications. This change does not require any manual intervention, but there are some edge cases where the behavior may differ from previous versions.

In NestJS v10 and earlier, dynamic modules were assigned a unique opaque key generated from the module's dynamic metadata. This key was used to identify the module in the module registry. For example, if you included `TypeOrmModule.forFeature([User])` in multiple modules, NestJS would deduplicate the modules and treat them as a single module node in the registry. This process is known as node deduplication.

With the release of NestJS v11, we no longer generate predictable hashes for dynamic modules. Instead, object references are now used to determine if one module is equivalent to another. To share the same dynamic module across multiple modules, simply assign it to a variable and import it wherever needed. This new approach provides more flexibility and ensures that dynamic modules are handled more efficiently.

This new algorithm might impact your integration tests if you use a lot of dynamic modules, because without the manually deduplication mentioned above, your TestingModule could have multiple instances of a dependency. This makes it a bit trickier to stub a method, because you'll need to target the correct instance. Your options are to either:

- Deduplicate the dynamic module you'd like to stub
- Use `module.select(ParentModule).get(Target)` to find the correct instance
- Stub all instances using `module.get(Target, { each: true })`
- Or switch your test back to the old algorithm using `Test.createTestingModule({}, { moduleIdGeneratorAlgorithm: 'deep-hash' })`

#### Reflector type inference [\#](https://docs.nestjs.com/migration-guide\#reflector-type-inference)

NestJS 11 introduces several improvements to the `Reflector` class, enhancing its functionality and type inference for metadata values. These updates provide a more intuitive and robust experience when working with metadata.

1. `getAllAndMerge` now returns an object rather than an array containing a single element when there is only one metadata entry, and the `value` is of type `object`. This change improves consistency when dealing with object-based metadata.
2. The `getAllAndOverride` return type has been updated to `T | undefined` instead of `T`. This update better reflects the possibility of no metadata being found and ensures proper handling of undefined cases.
3. The `ReflectableDecorator`'s transformed type argument is now properly inferred across all methods.

These enhancements improve the overall developer experience by providing better type safety and handling of metadata in NestJS 11.

#### Lifecycle hooks execution order [\#](https://docs.nestjs.com/migration-guide\#lifecycle-hooks-execution-order)

Termination lifecycle hooks are now executed in the reverse order to their initialization counterparts. That said, hooks like `OnModuleDestroy`, `BeforeApplicationShutdown`, and `OnApplicationShutdown` are now executed in the reverse order.

Imagine the following scenario:

```plaintext

// Where A, B, and C are modules and "->" represents the module dependency.
A -> B -> C

```

In this case, the `OnModuleInit` hooks are executed in the following order:

```plaintext

C -> B -> A

```

While the `OnModuleDestroy` hooks are executed in the reverse order:

```plaintext

A -> B -> C

```

> **Hint** Global modules are treated as a dependency of all other modules. This means that global modules are initialized first and destroyed last.

#### Middleware registration order [\#](https://docs.nestjs.com/migration-guide\#middleware-registration-order)

In NestJS v11, the behavior of middleware registration has been updated. Previously, the order of middleware registration was determined by the topological sort of the module dependency graph, where the distance from the root module defined the order of middleware registration, regardless of whether the middleware was registered in a global module or a regular module. Global modules were treated like regular modules in this respect, which led to inconsistent behavior, especially when compared to other framework features.

From v11 onwards, middleware registered in global modules is now **executed first**, regardless of its position in the module dependency graph. This change ensures that global middleware always runs before any middleware from imported modules, maintaining a consistent and predictable order.

#### Cache module [\#](https://docs.nestjs.com/migration-guide\#cache-module)

The `CacheModule` (from the `@nestjs/cache-manager` package) has been updated to support the latest version of the `cache-manager` package. This update brings a few breaking changes, including a migration to [Keyv](https://keyv.org/), which offers a unified interface for key-value storage across multiple backend stores through storage adapters.

The key difference between the previous version and the new version lies in the configuration of external stores. In the previous version, to register a Redis store, you would have likely configured it like this:

content\_copy

```ts

// Old version - no longer supported
CacheModule.registerAsync({
  useFactory: async () => {
    const store = await redisStore({
      socket: {
        host: 'localhost',
        port: 6379,
      },
    });

    return {
      store,
    };
  },
}),

```

In the new version, you should use the `Keyv` adapter to configure the store:

content\_copy

```ts

// New version - supported
CacheModule.registerAsync({
  useFactory: async () => {
    return {
      stores: [\
        new KeyvRedis('redis://localhost:6379'),\
      ],
    };
  },
}),

```

Where `KeyvRedis` is imported from the `@keyv/redis` package. See the [Caching documentation](https://docs.nestjs.com/techniques/caching) to learn more.

> **Warning** In this update, cached data handled by the Keyv library is now structured as an object containing `value` and `expires` fields, for example: `{"value": "yourData", "expires": 1678901234567}`. While Keyv automatically retrieves the `value` field when accessing data through its API, it’s important to note this change if you interact with the cache data directly (e.g., outside of the cache-manager API) or need to support data written using the previous version of `@nestjs/cache-manager`.

#### Config module [\#](https://docs.nestjs.com/migration-guide\#config-module)

If you're using the `ConfigModule` from the `@nestjs/config` package, be aware of several breaking changes introduced in `@nestjs/config@4.0.0`. Most notably, the order in which configuration variables are read by the `ConfigService#get` method has been updated. The new order is:

- Internal configuration (config namespaces and custom config files)
- Validated environment variables (if validation is enabled and a schema is provided)
- The `process.env` object

Previously, validated environment variables and the `process.env` object were read first, preventing them from being overridden by internal configuration. With this update, internal configuration will now always take precedence over environment variables.

Additionally, the `ignoreEnvVars` configuration option, which previously allowed disabling validation of the `process.env` object, has been deprecated. Instead, use the `validatePredefined` option (set to `false` to disable validation of predefined environment variables). Predefined environment variables refer to `process.env` variables that were set before the module was imported. For example, if you start your application with `PORT=3000 node main.js`, the `PORT` variable is considered predefined. However, variables loaded by the `ConfigModule` from a `.env` file are not classified as predefined.

A new `skipProcessEnv` option has also been introduced. This option allows you to prevent the `ConfigService#get` method from accessing the `process.env` object entirely, which can be helpful when you want to restrict the service from reading environment variables directly.

#### Terminus module [\#](https://docs.nestjs.com/migration-guide\#terminus-module)

If you are using the `TerminusModule` and have built your own custom health indicator, a new API has been introduced in version 11. The new `HealthIndicatorService` is designed to enhance the readability and testability of custom health indicators.

Before version 11, a health indicator might have looked like this:

content\_copy

```typescript

@Injectable()
export class DogHealthIndicator extends HealthIndicator {
  constructor(private readonly httpService: HttpService) {
    super();
  }

  async isHealthy(key: string) {
    try {
      const badboys = await this.getBadboys();
      const isHealthy = badboys.length === 0;

      const result = this.getStatus(key, isHealthy, {
        badboys: badboys.length,
      });

      if (!isHealthy) {
        throw new HealthCheckError('Dog check failed', result);
      }

      return result;
    } catch (error) {
      const result = this.getStatus(key, isHealthy);
      throw new HealthCheckError('Dog check failed', result);
    }
  }

  private getBadboys() {
    return firstValueFrom(
      this.httpService.get<Dog[]>('https://example.com/dog').pipe(
        map((response) => response.data),
        map((dogs) => dogs.filter((dog) => dog.state === DogState.BAD_BOY)),
      ),
    );
  }
}

```

Starting with version 11, it is recommended to use the new `HealthIndicatorService` API, which streamlines the implementation process. Here's how the same health indicator can now be implemented:

content\_copy

```typescript

@Injectable()
export class DogHealthIndicator {
  constructor(
    private readonly httpService: HttpService,
    //  Inject the `HealthIndicatorService` provided by the `TerminusModule`
    private readonly healthIndicatorService: HealthIndicatorService,
  ) {}

  async isHealthy(key: string) {
    // Start the health indicator check for the given key
    const indicator = this.healthIndicatorService.check(key);

    try {
      const badboys = await this.getBadboys();
      const isHealthy = badboys.length === 0;

      if (!isHealthy) {
        // Mark the indicator as "down" and add additional info to the response
        return indicator.down({ badboys: badboys.length });
      }

      // Mark the health indicator as up
      return indicator.up();
    } catch (error) {
      return indicator.down('Unable to retrieve dogs');
    }
  }

  private getBadboys() {
    // ...
  }
}

```

Key changes:

- The `HealthIndicatorService` replaces the legacy `HealthIndicator` and `HealthCheckError` classes, providing a cleaner API for health checks.
- The `check` method allows for easy state tracking ( `up` or `down`) while supporting the inclusion of additional metadata in health check responses.

> **Info** Please note that the `HealthIndicator` and `HealthCheckError` classes have been marked as deprecated and are scheduled for removal in the next major release.

#### Node.js v16 and v18 no longer supported [\#](https://docs.nestjs.com/migration-guide\#nodejs-v16-and-v18-no-longer-supported)

Starting with NestJS 11, Node.js v16 is no longer supported, as it reached its end-of-life (EOL) on September 11, 2023. Likewise, the security support is scheduled to end on April 30, 2025 for Node.js v18, so we went ahead and dropped support for it as well.

NestJS 11 now requires **Node.js v20 or higher**.

To ensure the best experience, we strongly recommend using the latest LTS version of Node.js.

#### Mau official deployment platform [\#](https://docs.nestjs.com/migration-guide\#mau-official-deployment-platform)

In case you missed the announcement, we launched our official deployment platform, [Mau](https://www.mau.nestjs.com/), in 2024.
Mau is a fully managed platform that simplifies the deployment process for NestJS applications. With Mau, you can deploy your applications to the cloud ( **AWS**; Amazon Web Services) with a single command, manage your environment variables, and monitor your application's performance in real-time.

Mau makes provisioning and maintaining your infrastructure as simple as clicking just a few buttons. Mau is designed to be simple and intuitive, so you can focus on building your applications and not worry about the underlying infrastructure. Under the hood, we use Amazon Web Services to provide you with a powerful and reliable platform, while abstracting away all the complexity of AWS. We take care of all the heavy lifting for you, so you can focus on building your applications and growing your business.

```bash

$ npm install -g @nestjs/mau
$ mau deploy

```

You can learn more about Mau [in this chapter](https://docs.nestjs.com/deployment#easy-deployment-with-mau).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Framework
### Introduction

Nest is a framework for building efficient, scalable [Node.js](http://nodejs.org/) server-side applications. It uses progressive JavaScript, is built with [TypeScript](http://www.typescriptlang.org/) (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

Under the hood, Nest makes use of [Express](https://expressjs.com/), but also provides compatibility with a wide range of other libraries (e.g. [Fastify](https://github.com/fastify/fastify)). This allows for easy use of the myriad third-party plugins which are available.

### Philosophy

In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications. This has given rise to awesome projects like [Angular](https://angular.io/), [React](https://github.com/facebook/react) and [Vue](https://github.com/vuejs/vue) which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, while plenty of superb libraries, helpers, and tools exist for Node (and server-side JavaScript), none of them effectively solve the main problem - **architecture**.

Nest provides an out-of-the-box application architecture which allows for effortless creation of highly testable, scalable, loosely coupled, and easily maintainable applications.

### Installation

To get started, scaffold the base project with the [Nest CLI](https://docs.nestjs.com/v5/cli/overview):

```  bash

$ npm i -g @nestjs/cli
$ nest new project-name
```

Install the starter project with **Git**:

JS  TS

```  bash

$ git clone https://github.com/nestjs/typescript-starter.git project
$ cd project
$ npm install
$ npm run start
```

```  bash

$ git clone https://github.com/nestjs/javascript-starter.git project
$ cd project
$ npm install
$ npm run start
```

Or start a new project from scratch with **npm** (or **yarn**):

```  bash

$ npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata
```

### Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com/ "Kamil Mysliwiec Blog | Full-Stack Software Engineer")
- Website - [https://nestjs.com](https://nestjs.com/ "NestJS - A node.js framework built on top of TypeScript")
- Twitter - [@nestframework](https://twitter.com/nestframework)

- Introduction
- Philosophy
- Installation
- Stay in touch

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support by these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/v5/support).

#### Principal Sponsor

[![](https://docs.nestjs.com/assets/sponsors/valor-software.png)](https://valor-software.com/)

#### Sponsors / Backers

[![](https://nestjs.com/logo-xtremis.0feb160c.svg)](http://www.xtremis.com/en)

[![](https://opencollective.com/nest/backer/0/avatar.svg)](https://opencollective.com/nest/backer/0/website)[![](https://opencollective.com/nest/backer/1/avatar.svg)](https://opencollective.com/nest/backer/1/website)[![](https://opencollective.com/nest/backer/2/avatar.svg)](https://opencollective.com/nest/backer/2/website)[![](https://opencollective.com/nest/backer/3/avatar.svg)](https://opencollective.com/nest/backer/3/website)[![](https://opencollective.com/nest/backer/4/avatar.svg)](https://opencollective.com/nest/backer/4/website)[![](https://opencollective.com/nest/backer/5/avatar.svg)](https://opencollective.com/nest/backer/5/website)[![](https://opencollective.com/nest/backer/6/avatar.svg)](https://opencollective.com/nest/backer/6/website)[![](https://opencollective.com/nest/backer/7/avatar.svg)](https://opencollective.com/nest/backer/7/website)[![](https://opencollective.com/nest/backer/8/avatar.svg)](https://opencollective.com/nest/backer/8/website)[![](https://opencollective.com/nest/backer/9/avatar.svg)](https://opencollective.com/nest/backer/9/website)[![](https://opencollective.com/nest/backer/10/avatar.svg)](https://opencollective.com/nest/backer/10/website)[![](https://opencollective.com/nest/backer/11/avatar.svg)](https://opencollective.com/nest/backer/11/website)[![](https://opencollective.com/nest/backer/12/avatar.svg)](https://opencollective.com/nest/backer/12/website)[![](https://opencollective.com/nest/backer/13/avatar.svg)](https://opencollective.com/nest/backer/13/website)[![](https://opencollective.com/nest/backer/14/avatar.svg)](https://opencollective.com/nest/backer/14/website)[![](https://opencollective.com/nest/backer/15/avatar.svg)](https://opencollective.com/nest/backer/15/website)[![](https://opencollective.com/nest/backer/16/avatar.svg)](https://opencollective.com/nest/backer/16/website)[![](https://opencollective.com/nest/backer/17/avatar.svg)](https://opencollective.com/nest/backer/17/website)[![](https://opencollective.com/nest/backer/18/avatar.svg)](https://opencollective.com/nest/backer/18/website)[![](https://opencollective.com/nest/backer/19/avatar.svg)](https://opencollective.com/nest/backer/19/website)[![](https://opencollective.com/nest/backer/20/avatar.svg)](https://opencollective.com/nest/backer/20/website)[![](https://opencollective.com/nest/backer/21/avatar.svg)](https://opencollective.com/nest/backer/21/website)[![](https://opencollective.com/nest/backer/22/avatar.svg)](https://opencollective.com/nest/backer/22/website)[![](https://opencollective.com/nest/backer/23/avatar.svg)](https://opencollective.com/nest/backer/23/website)[![](https://opencollective.com/nest/backer/24/avatar.svg)](https://opencollective.com/nest/backer/24/website)[![](https://opencollective.com/nest/backer/25/avatar.svg)](https://opencollective.com/nest/backer/25/website)[![](https://opencollective.com/nest/backer/26/avatar.svg)](https://opencollective.com/nest/backer/26/website)[![](https://opencollective.com/nest/backer/27/avatar.svg)](https://opencollective.com/nest/backer/27/website)[![](https://opencollective.com/nest/backer/28/avatar.svg)](https://opencollective.com/nest/backer/28/website)[![](https://opencollective.com/nest/backer/29/avatar.svg)](https://opencollective.com/nest/backer/29/website)[![](https://opencollective.com/nest/backer/30/avatar.svg)](https://opencollective.com/nest/backer/30/website)[![](https://opencollective.com/nest/backer/31/avatar.svg)](https://opencollective.com/nest/backer/31/website)[![](https://opencollective.com/nest/backer/32/avatar.svg)](https://opencollective.com/nest/backer/32/website)[![](https://opencollective.com/nest/backer/33/avatar.svg)](https://opencollective.com/nest/backer/33/website)[![](https://opencollective.com/nest/backer/34/avatar.svg)](https://opencollective.com/nest/backer/34/website)[![](https://opencollective.com/nest/backer/35/avatar.svg)](https://opencollective.com/nest/backer/35/website)[![](https://opencollective.com/nest/backer/36/avatar.svg)](https://opencollective.com/nest/backer/36/website)[![](https://opencollective.com/nest/backer/37/avatar.svg)](https://opencollective.com/nest/backer/37/website)[![](https://opencollective.com/nest/backer/38/avatar.svg)](https://opencollective.com/nest/backer/38/website)[![](https://opencollective.com/nest/backer/39/avatar.svg)](https://opencollective.com/nest/backer/39/website)[![](https://opencollective.com/nest/backer/40/avatar.svg)](https://opencollective.com/nest/backer/40/website)[![](https://opencollective.com/nest/backer/41/avatar.svg)](https://opencollective.com/nest/backer/41/website)[![](https://opencollective.com/nest/backer/42/avatar.svg)](https://opencollective.com/nest/backer/42/website)[![](https://opencollective.com/nest/backer/43/avatar.svg)](https://opencollective.com/nest/backer/43/website)[![](https://opencollective.com/nest/backer/44/avatar.svg)](https://opencollective.com/nest/backer/44/website)[![](https://opencollective.com/nest/backer/45/avatar.svg)](https://opencollective.com/nest/backer/45/website)[![](https://opencollective.com/nest/backer/46/avatar.svg)](https://opencollective.com/nest/backer/46/website)[![](https://opencollective.com/nest/backer/47/avatar.svg)](https://opencollective.com/nest/backer/47/website)[![](https://opencollective.com/nest/backer/48/avatar.svg)](https://opencollective.com/nest/backer/48/website)[![](https://opencollective.com/nest/backer/49/avatar.svg)](https://opencollective.com/nest/backer/49/website)

## NestJS Health Checks
- [Healthchecks (Terminus)](https://docs.nestjs.com/recipes/terminus#healthchecks-terminus)
- [Getting started](https://docs.nestjs.com/recipes/terminus#getting-started)
- [Setting up a Healthcheck](https://docs.nestjs.com/recipes/terminus#setting-up-a-healthcheck)
- [HTTP Healthcheck](https://docs.nestjs.com/recipes/terminus#http-healthcheck)
- [TypeOrm health indicator](https://docs.nestjs.com/recipes/terminus#typeorm-health-indicator)
- [Disk health indicator](https://docs.nestjs.com/recipes/terminus#disk-health-indicator)
- [Memory health indicator](https://docs.nestjs.com/recipes/terminus#memory-health-indicator)
- [Custom health indicator](https://docs.nestjs.com/recipes/terminus#custom-health-indicator)
- [Logging](https://docs.nestjs.com/recipes/terminus#logging)
- [Graceful shutdown timeout](https://docs.nestjs.com/recipes/terminus#graceful-shutdown-timeout)
- [More examples](https://docs.nestjs.com/recipes/terminus#more-examples)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/terminus.md "Suggest Edits")

### Healthchecks (Terminus)

Terminus integration provides you with **readiness/liveness** health checks. Healthchecks are crucial when it comes to complex
backend setups. In a nutshell, a health check in the realm of web development usually consists of a special address, for example, `https://my-website.com/health/readiness`.
A service or a component of your infrastructure (e.g., [Kubernetes](https://kubernetes.io/) checks this address continuously). Depending on the HTTP status code returned from a `GET` request to this address the service will take action when it receives an "unhealthy" response.
Since the definition of "healthy" or "unhealthy" varies with the type of service you provide, the **Terminus** integration supports you with a
set of **health indicators**.

As an example, if your web server uses MongoDB to store its data, it would be vital information whether MongoDB is still up and running.
In that case, you can make use of the `MongooseHealthIndicator`. If configured correctly - more on that later - your health check address will return
a healthy or unhealthy HTTP status code, depending on whether MongoDB is running.

#### Getting started [\#](https://docs.nestjs.com/recipes/terminus\#getting-started)

To get started with `@nestjs/terminus` we need to install the required dependency.

```bash

$ npm install --save @nestjs/terminus

```

#### Setting up a Healthcheck [\#](https://docs.nestjs.com/recipes/terminus\#setting-up-a-healthcheck)

A health check represents a summary of **health indicators**. A health indicator executes a check of a service, whether it is in a healthy or unhealthy state. A health check is positive if all the assigned health indicators are up and running. Because a lot of applications will need similar health indicators, [`@nestjs/terminus`](https://github.com/nestjs/terminus) provides a set of predefined indicators, such as:

- `HttpHealthIndicator`
- `TypeOrmHealthIndicator`
- `MongooseHealthIndicator`
- `SequelizeHealthIndicator`
- `MikroOrmHealthIndicator`
- `PrismaHealthIndicator`
- `MicroserviceHealthIndicator`
- `GRPCHealthIndicator`
- `MemoryHealthIndicator`
- `DiskHealthIndicator`

To get started with our first health check, let's create the `HealthModule` and import the `TerminusModule` into it in its imports array.

> **Hint** To create the module using the [Nest CLI](https://docs.nestjs.com/recipes/terminus/cli/overview), simply execute the `$ nest g module health` command.

content\_copy health.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';

@Module({
  imports: [TerminusModule]
})
export class HealthModule {}

```

Our healthcheck(s) can be executed using a [controller](https://docs.nestjs.com/controllers), which can be easily set up using the [Nest CLI](https://docs.nestjs.com/recipes/terminus/cli/overview).

```bash

$ nest g controller health

```

> **Info** It is highly recommended to enable shutdown hooks in your application. Terminus integration makes use of this lifecycle event if enabled. Read more about shutdown hooks [here](https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown).

#### HTTP Healthcheck [\#](https://docs.nestjs.com/recipes/terminus\#http-healthcheck)

Once we have installed `@nestjs/terminus`, imported our `TerminusModule` and created a new controller, we are ready to create a health check.

The `HTTPHealthIndicator` requires the `@nestjs/axios` package so make sure to have it installed:

```bash

$ npm i --save @nestjs/axios axios

```

Now we can setup our `HealthController`:

content\_copy health.controller.ts

JS  TS

```typescript

import { Controller, Get } from '@nestjs/common';
import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([\
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),\
    ]);
  }
}

```

```typescript

import { Controller, Dependencies, Get } from '@nestjs/common';
import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';

@Controller('health')
@Dependencies(HealthCheckService, HttpHealthIndicator)
export class HealthController {
  constructor(
    private health,
    private http,
  ) { }

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),\
    ])
  }
}

```

content\_copy health.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HttpModule } from '@nestjs/axios';
import { HealthController } from './health.controller';

@Module({
  imports: [TerminusModule, HttpModule],
  controllers: [HealthController],
})
export class HealthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HttpModule } from '@nestjs/axios';
import { HealthController } from './health.controller';

@Module({
  imports: [TerminusModule, HttpModule],
  controllers: [HealthController],
})
export class HealthModule {}

```

Our health check will now send a _GET_-request to the `https://docs.nestjs.com` address. If
we get a healthy response from that address, our route at `http://localhost:3000/health` will return
the following object with a 200 status code.

```json

{
  "status": "ok",
  "info": {
    "nestjs-docs": {
      "status": "up"
    }
  },
  "error": {},
  "details": {
    "nestjs-docs": {
      "status": "up"
    }
  }
}

```

The interface of this response object can be accessed from the `@nestjs/terminus` package with the `HealthCheckResult` interface.

| `status` | If any health indicator failed the status will be `'error'`. If the NestJS app is shutting down but still accepting HTTP requests, the health check will have the `'shutting_down'` status. | `'error' | 'ok' | 'shutting_down'` |
| `info` | Object containing information of each health indicator which is of status `'up'`, or in other words "healthy". | `object` |
| `error` | Object containing information of each health indicator which is of status `'down'`, or in other words "unhealthy". | `object` |
| `details` | Object containing all information of each health indicator | `object` |

##### Check for specific HTTP response codes

In certain cases, you might want to check for specific criteria and validate the response. As an example, let's assume
`https://my-external-service.com` returns a response code `204`. With `HttpHealthIndicator.responseCheck` you can
check for that response code specifically and determine all other codes as unhealthy.

In case any other response code other than `204` gets returned, the following example would be unhealthy. The third parameter
requires you to provide a function (sync or async) which returns a boolean whether the response is considered
healthy ( `true`) or unhealthy ( `false`).

content\_copy health.controller.ts

JS  TS

```typescript

// Within the `HealthController`-class

@Get()
@HealthCheck()
check() {
  return this.health.check([\
    () =>\
      this.http.responseCheck(\
        'my-external-service',\
        'https://my-external-service.com',\
        (res) => res.status === 204,\
      ),\
  ]);
}

```

#### TypeOrm health indicator [\#](https://docs.nestjs.com/recipes/terminus\#typeorm-health-indicator)

Terminus offers the capability to add database checks to your health check. In order to get started with this health indicator, you
should check out the [Database chapter](https://docs.nestjs.com/techniques/sql) and make sure your database connection within your application is established.

> **Hint** Behind the scenes the `TypeOrmHealthIndicator` simply executes a `SELECT 1`-SQL command which is often used to verify whether the database still alive. In case you are using an Oracle database it uses `SELECT 1 FROM DUAL`.

content\_copy health.controller.ts

JS  TS

```typescript

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: TypeOrmHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([\
      () => this.db.pingCheck('database'),\
    ]);
  }
}

```

```typescript

@Controller('health')
@Dependencies(HealthCheckService, TypeOrmHealthIndicator)
export class HealthController {
  constructor(
    private health,
    private db,
  ) { }

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.db.pingCheck('database'),\
    ])
  }
}

```

If your database is reachable, you should now see the following JSON-result when requesting `http://localhost:3000/health` with a `GET` request:

```json

{
  "status": "ok",
  "info": {
    "database": {
      "status": "up"
    }
  },
  "error": {},
  "details": {
    "database": {
      "status": "up"
    }
  }
}

```

In case your app uses [multiple databases](https://docs.nestjs.com/techniques/database#multiple-databases), you need to inject each
connection into your `HealthController`. Then, you can simply pass the connection reference to the `TypeOrmHealthIndicator`.

content\_copy health.controller.ts

JS  TS

```typescript

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: TypeOrmHealthIndicator,
    @InjectConnection('albumsConnection')
    private albumsConnection: Connection,
    @InjectConnection()
    private defaultConnection: Connection,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([\
      () => this.db.pingCheck('albums-database', { connection: this.albumsConnection }),\
      () => this.db.pingCheck('database', { connection: this.defaultConnection }),\
    ]);
  }
}

```

#### Disk health indicator [\#](https://docs.nestjs.com/recipes/terminus\#disk-health-indicator)

With the `DiskHealthIndicator` we can check how much storage is in use. To get started, make sure to inject the `DiskHealthIndicator`
into your `HealthController`. The following example checks the storage used of the path `/` (or on Windows you can use `C:\\`).
If that exceeds more than 50% of the total storage space it would response with an unhealthy Health Check.

content\_copy health.controller.ts

JS  TS

```typescript

@Controller('health')
export class HealthController {
  constructor(
    private readonly health: HealthCheckService,
    private readonly disk: DiskHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([\
      () => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.5 }),\
    ]);
  }
}

```

```typescript

@Controller('health')
@Dependencies(HealthCheckService, DiskHealthIndicator)
export class HealthController {
  constructor(health, disk) {}

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.5 }),\
    ])
  }
}

```

With the `DiskHealthIndicator.checkStorage` function you also have the possibility to check for a fixed amount of space.
The following example would be unhealthy in case the path `/my-app/` would exceed 250GB.

content\_copy health.controller.ts

JS  TS

```typescript

// Within the `HealthController`-class

@Get()
@HealthCheck()
check() {
  return this.health.check([\
    () => this.disk.checkStorage('storage', {  path: '/', threshold: 250 * 1024 * 1024 * 1024, })\
  ]);
}

```

#### Memory health indicator [\#](https://docs.nestjs.com/recipes/terminus\#memory-health-indicator)

To make sure your process does not exceed a certain memory limit the `MemoryHealthIndicator` can be used. The following example can be used to check the heap of your process.

> **Hint** Heap is the portion of memory where dynamically allocated memory resides (i.e. memory allocated via malloc). Memory allocated from the heap will remain allocated until one of the following occurs:
>
> - The memory is _free_'d
> - The program terminates

content\_copy health.controller.ts

JS  TS

```typescript

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private memory: MemoryHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([\
      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),\
    ]);
  }
}

```

```typescript

@Controller('health')
@Dependencies(HealthCheckService, MemoryHealthIndicator)
export class HealthController {
  constructor(health, memory) {}

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),\
    ])
  }
}

```

It is also possible to verify the memory RSS of your process with `MemoryHealthIndicator.checkRSS`. This example
would return an unhealthy response code in case your process does have more than 150MB allocated.

> **Hint** RSS is the Resident Set Size and is used to show how much memory is allocated to that process and is in RAM.
> It does not include memory that is swapped out. It does include memory from shared libraries as long as the pages from
> those libraries are actually in memory. It does include all stack and heap memory.

content\_copy health.controller.ts

JS  TS

```typescript

// Within the `HealthController`-class

@Get()
@HealthCheck()
check() {
  return this.health.check([\
    () => this.memory.checkRSS('memory_rss', 150 * 1024 * 1024),\
  ]);
}

```

#### Custom health indicator [\#](https://docs.nestjs.com/recipes/terminus\#custom-health-indicator)

In some cases, the predefined health indicators provided by `@nestjs/terminus` do not cover all of your health check requirements. In that case, you can set up a custom health indicator according to your needs.

Let's get started by creating a service that will represent our custom indicator. To get a basic understanding of how an indicator is structured, we will create an example `DogHealthIndicator`. This service should have the state `'up'` if every `Dog` object has the type `'goodboy'`. If that condition is not satisfied then it should throw an error.

content\_copy dog.health.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { HealthIndicatorService } from '@nestjs/terminus';

export interface Dog {
  name: string;
  type: string;
}

@Injectable()
export class DogHealthIndicator {
  constructor(
    private readonly healthIndicatorService: HealthIndicatorService
  ) {}

  private dogs: Dog[] = [\
    { name: 'Fido', type: 'goodboy' },\
    { name: 'Rex', type: 'badboy' },\
  ];

  async isHealthy(key: string){
    const indicator = this.healthIndicatorService.check(key);
    const badboys = this.dogs.filter(dog => dog.type === 'badboy');
    const isHealthy = badboys.length === 0;

    if (!isHealthy) {
      return indicator.down({ badboys: badboys.length });
    }

    return indicator.up();
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { HealthIndicatorService } from '@nestjs/terminus';

@Injectable()
@Dependencies(HealthIndicatorService)
export class DogHealthIndicator {
  constructor(healthIndicatorService) {
    this.healthIndicatorService = healthIndicatorService;
  }

  private dogs = [\
    { name: 'Fido', type: 'goodboy' },\
    { name: 'Rex', type: 'badboy' },\
  ];

  async isHealthy(key){
    const indicator = this.healthIndicatorService.check(key);
    const badboys = this.dogs.filter(dog => dog.type === 'badboy');
    const isHealthy = badboys.length === 0;

    if (!isHealthy) {
      return indicator.down({ badboys: badboys.length });
    }

    return indicator.up();
  }
}

```

The next thing we need to do is register the health indicator as a provider.

content\_copy health.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { DogHealthIndicator } from './dog.health';

@Module({
  controllers: [HealthController],
  imports: [TerminusModule],
  providers: [DogHealthIndicator]
})
export class HealthModule { }

```

> **Hint** In a real-world application the `DogHealthIndicator` should be provided in a separate module, for example, `DogModule`, which then will be imported by the `HealthModule`.

The last required step is to add the now available health indicator in the required health check endpoint. For that, we go back to our `HealthController` and add it to our `check` function.

content\_copy health.controller.ts

JS  TS

```typescript

import { HealthCheckService, HealthCheck } from '@nestjs/terminus';
import { Injectable, Dependencies, Get } from '@nestjs/common';
import { DogHealthIndicator } from './dog.health';

@Injectable()
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private dogHealthIndicator: DogHealthIndicator
  ) {}

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.dogHealthIndicator.isHealthy('dog'),\
    ])
  }
}

```

```typescript

import { HealthCheckService, HealthCheck } from '@nestjs/terminus';
import { Injectable, Get } from '@nestjs/common';
import { DogHealthIndicator } from './dog.health';

@Injectable()
@Dependencies(HealthCheckService, DogHealthIndicator)
export class HealthController {
  constructor(
    health,
    dogHealthIndicator
  ) {
    this.health = health;
    this.dogHealthIndicator = dogHealthIndicator;
  }

  @Get()
  @HealthCheck()
  healthCheck() {
    return this.health.check([\
      () => this.dogHealthIndicator.isHealthy('dog'),\
    ])
  }
}

```

#### Logging [\#](https://docs.nestjs.com/recipes/terminus\#logging)

Terminus only logs error messages, for instance when a Healthcheck has failed. With the `TerminusModule.forRoot()` method you have more control over how errors are being logged
as well as completely take over the logging itself.

In this section, we are going to walk you through how you create a custom logger `TerminusLogger`. This logger extends the built-in logger.
Therefore you can pick and choose which part of the logger you would like to overwrite

> **Info** If you want to learn more about custom loggers in NestJS, [read more here](https://docs.nestjs.com/techniques/logger#injecting-a-custom-logger).

content\_copy terminus-logger.service.ts

JS  TS

```typescript

import { Injectable, Scope, ConsoleLogger } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class TerminusLogger extends ConsoleLogger {
  error(message: any, stack?: string, context?: string): void;
  error(message: any, ...optionalParams: any[]): void;
  error(
    message: unknown,
    stack?: unknown,
    context?: unknown,
    ...rest: unknown[]
  ): void {
    // Overwrite here how error messages should be logged
  }
}

```

Once you have created your custom logger, all you need to do is simply pass it into the `TerminusModule.forRoot()` as such.

content\_copy health.module.ts

JS  TS

```typescript

@Module({
imports: [\
  TerminusModule.forRoot({\
    logger: TerminusLogger,\
  }),\
],
})
export class HealthModule {}

```

To completely suppress any log messages coming from Terminus, including error messages, configure Terminus as such.

content\_copy health.module.ts

JS  TS

```typescript

@Module({
imports: [\
  TerminusModule.forRoot({\
    logger: false,\
  }),\
],
})
export class HealthModule {}

```

Terminus allows you to configure how Healthcheck errors should be displayed in your logs.

| Error Log Style | Description | Example |
| :-- | :-- | :-- |
| `json` (default) | Prints a summary of the health check result in case of an error as JSON object | ![](https://docs.nestjs.com/assets/Terminus_Error_Log_Json.png) |
| `pretty` | Prints a summary of the health check result in case of an error within formatted boxes and highlights successful/erroneous results | ![](https://docs.nestjs.com/assets/Terminus_Error_Log_Pretty.png) |

You can change the log style using the `errorLogStyle` configuration option as in the following snippet.

content\_copy health.module.ts

JS  TS

```typescript

@Module({
  imports: [\
    TerminusModule.forRoot({\
      errorLogStyle: 'pretty',\
    }),\
  ]
})
export class HealthModule {}

```

#### Graceful shutdown timeout [\#](https://docs.nestjs.com/recipes/terminus\#graceful-shutdown-timeout)

If your application requires postponing its shutdown process, Terminus can handle it for you.
This setting can prove particularly beneficial when working with an orchestrator such as Kubernetes.
By setting a delay slightly longer than the readiness check interval, you can achieve zero downtime when shutting down containers.

content\_copy health.module.ts

JS  TS

```typescript

@Module({
  imports: [\
    TerminusModule.forRoot({\
      gracefulShutdownTimeoutMs: 1000,\
    }),\
  ]
})
export class HealthModule {}

```

#### More examples [\#](https://docs.nestjs.com/recipes/terminus\#more-examples)

More working examples are available [here](https://github.com/nestjs/terminus/tree/master/sample).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Configuration Guide
- [Configuration](https://docs.nestjs.com/techniques/configuration#configuration)
- [Installation](https://docs.nestjs.com/techniques/configuration#installation)
- [Getting started](https://docs.nestjs.com/techniques/configuration#getting-started)
- [Custom env file path](https://docs.nestjs.com/techniques/configuration#custom-env-file-path)
- [Disable env variables loading](https://docs.nestjs.com/techniques/configuration#disable-env-variables-loading)
- [Use module globally](https://docs.nestjs.com/techniques/configuration#use-module-globally)
- [Custom configuration files](https://docs.nestjs.com/techniques/configuration#custom-configuration-files)
- [Using the ConfigService](https://docs.nestjs.com/techniques/configuration#using-the-configservice)
- [Configuration namespaces](https://docs.nestjs.com/techniques/configuration#configuration-namespaces)
- [Namespaced configurations in modules](https://docs.nestjs.com/techniques/configuration#namespaced-configurations-in-modules)
- [Cache environment variables](https://docs.nestjs.com/techniques/configuration#cache-environment-variables)
- [Partial registration](https://docs.nestjs.com/techniques/configuration#partial-registration)
- [Schema validation](https://docs.nestjs.com/techniques/configuration#schema-validation)
- [Custom validate function](https://docs.nestjs.com/techniques/configuration#custom-validate-function)
- [Custom getter functions](https://docs.nestjs.com/techniques/configuration#custom-getter-functions)
- [Environment variables loaded hook](https://docs.nestjs.com/techniques/configuration#environment-variables-loaded-hook)
- [Conditional module configuration](https://docs.nestjs.com/techniques/configuration#conditional-module-configuration)
- [Expandable variables](https://docs.nestjs.com/techniques/configuration#expandable-variables)
- [Using in the main.ts](https://docs.nestjs.com/techniques/configuration#using-in-the-maints)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/configuration.md "Suggest Edits")

### Configuration

Applications often run in different **environments**. Depending on the environment, different configuration settings should be used. For example, usually the local environment relies on specific database credentials, valid only for the local DB instance. The production environment would use a separate set of DB credentials. Since configuration variables change, best practice is to [store configuration variables](https://12factor.net/config) in the environment.

Externally defined environment variables are visible inside Node.js through the `process.env` global. We could try to solve the problem of multiple environments by setting the environment variables separately in each environment. This can quickly get unwieldy, especially in the development and testing environments where these values need to be easily mocked and/or changed.

In Node.js applications, it's common to use `.env` files, holding key-value pairs where each key represents a particular value, to represent each environment. Running an app in different environments is then just a matter of swapping in the correct `.env` file.

A good approach for using this technique in Nest is to create a `ConfigModule` that exposes a `ConfigService` which loads the appropriate `.env` file. While you may choose to write such a module yourself, for convenience Nest provides the `@nestjs/config` package out-of-the box. We'll cover this package in the current chapter.

#### Installation [\#](https://docs.nestjs.com/techniques/configuration\#installation)

To begin using it, we first install the required dependency.

```bash

$ npm i --save @nestjs/config

```

> **Hint** The `@nestjs/config` package internally uses [dotenv](https://github.com/motdotla/dotenv).

> **Note** `@nestjs/config` requires TypeScript 4.1 or later.

#### Getting started [\#](https://docs.nestjs.com/techniques/configuration\#getting-started)

Once the installation process is complete, we can import the `ConfigModule`. Typically, we'll import it into the root `AppModule` and control its behavior using the `.forRoot()` static method. During this step, environment variable key/value pairs are parsed and resolved. Later, we'll see several options for accessing the `ConfigService` class of the `ConfigModule` in our other feature modules.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot()],
})
export class AppModule {}

```

The above code will load and parse a `.env` file from the default location (the project root directory), merge key/value pairs from the `.env` file with environment variables assigned to `process.env`, and store the result in a private structure that you can access through the `ConfigService`. The `forRoot()` method registers the `ConfigService` provider, which provides a `get()` method for reading these parsed/merged configuration variables. Since `@nestjs/config` relies on [dotenv](https://github.com/motdotla/dotenv), it uses that package's rules for resolving conflicts in environment variable names. When a key exists both in the runtime environment as an environment variable (e.g., via OS shell exports like `export DATABASE_USER=test`) and in a `.env` file, the runtime environment variable takes precedence.

A sample `.env` file looks something like this:

```json

DATABASE_USER=test
DATABASE_PASSWORD=test

```

If you need some env variables to be available even before the `ConfigModule` is loaded and Nest application is bootstrapped (for example, to pass the microservice configuration to the `NestFactory#createMicroservice` method), you can use the `--env-file` option of the Nest CLI. This option allows you to specify the path to the `.env` file that should be loaded before the application starts. `--env-file` flag support was introduced in Node v20, see [the documentation](https://nodejs.org/dist/v20.18.1/docs/api/cli.html#--env-fileconfig) for more details.

```bash

$ nest start --env-file .env

```

#### Custom env file path [\#](https://docs.nestjs.com/techniques/configuration\#custom-env-file-path)

By default, the package looks for a `.env` file in the root directory of the application. To specify another path for the `.env` file, set the `envFilePath` property of an (optional) options object you pass to `forRoot()`, as follows:

content\_copy

```typescript

ConfigModule.forRoot({
  envFilePath: '.development.env',
});

```

You can also specify multiple paths for `.env` files like this:

content\_copy

```typescript

ConfigModule.forRoot({
  envFilePath: ['.env.development.local', '.env.development'],
});

```

If a variable is found in multiple files, the first one takes precedence.

#### Disable env variables loading [\#](https://docs.nestjs.com/techniques/configuration\#disable-env-variables-loading)

If you don't want to load the `.env` file, but instead would like to simply access environment variables from the runtime environment (as with OS shell exports like `export DATABASE_USER=test`), set the options object's `ignoreEnvFile` property to `true`, as follows:

content\_copy

```typescript

ConfigModule.forRoot({
  ignoreEnvFile: true,
});

```

#### Use module globally [\#](https://docs.nestjs.com/techniques/configuration\#use-module-globally)

When you want to use `ConfigModule` in other modules, you'll need to import it (as is standard with any Nest module). Alternatively, declare it as a [global module](https://docs.nestjs.com/modules#global-modules) by setting the options object's `isGlobal` property to `true`, as shown below. In that case, you will not need to import `ConfigModule` in other modules once it's been loaded in the root module (e.g., `AppModule`).

content\_copy

```typescript

ConfigModule.forRoot({
  isGlobal: true,
});

```

#### Custom configuration files [\#](https://docs.nestjs.com/techniques/configuration\#custom-configuration-files)

For more complex projects, you may utilize custom configuration files to return nested configuration objects. This allows you to group related configuration settings by function (e.g., database-related settings), and to store related settings in individual files to help manage them independently.

A custom configuration file exports a factory function that returns a configuration object. The configuration object can be any arbitrarily nested plain JavaScript object. The `process.env` object will contain the fully resolved environment variable key/value pairs (with `.env` file and externally defined variables resolved and merged as described [above](https://docs.nestjs.com/techniques/configuration#getting-started)). Since you control the returned configuration object, you can add any required logic to cast values to an appropriate type, set default values, etc. For example:

content\_copy config/configuration.ts

JS  TS

```typescript

export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  database: {
    host: process.env.DATABASE_HOST,
    port: parseInt(process.env.DATABASE_PORT, 10) || 5432
  }
});

```

We load this file using the `load` property of the options object we pass to the `ConfigModule.forRoot()` method:

content\_copy

```typescript

import configuration from './config/configuration';

@Module({
  imports: [\
    ConfigModule.forRoot({\
      load: [configuration],\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** The value assigned to the `load` property is an array, allowing you to load multiple configuration files (e.g. `load: [databaseConfig, authConfig]`)

With custom configuration files, we can also manage custom files such as YAML files. Here is an example of a configuration using YAML format:

```yaml

http:
  host: 'localhost'
  port: 8080

db:
  postgres:
    url: 'localhost'
    port: 5432
    database: 'yaml-db'

  sqlite:
    database: 'sqlite.db'

```

To read and parse YAML files, we can leverage the `js-yaml` package.

```bash

$ npm i js-yaml
$ npm i -D @types/js-yaml

```

Once the package is installed, we use the `yaml#load` function to load the YAML file we just created above.

content\_copy config/configuration.ts

JS  TS

```typescript

import { readFileSync } from 'fs';
import * as yaml from 'js-yaml';
import { join } from 'path';

const YAML_CONFIG_FILENAME = 'config.yaml';

export default () => {
  return yaml.load(
    readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),
  ) as Record<string, any>;
};

```

> **Note** Nest CLI does not automatically move your "assets" (non-TS files) to the `dist` folder during the build process. To make sure that your YAML files are copied, you have to specify this in the `compilerOptions#assets` object in the `nest-cli.json` file. As an example, if the `config` folder is at the same level as the `src` folder, add `compilerOptions#assets` with the value `"assets": [{"include": "../config/*.yaml", "outDir": "./dist/config"}]`. Read more [here](https://docs.nestjs.com/cli/monorepo#assets).

Just a quick note - configuration files aren't automatically validated, even if you're using the `validationSchema` option in NestJS's `ConfigModule`. If you need validation or want to apply any transformations, you'll have to handle that within the factory function where you have complete control over the configuration object. This allows you to implement any custom validation logic as needed.

For example, if you want to ensure that port is within a certain range, you can add a validation step to the factory function:

content\_copy config/configuration.ts

JS  TS

```typescript

export default () => {
  const config = yaml.load(
    readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),
  ) as Record<string, any>;

  if (config.http.port < 1024 || config.http.port > 49151) {
    throw new Error('HTTP port must be between 1024 and 49151');
  }

  return config;
};

```

Now, if the port is outside the specified range, the application will throw an error during startup.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Using the `ConfigService` [\#](https://docs.nestjs.com/techniques/configuration\#using-the-configservice)

To access configuration values from our `ConfigService`, we first need to inject `ConfigService`. As with any provider, we need to import its containing module - the `ConfigModule` \- into the module that will use it (unless you set the `isGlobal` property in the options object passed to the `ConfigModule.forRoot()` method to `true`). Import it into a feature module as shown below.

content\_copy feature.module.ts

JS  TS

```typescript

@Module({
  imports: [ConfigModule],
  // ...
})

```

Then we can inject it using standard constructor injection:

content\_copy

```typescript

constructor(private configService: ConfigService) {}

```

> **Hint** The `ConfigService` is imported from the `@nestjs/config` package.

And use it in our class:

content\_copy

```typescript

// get an environment variable
const dbUser = this.configService.get<string>('DATABASE_USER');

// get a custom configuration value
const dbHost = this.configService.get<string>('database.host');

```

As shown above, use the `configService.get()` method to get a simple environment variable by passing the variable name. You can do TypeScript type hinting by passing the type, as shown above (e.g., `get<string>(...)`). The `get()` method can also traverse a nested custom configuration object (created via a [Custom configuration file](https://docs.nestjs.com/techniques/configuration#custom-configuration-files)), as shown in the second example above.

You can also get the whole nested custom configuration object using an interface as the type hint:

content\_copy

```typescript

interface DatabaseConfig {
  host: string;
  port: number;
}

const dbConfig = this.configService.get<DatabaseConfig>('database');

// you can now use `dbConfig.port` and `dbConfig.host`
const port = dbConfig.port;

```

The `get()` method also takes an optional second argument defining a default value, which will be returned when the key doesn't exist, as shown below:

content\_copy

```typescript

// use "localhost" when "database.host" is not defined
const dbHost = this.configService.get<string>('database.host', 'localhost');

```

`ConfigService` has two optional generics (type arguments). The first one is to help prevent accessing a config property that does not exist. Use it as shown below:

content\_copy

```typescript

interface EnvironmentVariables {
  PORT: number;
  TIMEOUT: string;
}

// somewhere in the code
constructor(private configService: ConfigService<EnvironmentVariables>) {
  const port = this.configService.get('PORT', { infer: true });

  // TypeScript Error: this is invalid as the URL property is not defined in EnvironmentVariables
  const url = this.configService.get('URL', { infer: true });
}

```

With the `infer` property set to `true`, the `ConfigService#get` method will automatically infer the property type based on the interface, so for example, `typeof port === "number"` (if you're not using `strictNullChecks` flag from TypeScript) since `PORT` has a `number` type in the `EnvironmentVariables` interface.

Also, with the `infer` feature, you can infer the type of a nested custom configuration object's property, even when using dot notation, as follows:

content\_copy

```typescript

constructor(private configService: ConfigService<{ database: { host: string } }>) {
  const dbHost = this.configService.get('database.host', { infer: true })!;
  // typeof dbHost === "string"                                          |
  //                                                                     +--> non-null assertion operator
}

```

The second generic relies on the first one, acting as a type assertion to get rid of all `undefined` types that `ConfigService`'s methods can return when `strictNullChecks` is on. For instance:

content\_copy

```typescript

// ...
constructor(private configService: ConfigService<{ PORT: number }, true>) {
  //                                                               ^^^^
  const port = this.configService.get('PORT', { infer: true });
  //    ^^^ The type of port will be 'number' thus you don't need TS type assertions anymore
}

```

> **Hint** To make sure the `ConfigService#get` method retrieves values exclusively from custom configuration files and ignores `process.env` variables, set the `skipProcessEnv` option to `true` in the options object of the `ConfigModule`'s `forRoot()` method.

#### Configuration namespaces [\#](https://docs.nestjs.com/techniques/configuration\#configuration-namespaces)

The `ConfigModule` allows you to define and load multiple custom configuration files, as shown in [Custom configuration files](https://docs.nestjs.com/techniques/configuration#custom-configuration-files) above. You can manage complex configuration object hierarchies with nested configuration objects as shown in that section. Alternatively, you can return a "namespaced" configuration object with the `registerAs()` function as follows:

content\_copy config/database.config.ts

JS  TS

```typescript

export default registerAs('database', () => ({
  host: process.env.DATABASE_HOST,
  port: process.env.DATABASE_PORT || 5432
}));

```

As with custom configuration files, inside your `registerAs()` factory function, the `process.env` object will contain the fully resolved environment variable key/value pairs (with `.env` file and externally defined variables resolved and merged as described [above](https://docs.nestjs.com/techniques/configuration#getting-started)).

> **Hint** The `registerAs` function is exported from the `@nestjs/config` package.

Load a namespaced configuration with the `load` property of the `forRoot()` method's options object, in the same way you load a custom configuration file:

content\_copy

```typescript

import databaseConfig from './config/database.config';

@Module({
  imports: [\
    ConfigModule.forRoot({\
      load: [databaseConfig],\
    }),\
  ],
})
export class AppModule {}

```

Now, to get the `host` value from the `database` namespace, use dot notation. Use `'database'` as the prefix to the property name, corresponding to the name of the namespace (passed as the first argument to the `registerAs()` function):

content\_copy

```typescript

const dbHost = this.configService.get<string>('database.host');

```

A reasonable alternative is to inject the `database` namespace directly. This allows us to benefit from strong typing:

content\_copy

```typescript

constructor(
  @Inject(databaseConfig.KEY)
  private dbConfig: ConfigType<typeof databaseConfig>,
) {}

```

> **Hint** The `ConfigType` is exported from the `@nestjs/config` package.

#### Namespaced configurations in modules [\#](https://docs.nestjs.com/techniques/configuration\#namespaced-configurations-in-modules)

To use a namespaced configuration as a configuration object for another module in your application, you can utilize the `.asProvider()` method of the configuration object. This method converts your namespaced configuration into a provider, which can then be passed to the `forRootAsync()` (or any equivalent method) of the module you want to use.

Here's an example:

content\_copy

```typescript

import databaseConfig from './config/database.config';

@Module({
  imports: [\
    TypeOrmModule.forRootAsync(databaseConfig.asProvider()),\
  ],
})

```

To understand how the `.asProvider()` method functions, let's examine the return value:

content\_copy

```typescript

// Return value of the .asProvider() method
{
  imports: [ConfigModule.forFeature(databaseConfig)],
  useFactory: (configuration: ConfigType<typeof databaseConfig>) => configuration,
  inject: [databaseConfig.KEY]
}

```

This structure allows you to seamlessly integrate namespaced configurations into your modules, ensuring that your application remains organized and modular, without writing boilerplate, repetitive code.

#### Cache environment variables [\#](https://docs.nestjs.com/techniques/configuration\#cache-environment-variables)

As accessing `process.env` can be slow, you can set the `cache` property of the options object passed to `ConfigModule.forRoot()` to increase the performance of `ConfigService#get` method when it comes to variables stored in `process.env`.

content\_copy

```typescript

ConfigModule.forRoot({
  cache: true,
});

```

#### Partial registration [\#](https://docs.nestjs.com/techniques/configuration\#partial-registration)

Thus far, we've processed configuration files in our root module (e.g., `AppModule`), with the `forRoot()` method. Perhaps you have a more complex project structure, with feature-specific configuration files located in multiple different directories. Rather than load all these files in the root module, the `@nestjs/config` package provides a feature called **partial registration**, which references only the configuration files associated with each feature module. Use the `forFeature()` static method within a feature module to perform this partial registration, as follows:

content\_copy

```typescript

import databaseConfig from './config/database.config';

@Module({
  imports: [ConfigModule.forFeature(databaseConfig)],
})
export class DatabaseModule {}

```

> **Warning** In some circumstances, you may need to access properties loaded via partial registration using the `onModuleInit()` hook, rather than in a constructor. This is because the `forFeature()` method is run during module initialization, and the order of module initialization is indeterminate. If you access values loaded this way by another module, in a constructor, the module that the configuration depends upon may not yet have initialized. The `onModuleInit()` method runs only after all modules it depends upon have been initialized, so this technique is safe.

#### Schema validation [\#](https://docs.nestjs.com/techniques/configuration\#schema-validation)

It is standard practice to throw an exception during application startup if required environment variables haven't been provided or if they don't meet certain validation rules. The `@nestjs/config` package enables two different ways to do this:

- [Joi](https://github.com/sideway/joi) built-in validator. With Joi, you define an object schema and validate JavaScript objects against it.
- A custom `validate()` function which takes environment variables as an input.

To use Joi, we must install Joi package:

```bash

$ npm install --save joi

```

Now we can define a Joi validation schema and pass it via the `validationSchema` property of the `forRoot()` method's options object, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import * as Joi from 'joi';

@Module({
  imports: [\
    ConfigModule.forRoot({\
      validationSchema: Joi.object({\
        NODE_ENV: Joi.string()\
          .valid('development', 'production', 'test', 'provision')\
          .default('development'),\
        PORT: Joi.number().port().default(3000),\
      }),\
    }),\
  ],
})
export class AppModule {}

```

By default, all schema keys are considered optional. Here, we set default values for `NODE_ENV` and `PORT` which will be used if we don't provide these variables in the environment ( `.env` file or process environment). Alternatively, we can use the `required()` validation method to require that a value must be defined in the environment ( `.env` file or process environment). In this case, the validation step will throw an exception if we don't provide the variable in the environment. See [Joi validation methods](https://joi.dev/api/?v=17.3.0#example) for more on how to construct validation schemas.

By default, unknown environment variables (environment variables whose keys are not present in the schema) are allowed and do not trigger a validation exception. By default, all validation errors are reported. You can alter these behaviors by passing an options object via the `validationOptions` key of the `forRoot()` options object. This options object can contain any of the standard validation options properties provided by [Joi validation options](https://joi.dev/api/?v=17.3.0#anyvalidatevalue-options). For example, to reverse the two settings above, pass options like this:

content\_copy app.module.ts

JS  TS

```typescript

import * as Joi from 'joi';

@Module({
  imports: [\
    ConfigModule.forRoot({\
      validationSchema: Joi.object({\
        NODE_ENV: Joi.string()\
          .valid('development', 'production', 'test', 'provision')\
          .default('development'),\
        PORT: Joi.number().port().default(3000),\
      }),\
      validationOptions: {\
        allowUnknown: false,\
        abortEarly: true,\
      },\
    }),\
  ],
})
export class AppModule {}

```

The `@nestjs/config` package uses default settings of:

- `allowUnknown`: controls whether or not to allow unknown keys in the environment variables. Default is `true`
- `abortEarly`: if true, stops validation on the first error; if false, returns all errors. Defaults to `false`.

Note that once you decide to pass a `validationOptions` object, any settings you do not explicitly pass will default to `Joi` standard defaults (not the `@nestjs/config` defaults). For example, if you leave `allowUnknowns` unspecified in your custom `validationOptions` object, it will have the `Joi` default value of `false`. Hence, it is probably safest to specify **both** of these settings in your custom object.

> **Hint** To disable validation of predefined environment variables, set the `validatePredefined` attribute to `false` in the `forRoot()` method's options object. Predefined environment variables are process variables ( `process.env` variables) that were set before the module was imported. For example, if you start your application with `PORT=3000 node main.js`, then `PORT` is a predefined environment variable.

#### Custom validate function [\#](https://docs.nestjs.com/techniques/configuration\#custom-validate-function)

Alternatively, you can specify a **synchronous** `validate` function that takes an object containing the environment variables (from env file and process) and returns an object containing validated environment variables so that you can convert/mutate them if needed. If the function throws an error, it will prevent the application from bootstrapping.

In this example, we'll proceed with the `class-transformer` and `class-validator` packages. First, we have to define:

- a class with validation constraints,
- a validate function that makes use of the `plainToInstance` and `validateSync` functions.

content\_copy env.validation.ts

JS  TS

```typescript

import { plainToInstance } from 'class-transformer';
import { IsEnum, IsNumber, Max, Min, validateSync } from 'class-validator';

enum Environment {
  Development = "development",
  Production = "production",
  Test = "test",
  Provision = "provision",
}

class EnvironmentVariables {
  @IsEnum(Environment)
  NODE_ENV: Environment;

  @IsNumber()
  @Min(0)
  @Max(65535)
  PORT: number;
}

export function validate(config: Record<string, unknown>) {
  const validatedConfig = plainToInstance(
    EnvironmentVariables,
    config,
    { enableImplicitConversion: true },
  );
  const errors = validateSync(validatedConfig, { skipMissingProperties: false });

  if (errors.length > 0) {
    throw new Error(errors.toString());
  }
  return validatedConfig;
}

```

With this in place, use the `validate` function as a configuration option of the `ConfigModule`, as follows:

content\_copy app.module.ts

JS  TS

```typescript

import { validate } from './env.validation';

@Module({
  imports: [\
    ConfigModule.forRoot({\
      validate,\
    }),\
  ],
})
export class AppModule {}

```

#### Custom getter functions [\#](https://docs.nestjs.com/techniques/configuration\#custom-getter-functions)

`ConfigService` defines a generic `get()` method to retrieve a configuration value by key. We may also add `getter` functions to enable a little more natural coding style:

content\_copy

JS  TS

```typescript

@Injectable()
export class ApiConfigService {
  constructor(private configService: ConfigService) {}

  get isAuthEnabled(): boolean {
    return this.configService.get('AUTH_ENABLED') === 'true';
  }
}

```

```typescript

@Dependencies(ConfigService)
@Injectable()
export class ApiConfigService {
  constructor(configService) {
    this.configService = configService;
  }

  get isAuthEnabled() {
    return this.configService.get('AUTH_ENABLED') === 'true';
  }
}

```

Now we can use the getter function as follows:

content\_copy app.service.ts

JS  TS

```typescript

@Injectable()
export class AppService {
  constructor(apiConfigService: ApiConfigService) {
    if (apiConfigService.isAuthEnabled) {
      // Authentication is enabled
    }
  }
}

```

```typescript

@Dependencies(ApiConfigService)
@Injectable()
export class AppService {
  constructor(apiConfigService) {
    if (apiConfigService.isAuthEnabled) {
      // Authentication is enabled
    }
  }
}

```

#### Environment variables loaded hook [\#](https://docs.nestjs.com/techniques/configuration\#environment-variables-loaded-hook)

If a module configuration depends on the environment variables, and these variables are loaded from the `.env` file, you can use the `ConfigModule.envVariablesLoaded` hook to ensure that the file was loaded before interacting with the `process.env` object, see the following example:

content\_copy

```typescript

export async function getStorageModule() {
  await ConfigModule.envVariablesLoaded;
  return process.env.STORAGE === 'S3' ? S3StorageModule : DefaultStorageModule;
}

```

This construction guarantees that after the `ConfigModule.envVariablesLoaded` Promise resolves, all configuration variables are loaded up.

#### Conditional module configuration [\#](https://docs.nestjs.com/techniques/configuration\#conditional-module-configuration)

There may be times where you want to conditionally load in a module and specify the condition in an env variable. Fortunately, `@nestjs/config` provides a `ConditionalModule` that allows you to do just that.

content\_copy

```typescript

@Module({
  imports: [\
    ConfigModule.forRoot(),\
    ConditionalModule.registerWhen(FooModule, 'USE_FOO'),\
  ],
})
export class AppModule {}

```

The above module would only load in the `FooModule` if in the `.env` file there is not a `false` value for the env variable `USE_FOO`. You can also pass a custom condition yourself, a function receiving the `process.env` reference that should return a boolean for the `ConditionalModule` to handle:

content\_copy

```typescript

@Module({
  imports: [\
    ConfigModule.forRoot(),\
    ConditionalModule.registerWhen(\
      FooBarModule,\
      (env: NodeJS.ProcessEnv) => !!env['foo'] && !!env['bar'],\
    ),\
  ],
})
export class AppModule {}

```

It is important to be sure that when using the `ConditionalModule` you also have the `ConfigModule` loaded in the application, so that the `ConfigModule.envVariablesLoaded` hook can be properly referenced and utilized. If the hook is not flipped to true within 5 seconds, or a timeout in milliseconds, set by the user in the third options parameter of the `registerWhen` method, then the `ConditionalModule` will throw an error and Nest will abort starting the application.

#### Expandable variables [\#](https://docs.nestjs.com/techniques/configuration\#expandable-variables)

The `@nestjs/config` package supports environment variable expansion. With this technique, you can create nested environment variables, where one variable is referred to within the definition of another. For example:

```json

APP_URL=mywebsite.com
SUPPORT_EMAIL=support@${APP_URL}

```

With this construction, the variable `SUPPORT_EMAIL` resolves to `'support@mywebsite.com'`. Note the use of the `${...}` syntax to trigger resolving the value of the variable `APP_URL` inside the definition of `SUPPORT_EMAIL`.

> **Hint** For this feature, `@nestjs/config` package internally uses [dotenv-expand](https://github.com/motdotla/dotenv-expand).

Enable environment variable expansion using the `expandVariables` property in the options object passed to the `forRoot()` method of the `ConfigModule`, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

@Module({
  imports: [\
    ConfigModule.forRoot({\
      // ...\
      expandVariables: true,\
    }),\
  ],
})
export class AppModule {}

```

#### Using in the `main.ts` [\#](https://docs.nestjs.com/techniques/configuration\#using-in-the-maints)

While our config is stored in a service, it can still be used in the `main.ts` file. This way, you can use it to store variables such as the application port or the CORS host.

To access it, you must use the `app.get()` method, followed by the service reference:

content\_copy

```typescript

const configService = app.get(ConfigService);

```

You can then use it as usual, by calling the `get` method with the configuration key:

content\_copy

```typescript

const port = configService.get('PORT');

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Database Integration
- [Database](https://docs.nestjs.com/techniques/database#database)
- [TypeORM Integration](https://docs.nestjs.com/techniques/database#typeorm-integration)
- [Repository pattern](https://docs.nestjs.com/techniques/database#repository-pattern)
- [Relations](https://docs.nestjs.com/techniques/database#relations)
- [Auto-load entities](https://docs.nestjs.com/techniques/database#auto-load-entities)
- [Separating entity definition](https://docs.nestjs.com/techniques/database#separating-entity-definition)
- [TypeORM Transactions](https://docs.nestjs.com/techniques/database#typeorm-transactions)
- [Subscribers](https://docs.nestjs.com/techniques/database#subscribers)
- [Migrations](https://docs.nestjs.com/techniques/database#migrations)
- [Multiple databases](https://docs.nestjs.com/techniques/database#multiple-databases)
- [Testing](https://docs.nestjs.com/techniques/database#testing)
- [Async configuration](https://docs.nestjs.com/techniques/database#async-configuration)
- [Custom DataSource Factory](https://docs.nestjs.com/techniques/database#custom-datasource-factory)
- [Example](https://docs.nestjs.com/techniques/database#example)
- [Sequelize Integration](https://docs.nestjs.com/techniques/database#sequelize-integration)
- [Models](https://docs.nestjs.com/techniques/database#models)
- [Relations](https://docs.nestjs.com/techniques/database#relations-1)
- [Auto-load models](https://docs.nestjs.com/techniques/database#auto-load-models)
- [Sequelize Transactions](https://docs.nestjs.com/techniques/database#sequelize-transactions)
- [Migrations](https://docs.nestjs.com/techniques/database#migrations-1)
- [Multiple databases](https://docs.nestjs.com/techniques/database#multiple-databases-1)
- [Testing](https://docs.nestjs.com/techniques/database#testing-1)
- [Async configuration](https://docs.nestjs.com/techniques/database#async-configuration-1)
- [Example](https://docs.nestjs.com/techniques/database#example-1)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/sql.md "Suggest Edits")

### Database

Nest is database agnostic, allowing you to easily integrate with any SQL or NoSQL database. You have a number of options available to you, depending on your preferences. At the most general level, connecting Nest to a database is simply a matter of loading an appropriate Node.js driver for the database, just as you would with [Express](https://expressjs.com/en/guide/database-integration.html) or Fastify.

You can also directly use any general purpose Node.js database integration **library** or ORM, such as [MikroORM](https://mikro-orm.io/) (see [MikroORM recipe](https://docs.nestjs.com/recipes/mikroorm)), [Sequelize](https://sequelize.org/) (see [Sequelize integration](https://docs.nestjs.com/techniques/database#sequelize-integration)), [Knex.js](https://knexjs.org/) (see [Knex.js tutorial](https://dev.to/nestjs/build-a-nestjs-module-for-knex-js-or-other-resource-based-libraries-in-5-minutes-12an)), [TypeORM](https://github.com/typeorm/typeorm), and [Prisma](https://www.github.com/prisma/prisma) (see [Prisma recipe](https://docs.nestjs.com/recipes/prisma)), to operate at a higher level of abstraction.

For convenience, Nest provides tight integration with TypeORM and Sequelize out-of-the-box with the `@nestjs/typeorm` and `@nestjs/sequelize` packages respectively, which we'll cover in the current chapter, and Mongoose with `@nestjs/mongoose`, which is covered in [this chapter](https://docs.nestjs.com/techniques/mongodb). These integrations provide additional NestJS-specific features, such as model/repository injection, testability, and asynchronous configuration to make accessing your chosen database even easier.

### TypeORM Integration

For integrating with SQL and NoSQL databases, Nest provides the `@nestjs/typeorm` package. [TypeORM](https://github.com/typeorm/typeorm) is the most mature Object Relational Mapper (ORM) available for TypeScript. Since it's written in TypeScript, it integrates well with the Nest framework.

To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular [MySQL](https://www.mysql.com/) Relational DBMS, but TypeORM provides support for many relational databases, such as PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. The procedure we walk through in this chapter will be the same for any database supported by TypeORM. You'll simply need to install the associated client API libraries for your selected database.

```bash

$ npm install --save @nestjs/typeorm typeorm mysql2

```

Once the installation process is complete, we can import the `TypeOrmModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      type: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      entities: [],\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

> **Warning** Setting `synchronize: true` shouldn't be used in production - otherwise you can lose production data.

The `forRoot()` method supports all the configuration properties exposed by the `DataSource` constructor from the [TypeORM](https://typeorm.io/data-source-options#common-data-source-options) package. In addition, there are several extra configuration properties described below.

|     |     |
| --- | --- |
| `retryAttempts` | Number of attempts to connect to the database (default: `10`) |
| `retryDelay` | Delay between connection retry attempts (ms) (default: `3000`) |
| `autoLoadEntities` | If `true`, entities will be loaded automatically (default: `false`) |

> **Hint** Learn more about the data source options [here](https://typeorm.io/data-source-options).

Once this is done, the TypeORM `DataSource` and `EntityManager` objects will be available to inject across the entire project (without needing to import any modules), for example:

content\_copy app.module.ts

JS  TS

```typescript

import { DataSource } from 'typeorm';

@Module({
  imports: [TypeOrmModule.forRoot(), UsersModule],
})
export class AppModule {
  constructor(private dataSource: DataSource) {}
}

```

```typescript

import { DataSource } from 'typeorm';

@Dependencies(DataSource)
@Module({
  imports: [TypeOrmModule.forRoot(), UsersModule],
})
export class AppModule {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
}

```

#### Repository pattern [\#](https://docs.nestjs.com/techniques/database\#repository-pattern)

[TypeORM](https://github.com/typeorm/typeorm) supports the **repository design pattern**, so each entity has its own repository. These repositories can be obtained from the database data source.

To continue the example, we need at least one entity. Let's define the `User` entity.

content\_copy user.entity.ts

JS  TS

```typescript

import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;
}

```

> **Hint** Learn more about entities in the [TypeORM documentation](https://typeorm.io/docs/entity/entities/).

The `User` entity file sits in the `users` directory. This directory contains all files related to the `UsersModule`. You can decide where to keep your model files, however, we recommend creating them near their **domain**, in the corresponding module directory.

To begin using the `User` entity, we need to let TypeORM know about it by inserting it into the `entities` array in the module `forRoot()` method options (unless you use a static glob path):

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './users/user.entity';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      type: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      entities: [User],\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

Next, let's look at the `UsersModule`:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User } from './user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

This module uses the `forFeature()` method to define which repositories are registered in the current scope. With that in place, we can inject the `UsersRepository` into the `UsersService` using the `@InjectRepository()` decorator:

content\_copy users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  findAll(): Promise<User[]> {
    return this.usersRepository.find();
  }

  findOne(id: number): Promise<User | null> {
    return this.usersRepository.findOneBy({ id });
  }

  async remove(id: number): Promise<void> {
    await this.usersRepository.delete(id);
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { getRepositoryToken } from '@nestjs/typeorm';
import { User } from './user.entity';

@Injectable()
@Dependencies(getRepositoryToken(User))
export class UsersService {
  constructor(usersRepository) {
    this.usersRepository = usersRepository;
  }

  findAll() {
    return this.usersRepository.find();
  }

  findOne(id) {
    return this.usersRepository.findOneBy({ id });
  }

  async remove(id) {
    await this.usersRepository.delete(id);
  }
}

```

> **Notice** Don't forget to import the `UsersModule` into the root `AppModule`.

If you want to use the repository outside of the module which imports `TypeOrmModule.forFeature`, you'll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  exports: [TypeOrmModule]
})
export class UsersModule {}

```

Now if we import `UsersModule` in `UserHttpModule`, we can use `@InjectRepository(User)` in the providers of the latter module.

content\_copy users-http.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersModule } from './users.module';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserHttpModule {}

```

#### Relations [\#](https://docs.nestjs.com/techniques/database\#relations)

Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.

There are three types of relations:

|     |     |
| --- | --- |
| `One-to-one` | Every row in the primary table has one and only one associated row in the foreign table. Use the `@OneToOne()` decorator to define this type of relation. |
| `One-to-many / Many-to-one` | Every row in the primary table has one or more related rows in the foreign table. Use the `@OneToMany()` and `@ManyToOne()` decorators to define this type of relation. |
| `Many-to-many` | Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table. Use the `@ManyToMany()` decorator to define this type of relation. |

To define relations in entities, use the corresponding **decorators**. For example, to define that each `User` can have multiple photos, use the `@OneToMany()` decorator.

content\_copy user.entity.ts

JS  TS

```typescript

import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';
import { Photo } from '../photos/photo.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;

  @OneToMany(type => Photo, photo => photo.user)
  photos: Photo[];
}

```

> **Hint** To learn more about relations in TypeORM, visit the [TypeORM documentation](https://typeorm.io/#/relations).

#### Auto-load entities [\#](https://docs.nestjs.com/techniques/database\#auto-load-entities)

Manually adding entities to the `entities` array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the `autoLoadEntities` property of the configuration object (passed into the `forRoot()` method) to `true`, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      ...\
      autoLoadEntities: true,\
    }),\
  ],
})
export class AppModule {}

```

With that option specified, every entity registered through the `forFeature()` method will be automatically added to the `entities` array of the configuration object.

> **Warning** Note that entities that aren't registered through the `forFeature()` method, but are only referenced from the entity (via a relationship), won't be included by way of the `autoLoadEntities` setting.

#### Separating entity definition [\#](https://docs.nestjs.com/techniques/database\#separating-entity-definition)

You can define an entity and its columns right in the model, using decorators. But some people prefer to define entities and their columns inside separate files using the ["entity schemas"](https://typeorm.io/#/separating-entity-definition).

content\_copy

```typescript

import { EntitySchema } from 'typeorm';
import { User } from './user.entity';

export const UserSchema = new EntitySchema<User>({
  name: 'User',
  target: User,
  columns: {
    id: {
      type: Number,
      primary: true,
      generated: true,
    },
    firstName: {
      type: String,
    },
    lastName: {
      type: String,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  relations: {
    photos: {
      type: 'one-to-many',
      target: 'Photo', // the name of the PhotoSchema
    },
  },
});

```

> **Warning** If you provide the `target` option, the `name` option value has to be the same as the name of the target class.
> If you do not provide the `target` you can use any name.

Nest allows you to use an `EntitySchema` instance wherever an `Entity` is expected, for example:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserSchema } from './user.schema';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [TypeOrmModule.forFeature([UserSchema])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

#### TypeORM Transactions [\#](https://docs.nestjs.com/techniques/database\#typeorm-transactions)

A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database ( [learn more](https://en.wikipedia.org/wiki/Database_transaction)).

There are many different strategies to handle [TypeORM transactions](https://typeorm.io/docs/advanced-topics/transactions/). We recommend using the `QueryRunner` class because it gives full control over the transaction.

First, we need to inject the `DataSource` object into a class in the normal way:

content\_copy

```typescript

@Injectable()
export class UsersService {
  constructor(private dataSource: DataSource) {}
}

```

> **Hint** The `DataSource` class is imported from the `typeorm` package.

Now, we can use this object to create a transaction.

content\_copy

```typescript

async createMany(users: User[]) {
  const queryRunner = this.dataSource.createQueryRunner();

  await queryRunner.connect();
  await queryRunner.startTransaction();
  try {
    await queryRunner.manager.save(users[0]);
    await queryRunner.manager.save(users[1]);

    await queryRunner.commitTransaction();
  } catch (err) {
    // since we have errors lets rollback the changes we made
    await queryRunner.rollbackTransaction();
  } finally {
    // you need to release a queryRunner which was manually instantiated
    await queryRunner.release();
  }
}

```

> **Hint** Note that the `dataSource` is used only to create the `QueryRunner`. However, to test this class would require mocking the entire `DataSource` object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., `QueryRunnerFactory`) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

Alternatively, you can use the callback-style approach with the `transaction` method of the `DataSource` object ( [read more](https://typeorm.io/docs/advanced-topics/transactions/#creating-and-using-transactions)).

content\_copy

```typescript

async createMany(users: User[]) {
  await this.dataSource.transaction(async manager => {
    await manager.save(users[0]);
    await manager.save(users[1]);
  });
}

```

#### Subscribers [\#](https://docs.nestjs.com/techniques/database\#subscribers)

With TypeORM [subscribers](https://typeorm.io/docs/advanced-topics/listeners-and-subscribers#what-is-a-subscriber), you can listen to specific entity events.

content\_copy

```typescript

import {
  DataSource,
  EntitySubscriberInterface,
  EventSubscriber,
  InsertEvent,
} from 'typeorm';
import { User } from './user.entity';

@EventSubscriber()
export class UserSubscriber implements EntitySubscriberInterface<User> {
  constructor(dataSource: DataSource) {
    dataSource.subscribers.push(this);
  }

  listenTo() {
    return User;
  }

  beforeInsert(event: InsertEvent<User>) {
    console.log(`BEFORE USER INSERTED: `, event.entity);
  }
}

```

> **Warning** Event subscribers can not be [request-scoped](https://docs.nestjs.com/fundamentals/injection-scopes).

Now, add the `UserSubscriber` class to the `providers` array:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { UserSubscriber } from './user.subscriber';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService, UserSubscriber],
  controllers: [UsersController],
})
export class UsersModule {}

```

#### Migrations [\#](https://docs.nestjs.com/techniques/database\#migrations)

[Migrations](https://typeorm.io/#/migrations) provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated [CLI](https://typeorm.io/#/migrations/creating-a-new-migration).

Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the TypeORM CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the [TypeORM documentation](https://typeorm.io/#/migrations/creating-a-new-migration).

#### Multiple databases [\#](https://docs.nestjs.com/techniques/database\#multiple-databases)

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, data source naming becomes **mandatory**.

Suppose you have an `Album` entity stored in its own database.

content\_copy

```typescript

const defaultOptions = {
  type: 'postgres',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'db',
  synchronize: true,
};

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      ...defaultOptions,\
      host: 'user_db_host',\
      entities: [User],\
    }),\
    TypeOrmModule.forRoot({\
      ...defaultOptions,\
      name: 'albumsConnection',\
      host: 'album_db_host',\
      entities: [Album],\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** If you don't set the `name` for a data source, its name is set to `default`. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.

> **Notice** If you are using `TypeOrmModule.forRootAsync`, you have to **also** set the data source name outside `useFactory`. For example:
> content\_copy
>
> ```typescript
>
> TypeOrmModule.forRootAsync({
>   name: 'albumsConnection',
>   useFactory: ...,
>   inject: ...,
> }),
>
> ```
>
> See [this issue](https://github.com/nestjs/typeorm/issues/86) for more details.

At this point, you have `User` and `Album` entities registered with their own data source. With this setup, you have to tell the `TypeOrmModule.forFeature()` method and the `@InjectRepository()` decorator which data source should be used. If you do not pass any data source name, the `default` data source is used.

content\_copy

```typescript

@Module({
  imports: [\
    TypeOrmModule.forFeature([User]),\
    TypeOrmModule.forFeature([Album], 'albumsConnection'),\
  ],
})
export class AppModule {}

```

You can also inject the `DataSource` or `EntityManager` for a given data source:

content\_copy

```typescript

@Injectable()
export class AlbumsService {
  constructor(
    @InjectDataSource('albumsConnection')
    private dataSource: DataSource,
    @InjectEntityManager('albumsConnection')
    private entityManager: EntityManager,
  ) {}
}

```

It's also possible to inject any `DataSource` to the providers:

content\_copy

```typescript

@Module({
  providers: [\
    {\
      provide: AlbumsService,\
      useFactory: (albumsConnection: DataSource) => {\
        return new AlbumsService(albumsConnection);\
      },\
      inject: [getDataSourceToken('albumsConnection')],\
    },\
  ],
})
export class AlbumsModule {}

```

#### Testing [\#](https://docs.nestjs.com/techniques/database\#testing)

When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on repositories that are pulled from the data source (connection) instance. How do we handle that? The solution is to create mock repositories. In order to achieve that, we set up [custom providers](https://docs.nestjs.com/fundamentals/custom-providers). Each registered repository is automatically represented by an `<EntityName>Repository` token, where `EntityName` is the name of your entity class.

The `@nestjs/typeorm` package exposes the `getRepositoryToken()` function which returns a prepared token based on a given entity.

content\_copy

```typescript

@Module({
  providers: [\
    UsersService,\
    {\
      provide: getRepositoryToken(User),\
      useValue: mockRepository,\
    },\
  ],
})
export class UsersModule {}

```

Now a substitute `mockRepository` will be used as the `UsersRepository`. Whenever any class asks for `UsersRepository` using an `@InjectRepository()` decorator, Nest will use the registered `mockRepository` object.

#### Async configuration [\#](https://docs.nestjs.com/techniques/database\#async-configuration)

You may want to pass your repository module options asynchronously instead of statically. In this case, use the `forRootAsync()` method, which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  useFactory: () => ({
    type: 'mysql',
    host: 'localhost',
    port: 3306,
    username: 'root',
    password: 'root',
    database: 'test',
    entities: [],
    synchronize: true,
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    entities: [],
    synchronize: true,
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  useClass: TypeOrmConfigService,
});

```

The construction above will instantiate `TypeOrmConfigService` inside `TypeOrmModule` and use it to provide an options object by calling `createTypeOrmOptions()`. Note that this means that the `TypeOrmConfigService` has to implement the `TypeOrmOptionsFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  createTypeOrmOptions(): TypeOrmModuleOptions {
    return {
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [],
      synchronize: true,
    };
  }
}

```

In order to prevent the creation of `TypeOrmConfigService` inside `TypeOrmModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `TypeOrmModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

> **Hint** Make sure that the `name` property is defined at the same level as the `useFactory`, `useClass`, or `useValue` property. This will allow Nest to properly register the data source under the appropriate injection token.

#### Custom DataSource Factory [\#](https://docs.nestjs.com/techniques/database\#custom-datasource-factory)

In conjunction with async configuration using `useFactory`, `useClass`, or `useExisting`, you can optionally specify a `dataSourceFactory` function which will allow you to provide your own TypeORM data source rather than allowing `TypeOrmModule` to create the data source.

`dataSourceFactory` receives the TypeORM `DataSourceOptions` configured during async configuration using `useFactory`, `useClass`, or `useExisting` and returns a `Promise` that resolves a TypeORM `DataSource`.

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  // Use useFactory, useClass, or useExisting
  // to configure the DataSourceOptions.
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    entities: [],
    synchronize: true,
  }),
  // dataSource receives the configured DataSourceOptions
  // and returns a Promise<DataSource>.
  dataSourceFactory: async (options) => {
    const dataSource = await new DataSource(options).initialize();
    return dataSource;
  },
});

```

> **Hint** The `DataSource` class is imported from the `typeorm` package.

#### Example [\#](https://docs.nestjs.com/techniques/database\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/05-sql-typeorm).

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

### Sequelize Integration

An alternative to using TypeORM is to use the [Sequelize](https://sequelize.org/) ORM with the `@nestjs/sequelize` package. In addition, we leverage the [sequelize-typescript](https://github.com/RobinBuschmann/sequelize-typescript) package which provides a set of additional decorators to declaratively define entities.

To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular [MySQL](https://www.mysql.com/) Relational DBMS, but Sequelize provides support for many relational databases, such as PostgreSQL, MySQL, Microsoft SQL Server, SQLite, and MariaDB. The procedure we walk through in this chapter will be the same for any database supported by Sequelize. You'll simply need to install the associated client API libraries for your selected database.

```bash

$ npm install --save @nestjs/sequelize sequelize sequelize-typescript mysql2
$ npm install --save-dev @types/sequelize

```

Once the installation process is complete, we can import the `SequelizeModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      dialect: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      models: [],\
    }),\
  ],
})
export class AppModule {}

```

The `forRoot()` method supports all the configuration properties exposed by the Sequelize constructor ( [read more](https://sequelize.org/docs/v6/getting-started/#connecting-to-a-database)). In addition, there are several extra configuration properties described below.

|     |     |
| --- | --- |
| `retryAttempts` | Number of attempts to connect to the database (default: `10`) |
| `retryDelay` | Delay between connection retry attempts (ms) (default: `3000`) |
| `autoLoadModels` | If `true`, models will be loaded automatically (default: `false`) |
| `keepConnectionAlive` | If `true`, connection will not be closed on the application shutdown (default: `false`) |
| `synchronize` | If `true`, automatically loaded models will be synchronized (default: `true`) |

Once this is done, the `Sequelize` object will be available to inject across the entire project (without needing to import any modules), for example:

content\_copy app.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Sequelize } from 'sequelize-typescript';

@Injectable()
export class AppService {
  constructor(private sequelize: Sequelize) {}
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { Sequelize } from 'sequelize-typescript';

@Dependencies(Sequelize)
@Injectable()
export class AppService {
  constructor(sequelize) {
    this.sequelize = sequelize;
  }
}

```

#### Models [\#](https://docs.nestjs.com/techniques/database\#models)

Sequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database. To continue the example, we need at least one model. Let's define the `User` model.

content\_copy user.model.ts

JS  TS

```typescript

import { Column, Model, Table } from 'sequelize-typescript';

@Table
export class User extends Model {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;
}

```

> **Hint** Learn more about the available decorators [here](https://github.com/RobinBuschmann/sequelize-typescript#column).

The `User` model file sits in the `users` directory. This directory contains all files related to the `UsersModule`. You can decide where to keep your model files, however, we recommend creating them near their **domain**, in the corresponding module directory.

To begin using the `User` model, we need to let Sequelize know about it by inserting it into the `models` array in the module `forRoot()` method options:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './users/user.model';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      dialect: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      models: [User],\
    }),\
  ],
})
export class AppModule {}

```

Next, let's look at the `UsersModule`:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.model';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

This module uses the `forFeature()` method to define which models are registered in the current scope. With that in place, we can inject the `UserModel` into the `UsersService` using the `@InjectModel()` decorator:

content\_copy users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { User } from './user.model';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User)
    private userModel: typeof User,
  ) {}

  async findAll(): Promise<User[]> {
    return this.userModel.findAll();
  }

  findOne(id: string): Promise<User> {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await user.destroy();
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { getModelToken } from '@nestjs/sequelize';
import { User } from './user.model';

@Injectable()
@Dependencies(getModelToken(User))
export class UsersService {
  constructor(usersRepository) {
    this.usersRepository = usersRepository;
  }

  async findAll() {
    return this.userModel.findAll();
  }

  findOne(id) {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id) {
    const user = await this.findOne(id);
    await user.destroy();
  }
}

```

> **Notice** Don't forget to import the `UsersModule` into the root `AppModule`.

If you want to use the model outside of the module which imports `SequelizeModule.forFeature`, you'll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.entity';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  exports: [SequelizeModule]
})
export class UsersModule {}

```

Now if we import `UsersModule` in `UserHttpModule`, we can use `@InjectModel(User)` in the providers of the latter module.

content\_copy users-http.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersModule } from './users.module';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserHttpModule {}

```

#### Relations [\#](https://docs.nestjs.com/techniques/database\#relations-1)

Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.

There are three types of relations:

|     |     |
| --- | --- |
| `One-to-one` | Every row in the primary table has one and only one associated row in the foreign table |
| `One-to-many / Many-to-one` | Every row in the primary table has one or more related rows in the foreign table |
| `Many-to-many` | Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table |

To define relations in models, use the corresponding **decorators**. For example, to define that each `User` can have multiple photos, use the `@HasMany()` decorator.

content\_copy user.model.ts

JS  TS

```typescript

import { Column, Model, Table, HasMany } from 'sequelize-typescript';
import { Photo } from '../photos/photo.model';

@Table
export class User extends Model {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;

  @HasMany(() => Photo)
  photos: Photo[];
}

```

> **Hint** To learn more about associations in Sequelize, read [this](https://github.com/RobinBuschmann/sequelize-typescript#model-association) chapter.

#### Auto-load models [\#](https://docs.nestjs.com/techniques/database\#auto-load-models)

Manually adding models to the `models` array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both `autoLoadModels` and `synchronize` properties of the configuration object (passed into the `forRoot()` method) to `true`, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      ...\
      autoLoadModels: true,\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

With that option specified, every model registered through the `forFeature()` method will be automatically added to the `models` array of the configuration object.

> **Warning** Note that models that aren't registered through the `forFeature()` method, but are only referenced from the model (via an association), won't be included.

#### Sequelize Transactions [\#](https://docs.nestjs.com/techniques/database\#sequelize-transactions)

A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database ( [learn more](https://en.wikipedia.org/wiki/Database_transaction)).

There are many different strategies to handle [Sequelize transactions](https://sequelize.org/docs/v6/other-topics/transactions/). Below is a sample implementation of a managed transaction (auto-callback).

First, we need to inject the `Sequelize` object into a class in the normal way:

content\_copy

```typescript

@Injectable()
export class UsersService {
  constructor(private sequelize: Sequelize) {}
}

```

> **Hint** The `Sequelize` class is imported from the `sequelize-typescript` package.

Now, we can use this object to create a transaction.

content\_copy

```typescript

async createMany() {
  try {
    await this.sequelize.transaction(async t => {
      const transactionHost = { transaction: t };

      await this.userModel.create(
          { firstName: 'Abraham', lastName: 'Lincoln' },
          transactionHost,
      );
      await this.userModel.create(
          { firstName: 'John', lastName: 'Boothe' },
          transactionHost,
      );
    });
  } catch (err) {
    // Transaction has been rolled back
    // err is whatever rejected the promise chain returned to the transaction callback
  }
}

```

> **Hint** Note that the `Sequelize` instance is used only to start the transaction. However, to test this class would require mocking the entire `Sequelize` object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., `TransactionRunner`) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.

#### Migrations [\#](https://docs.nestjs.com/techniques/database\#migrations-1)

[Migrations](https://sequelize.org/docs/v6/other-topics/migrations/) provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, Sequelize provides a dedicated [CLI](https://sequelize.org/docs/v6/other-topics/migrations/#installing-the-cli).

Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the [Sequelize documentation](https://sequelize.org/docs/v6/other-topics/migrations/#installing-the-cli).

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Multiple databases [\#](https://docs.nestjs.com/techniques/database\#multiple-databases-1)

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes **mandatory**.

Suppose you have an `Album` entity stored in its own database.

content\_copy

```typescript

const defaultOptions = {
  dialect: 'postgres',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'db',
  synchronize: true,
};

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      ...defaultOptions,\
      host: 'user_db_host',\
      models: [User],\
    }),\
    SequelizeModule.forRoot({\
      ...defaultOptions,\
      name: 'albumsConnection',\
      host: 'album_db_host',\
      models: [Album],\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** If you don't set the `name` for a connection, its name is set to `default`. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.

At this point, you have `User` and `Album` models registered with their own connection. With this setup, you have to tell the `SequelizeModule.forFeature()` method and the `@InjectModel()` decorator which connection should be used. If you do not pass any connection name, the `default` connection is used.

content\_copy

```typescript

@Module({
  imports: [\
    SequelizeModule.forFeature([User]),\
    SequelizeModule.forFeature([Album], 'albumsConnection'),\
  ],
})
export class AppModule {}

```

You can also inject the `Sequelize` instance for a given connection:

content\_copy

```typescript

@Injectable()
export class AlbumsService {
  constructor(
    @InjectConnection('albumsConnection')
    private sequelize: Sequelize,
  ) {}
}

```

It's also possible to inject any `Sequelize` instance to the providers:

content\_copy

```typescript

@Module({
  providers: [\
    {\
      provide: AlbumsService,\
      useFactory: (albumsSequelize: Sequelize) => {\
        return new AlbumsService(albumsSequelize);\
      },\
      inject: [getDataSourceToken('albumsConnection')],\
    },\
  ],
})
export class AlbumsModule {}

```

#### Testing [\#](https://docs.nestjs.com/techniques/database\#testing-1)

When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up [custom providers](https://docs.nestjs.com/fundamentals/custom-providers). Each registered model is automatically represented by a `<ModelName>Model` token, where `ModelName` is the name of your model class.

The `@nestjs/sequelize` package exposes the `getModelToken()` function which returns a prepared token based on a given model.

content\_copy

```typescript

@Module({
  providers: [\
    UsersService,\
    {\
      provide: getModelToken(User),\
      useValue: mockModel,\
    },\
  ],
})
export class UsersModule {}

```

Now a substitute `mockModel` will be used as the `UserModel`. Whenever any class asks for `UserModel` using an `@InjectModel()` decorator, Nest will use the registered `mockModel` object.

#### Async configuration [\#](https://docs.nestjs.com/techniques/database\#async-configuration-1)

You may want to pass your `SequelizeModule` options asynchronously instead of statically. In this case, use the `forRootAsync()` method, which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

SequelizeModule.forRootAsync({
  useFactory: () => ({
    dialect: 'mysql',
    host: 'localhost',
    port: 3306,
    username: 'root',
    password: 'root',
    database: 'test',
    models: [],
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

SequelizeModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) => ({
    dialect: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    models: [],
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

SequelizeModule.forRootAsync({
  useClass: SequelizeConfigService,
});

```

The construction above will instantiate `SequelizeConfigService` inside `SequelizeModule` and use it to provide an options object by calling `createSequelizeOptions()`. Note that this means that the `SequelizeConfigService` has to implement the `SequelizeOptionsFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
class SequelizeConfigService implements SequelizeOptionsFactory {
  createSequelizeOptions(): SequelizeModuleOptions {
    return {
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      models: [],
    };
  }
}

```

In order to prevent the creation of `SequelizeConfigService` inside `SequelizeModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

SequelizeModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `SequelizeModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

#### Example [\#](https://docs.nestjs.com/techniques/database\#example-1)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/07-sequelize).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Performance Guide
- [Performance (Fastify)](https://docs.nestjs.com/techniques/performance#performance-fastify)
- [Installation](https://docs.nestjs.com/techniques/performance#installation)
- [Adapter](https://docs.nestjs.com/techniques/performance#adapter)
- [Platform specific packages](https://docs.nestjs.com/techniques/performance#platform-specific-packages)
- [Redirect response](https://docs.nestjs.com/techniques/performance#redirect-response)
- [Fastify options](https://docs.nestjs.com/techniques/performance#fastify-options)
- [Middleware](https://docs.nestjs.com/techniques/performance#middleware)
- [Route Config](https://docs.nestjs.com/techniques/performance#route-config)
- [Route Constraints](https://docs.nestjs.com/techniques/performance#route-constraints)
- [Example](https://docs.nestjs.com/techniques/performance#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/performance.md "Suggest Edits")

### Performance (Fastify)

By default, Nest makes use of the [Express](https://expressjs.com/) framework. As mentioned earlier, Nest also provides compatibility with other libraries such as, for example, [Fastify](https://github.com/fastify/fastify). Nest achieves this framework independence by implementing a framework adapter whose primary function is to proxy middleware and handlers to appropriate library-specific implementations.

> **Hint** Note that in order for a framework adapter to be implemented, the target library has to provide similar request/response pipeline processing as found in Express.

[Fastify](https://github.com/fastify/fastify) provides a good alternative framework for Nest because it solves design issues in a similar manner to Express. However, fastify is much **faster** than Express, achieving almost two times better benchmarks results. A fair question is why does Nest use Express as the default HTTP provider? The reason is that Express is widely-used, well-known, and has an enormous set of compatible middleware, which is available to Nest users out-of-the-box.

But since Nest provides framework-independence, you can easily migrate between them. Fastify can be a better choice when you place high value on very fast performance. To utilize Fastify, simply choose the built-in `FastifyAdapter` as shown in this chapter.

#### Installation [\#](https://docs.nestjs.com/techniques/performance\#installation)

First, we need to install the required package:

```bash

$ npm i --save @nestjs/platform-fastify

```

#### Adapter [\#](https://docs.nestjs.com/techniques/performance\#adapter)

Once the Fastify platform is installed, we can use the `FastifyAdapter`.

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter()
  );
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

By default, Fastify listens only on the `localhost 127.0.0.1` interface ( [read more](https://www.fastify.io/docs/latest/Guides/Getting-Started/#your-first-server)). If you want to accept connections on other hosts, you should specify `'0.0.0.0'` in the `listen()` call:

content\_copy

```typescript

async function bootstrap() {
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter(),
  );
  await app.listen(3000, '0.0.0.0');
}

```

#### Platform specific packages [\#](https://docs.nestjs.com/techniques/performance\#platform-specific-packages)

Keep in mind that when you use the `FastifyAdapter`, Nest uses Fastify as the **HTTP provider**. This means that each recipe that relies on Express may no longer work. You should, instead, use Fastify equivalent packages.

#### Redirect response [\#](https://docs.nestjs.com/techniques/performance\#redirect-response)

Fastify handles redirect responses slightly differently than Express. To do a proper redirect with Fastify, return both the status code and the URL, as follows:

content\_copy

```typescript

@Get()
index(@Res() res) {
  res.status(302).redirect('/login');
}

```

#### Fastify options [\#](https://docs.nestjs.com/techniques/performance\#fastify-options)

You can pass options into the Fastify constructor through the `FastifyAdapter` constructor. For example:

content\_copy

```typescript

new FastifyAdapter({ logger: true });

```

#### Middleware [\#](https://docs.nestjs.com/techniques/performance\#middleware)

Middleware functions retrieve the raw `req` and `res` objects instead of Fastify's wrappers. This is how the `middie` package works (that's used under the hood) and `fastify` \- check out this [page](https://www.fastify.io/docs/latest/Reference/Middleware/) for more information,

content\_copy logger.middleware.ts

JS  TS

```typescript

import { Injectable, NestMiddleware } from '@nestjs/common';
import { FastifyRequest, FastifyReply } from 'fastify';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: FastifyRequest['raw'], res: FastifyReply['raw'], next: () => void) {
    console.log('Request...');
    next();
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware {
  use(req, res, next) {
    console.log('Request...');
    next();
  }
}

```

#### Route Config [\#](https://docs.nestjs.com/techniques/performance\#route-config)

You can use the [route config](https://fastify.dev/docs/latest/Reference/Routes/#config) feature of Fastify with the `@RouteConfig()` decorator.

content\_copy

```typescript

@RouteConfig({ output: 'hello world' })
@Get()
index(@Req() req) {
  return req.routeConfig.output;
}

```

#### Route Constraints [\#](https://docs.nestjs.com/techniques/performance\#route-constraints)

As of v10.3.0, `@nestjs/platform-fastify` supports [route constraints](https://fastify.dev/docs/latest/Reference/Routes/#constraints) feature of Fastify with `@RouteConstraints` decorator.

content\_copy

```typescript

@RouteConstraints({ version: '1.2.x' })
newFeature() {
  return 'This works only for version >= 1.2.x';
}

```

> **Hint** `@RouteConfig()` and `@RouteConstraints` are imported from `@nestjs/platform-fastify`.

#### Example [\#](https://docs.nestjs.com/techniques/performance\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/10-fastify).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Authorization Guide
- [Authorization](https://docs.nestjs.com/security/authorization#authorization)
- [Basic RBAC implementation](https://docs.nestjs.com/security/authorization#basic-rbac-implementation)
- [Claims-based authorization](https://docs.nestjs.com/security/authorization#claims-based-authorization)
- [Integrating CASL](https://docs.nestjs.com/security/authorization#integrating-casl)
- [Advanced: Implementing a PoliciesGuard](https://docs.nestjs.com/security/authorization#advanced-implementing-a-policiesguard)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/authorization.md "Suggest Edits")

### Authorization

**Authorization** refers to the process that determines what a user is able to do. For example, an administrative user is allowed to create, edit, and delete posts. A non-administrative user is only authorized to read the posts.

Authorization is orthogonal and independent from authentication. However, authorization requires an authentication mechanism.

There are many different approaches and strategies to handle authorization. The approach taken for any project depends on its particular application requirements. This chapter presents a few approaches to authorization that can be adapted to a variety of different requirements.

#### Basic RBAC implementation [\#](https://docs.nestjs.com/security/authorization\#basic-rbac-implementation)

Role-based access control ( **RBAC**) is a policy-neutral access-control mechanism defined around roles and privileges. In this section, we'll demonstrate how to implement a very basic RBAC mechanism using Nest [guards](https://docs.nestjs.com/guards).

First, let's create a `Role` enum representing roles in the system:

content\_copy role.enum.ts

JS  TS

```typescript

export enum Role {
  User = 'user',
  Admin = 'admin',
}

```

> **Hint** In more sophisticated systems, you may store roles within a database, or pull them from the external authentication provider.

With this in place, we can create a `@Roles()` decorator. This decorator allows specifying what roles are required to access specific resources.

content\_copy roles.decorator.ts

JS  TS

```typescript

import { SetMetadata } from '@nestjs/common';
import { Role } from '../enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);

```

```typescript

import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles) => SetMetadata(ROLES_KEY, roles);

```

Now that we have a custom `@Roles()` decorator, we can use it to decorate any route handler.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@Roles(Role.Admin)
create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@Roles(Role.Admin)
@Bind(Body())
create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

Finally, we create a `RolesGuard` class which will compare the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's role(s) (custom metadata), we'll use the `Reflector` helper class, which is provided out of the box by the framework and exposed from the `@nestjs/core` package.

content\_copy roles.guard.ts

JS  TS

```typescript

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [\
      context.getHandler(),\
      context.getClass(),\
    ]);
    if (!requiredRoles) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
@Dependencies(Reflector)
export class RolesGuard {
  constructor(reflector) {
    this.reflector = reflector;
  }

  canActivate(context) {
    const requiredRoles = this.reflector.getAllAndOverride(ROLES_KEY, [\
      context.getHandler(),\
      context.getClass(),\
    ]);
    if (!requiredRoles) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles.includes(role));
  }
}

```

> **Hint** Refer to the [Reflection and metadata](https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata) section of the Execution context chapter for more details on utilizing `Reflector` in a context-sensitive way.

> **Notice** This example is named " **basic**" as we only check for the presence of roles on the route handler level. In real-world applications, you may have endpoints/handlers that involve several operations, in which each of them requires a specific set of permissions. In this case, you'll have to provide a mechanism to check roles somewhere within your business-logic, making it somewhat harder to maintain as there will be no centralized place that associates permissions with specific actions.

In this example, we assumed that `request.user` contains the user instance and allowed roles (under the `roles` property). In your app, you will probably make that association in your custom **authentication guard** \- see [authentication](https://docs.nestjs.com/security/authentication) chapter for more details.

To make sure this example works, your `User` class must look as follows:

content\_copy

```typescript

class User {
  // ...other properties
  roles: Role[];
}

```

Lastly, make sure to register the `RolesGuard`, for example, at the controller level, or globally:

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useClass: RolesGuard,\
  },\
],

```

When a user with insufficient privileges requests an endpoint, Nest automatically returns the following response:

content\_copy

```typescript

{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}

```

> **Hint** If you want to return a different error response, you should throw your own specific exception instead of returning a boolean value.

## Learn the right way!

- 19 chapters
- Authn & Authz
- Official certificate
- Deep-dive sessions

[Purchase the Authentication course](https://courses.nestjs.com/#authentication "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Claims-based authorization [\#](https://docs.nestjs.com/security/authorization\#claims-based-authorization)

When an identity is created it may be assigned one or more claims issued by a trusted party. A claim is a name-value pair that represents what the subject can do, not what the subject is.

To implement a Claims-based authorization in Nest, you can follow the same steps we have shown above in the [RBAC](https://docs.nestjs.com/security/authorization#basic-rbac-implementation) section with one significant difference: instead of checking for specific roles, you should compare **permissions**. Every user would have a set of permissions assigned. Likewise, each resource/endpoint would define what permissions are required (for example, through a dedicated `@RequirePermissions()` decorator) to access them.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@RequirePermissions(Permission.CREATE_CAT)
create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@RequirePermissions(Permission.CREATE_CAT)
@Bind(Body())
create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

> **Hint** In the example above, `Permission` (similar to `Role` we have shown in RBAC section) is a TypeScript enum that contains all the permissions available in your system.

#### Integrating CASL [\#](https://docs.nestjs.com/security/authorization\#integrating-casl)

[CASL](https://casl.js.org/) is an isomorphic authorization library which restricts what resources a given client is allowed to access. It's designed to be incrementally adoptable and can easily scale between a simple claim based and fully featured subject and attribute based authorization.

To start, first install the `@casl/ability` package:

```bash

$ npm i @casl/ability

```

> **Hint** In this example, we chose CASL, but you can use any other library like `accesscontrol` or `acl`, depending on your preferences and project needs.

Once the installation is complete, for the sake of illustrating the mechanics of CASL, we'll define two entity classes: `User` and `Article`.

content\_copy

```typescript

class User {
  id: number;
  isAdmin: boolean;
}

```

`User` class consists of two properties, `id`, which is a unique user identifier, and `isAdmin`, indicating whether a user has administrator privileges.

content\_copy

```typescript

class Article {
  id: number;
  isPublished: boolean;
  authorId: number;
}

```

`Article` class has three properties, respectively `id`, `isPublished`, and `authorId`. `id` is a unique article identifier, `isPublished` indicates whether an article was already published or not, and `authorId`, which is an ID of a user who wrote the article.

Now let's review and refine our requirements for this example:

- Admins can manage (create/read/update/delete) all entities
- Users have read-only access to everything
- Users can update their articles ( `article.authorId === userId`)
- Articles that are published already cannot be removed ( `article.isPublished === true`)

With this in mind, we can start off by creating an `Action` enum representing all possible actions that the users can perform with entities:

content\_copy

```typescript

export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}

```

> **Notice** `manage` is a special keyword in CASL which represents "any action".

To encapsulate CASL library, let's generate the `CaslModule` and `CaslAbilityFactory` now.

```bash

$ nest g module casl
$ nest g class casl/casl-ability.factory

```

With this in place, we can define the `createForUser()` method on the `CaslAbilityFactory`. This method will create the `Ability` object for a given user:

content\_copy

```typescript

type Subjects = InferSubjects<typeof Article | typeof User> | 'all';

export type AppAbility = MongoAbility<[Action, Subjects]>;

@Injectable()
export class CaslAbilityFactory {
  createForUser(user: User) {
    const { can, cannot, build } = new AbilityBuilder(createMongoAbility);

    if (user.isAdmin) {
      can(Action.Manage, 'all'); // read-write access to everything
    } else {
      can(Action.Read, 'all'); // read-only access to everything
    }

    can(Action.Update, Article, { authorId: user.id });
    cannot(Action.Delete, Article, { isPublished: true });

    return build({
      // Read https://casl.js.org/v6/en/guide/subject-type-detection#use-classes-as-subject-types for details
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    });
  }
}

```

> **Notice** `all` is a special keyword in CASL that represents "any subject".

> **Hint** Since CASL v6, `MongoAbility` serves as the default ability class, replacing the legacy `Ability` to better support condition-based permissions using MongoDB-like syntax. Despite the name, it is not tied to MongoDB — it works with any kind of data by simply comparing objects against conditions written in Mongo-like syntax.

> **Hint** `MongoAbility`, `AbilityBuilder`, `AbilityClass`, and `ExtractSubjectType` classes are exported from the `@casl/ability` package.

> **Hint** `detectSubjectType` option let CASL understand how to get subject type out of an object. For more information read [CASL documentation](https://casl.js.org/v6/en/guide/subject-type-detection#use-classes-as-subject-types) for details.

In the example above, we created the `MongoAbility` instance using the `AbilityBuilder` class. As you probably guessed, `can` and `cannot` accept the same arguments but have different meanings, `can` allows to do an action on the specified subject and `cannot` forbids. Both may accept up to 4 arguments. To learn more about these functions, visit the official [CASL documentation](https://casl.js.org/v6/en/guide/intro).

Lastly, make sure to add the `CaslAbilityFactory` to the `providers` and `exports` arrays in the `CaslModule` module definition:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { CaslAbilityFactory } from './casl-ability.factory';

@Module({
  providers: [CaslAbilityFactory],
  exports: [CaslAbilityFactory],
})
export class CaslModule {}

```

With this in place, we can inject the `CaslAbilityFactory` to any class using standard constructor injection as long as the `CaslModule` is imported in the host context:

content\_copy

```typescript

constructor(private caslAbilityFactory: CaslAbilityFactory) {}

```

Then use it in a class as follows.

content\_copy

```typescript

const ability = this.caslAbilityFactory.createForUser(user);
if (ability.can(Action.Read, 'all')) {
  // "user" has read access to everything
}

```

> **Hint** Learn more about the `MongoAbility` class in the official [CASL documentation](https://casl.js.org/v6/en/guide/intro).

For example, let's say we have a user who is not an admin. In this case, the user should be able to read articles, but creating new ones or removing the existing articles should be prohibited.

content\_copy

```typescript

const user = new User();
user.isAdmin = false;

const ability = this.caslAbilityFactory.createForUser(user);
ability.can(Action.Read, Article); // true
ability.can(Action.Delete, Article); // false
ability.can(Action.Create, Article); // false

```

> **Hint** Although both `MongoAbility` and `AbilityBuilder` classes provide `can` and `cannot` methods, they have different purposes and accept slightly different arguments.

Also, as we have specified in our requirements, the user should be able to update its articles:

content\_copy

```typescript

const user = new User();
user.id = 1;

const article = new Article();
article.authorId = user.id;

const ability = this.caslAbilityFactory.createForUser(user);
ability.can(Action.Update, article); // true

article.authorId = 2;
ability.can(Action.Update, article); // false

```

As you can see, `MongoAbility` instance allows us to check permissions in pretty readable way. Likewise, `AbilityBuilder` allows us to define permissions (and specify various conditions) in a similar fashion. To find more examples, visit the official documentation.

#### Advanced: Implementing a `PoliciesGuard` [\#](https://docs.nestjs.com/security/authorization\#advanced-implementing-a-policiesguard)

In this section, we'll demonstrate how to build a somewhat more sophisticated guard, which checks if a user meets specific **authorization policies** that can be configured on the method-level (you can extend it to respect policies configured on the class-level too). In this example, we are going to use the CASL package just for illustration purposes, but using this library is not required. Also, we will use the `CaslAbilityFactory` provider that we've created in the previous section.

First, let's flesh out the requirements. The goal is to provide a mechanism that allows specifying policy checks per route handler. We will support both objects and functions (for simpler checks and for those who prefer more functional-style code).

Let's start off by defining interfaces for policy handlers:

content\_copy

```typescript

import { AppAbility } from '../casl/casl-ability.factory';

interface IPolicyHandler {
  handle(ability: AppAbility): boolean;
}

type PolicyHandlerCallback = (ability: AppAbility) => boolean;

export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;

```

As mentioned above, we provided two possible ways of defining a policy handler, an object (instance of a class that implements the `IPolicyHandler` interface) and a function (which meets the `PolicyHandlerCallback` type).

With this in place, we can create a `@CheckPolicies()` decorator. This decorator allows specifying what policies have to be met to access specific resources.

content\_copy

```typescript

export const CHECK_POLICIES_KEY = 'check_policy';
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers);

```

Now let's create a `PoliciesGuard` that will extract and execute all the policy handlers bound to a route handler.

content\_copy

```typescript

@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || [];

    const { user } = context.switchToHttp().getRequest();
    const ability = this.caslAbilityFactory.createForUser(user);

    return policyHandlers.every((handler) =>
      this.execPolicyHandler(handler, ability),
    );
  }

  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {
    if (typeof handler === 'function') {
      return handler(ability);
    }
    return handler.handle(ability);
  }
}

```

> **Hint** In this example, we assumed that `request.user` contains the user instance. In your app, you will probably make that association in your custom **authentication guard** \- see [authentication](https://docs.nestjs.com/security/authentication) chapter for more details.

Let's break this example down. The `policyHandlers` is an array of handlers assigned to the method through the `@CheckPolicies()` decorator. Next, we use the `CaslAbilityFactory#create` method which constructs the `Ability` object, allowing us to verify whether a user has sufficient permissions to perform specific actions. We are passing this object to the policy handler which is either a function or an instance of a class that implements the `IPolicyHandler`, exposing the `handle()` method that returns a boolean. Lastly, we use the `Array#every` method to make sure that every handler returned `true` value.

Finally, to test this guard, bind it to any route handler, and register an inline policy handler (functional approach), as follows:

content\_copy

```typescript

@Get()
@UseGuards(PoliciesGuard)
@CheckPolicies((ability: AppAbility) => ability.can(Action.Read, Article))
findAll() {
  return this.articlesService.findAll();
}

```

Alternatively, we can define a class which implements the `IPolicyHandler` interface:

content\_copy

```typescript

export class ReadArticlePolicyHandler implements IPolicyHandler {
  handle(ability: AppAbility) {
    return ability.can(Action.Read, Article);
  }
}

```

And use it as follows:

content\_copy

```typescript

@Get()
@UseGuards(PoliciesGuard)
@CheckPolicies(new ReadArticlePolicyHandler())
findAll() {
  return this.articlesService.findAll();
}

```

> **Notice** Since we must instantiate the policy handler in-place using the `new` keyword, `ReadArticlePolicyHandler` class cannot use the Dependency Injection. This can be addressed with the `ModuleRef#get` method (read more [here](https://docs.nestjs.com/fundamentals/module-ref)). Basically, instead of registering functions and instances through the `@CheckPolicies()` decorator, you must allow passing a `Type<IPolicyHandler>`. Then, inside your guard, you could retrieve an instance using a type reference: `moduleRef.get(YOUR_HANDLER_TYPE)` or even dynamically instantiate it using the `ModuleRef#create` method.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Hybrid Applications in NestJS
- [Hybrid application](https://docs.nestjs.com/faq/hybrid-application#hybrid-application)
- [Sharing configuration](https://docs.nestjs.com/faq/hybrid-application#sharing-configuration)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/hybrid-application.md "Suggest Edits")

### Hybrid application

A hybrid application is one that listens for requests from two or more different sources. This can combine an HTTP server with a microservice listener or even just multiple different microservice listeners. The default `createMicroservice` method does not allow for multiple servers so in this case each microservice must be created and started manually. In order to do this, the `INestApplication` instance can be connected with `INestMicroservice` instances through the `connectMicroservice()` method.

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
const microservice = app.connectMicroservice<MicroserviceOptions>({
  transport: Transport.TCP,
});

await app.startAllMicroservices();
await app.listen(3001);

```

> **Hint** the `app.listen(port)` method starts an HTTP server on the specified address. If your application does not handle HTTP requests then you should use the `app.init()` method instead.

To connect multiple microservice instances, issue the call to `connectMicroservice()` for each microservice:

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
// microservice #1
const microserviceTcp = app.connectMicroservice<MicroserviceOptions>({
  transport: Transport.TCP,
  options: {
    port: 3001,
  },
});
// microservice #2
const microserviceRedis = app.connectMicroservice<MicroserviceOptions>({
  transport: Transport.REDIS,
  options: {
    host: 'localhost',
    port: 6379,
  },
});

await app.startAllMicroservices();
await app.listen(3001);

```

To bind `@MessagePattern()` to only one transport strategy (for example, MQTT) in a hybrid application with multiple microservices, we can pass the second argument of type `Transport` which is an enum with all the built-in transport strategies defined.

content\_copy

JS  TS

```typescript

@MessagePattern('time.us.*', Transport.NATS)
getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}
@MessagePattern({ cmd: 'time.us' }, Transport.TCP)
getTCPDate(@Payload() data: number[]) {
  return new Date().toLocaleTimeString(...);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('time.us.*', Transport.NATS)
getDate(data, context) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}
@Bind(Payload(), Ctx())
@MessagePattern({ cmd: 'time.us' }, Transport.TCP)
getTCPDate(data, context) {
  return new Date().toLocaleTimeString(...);
}

```

> **Hint** `@Payload()`, `@Ctx()`, `Transport` and `NatsContext` are imported from `@nestjs/microservices`.

#### Sharing configuration [\#](https://docs.nestjs.com/faq/hybrid-application\#sharing-configuration)

By default a hybrid application will not inherit global pipes, interceptors, guards and filters configured for the main (HTTP-based) application.
To inherit these configuration properties from the main application, set the `inheritAppConfig` property in the second argument (an optional options object) of the `connectMicroservice()` call, as follow:

content\_copy

```typescript

const microservice = app.connectMicroservice<MicroserviceOptions>(
  {
    transport: Transport.TCP,
  },
  { inheritAppConfig: true },
);

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS CI/CD Integration
- [CI/CD integration](https://docs.nestjs.com/devtools/ci-cd-integration#cicd-integration)
- [Publishing graphs](https://docs.nestjs.com/devtools/ci-cd-integration#publishing-graphs)
- [Reports](https://docs.nestjs.com/devtools/ci-cd-integration#reports)
- [Build preview](https://docs.nestjs.com/devtools/ci-cd-integration#build-preview)
- [Integrations: GitHub Actions](https://docs.nestjs.com/devtools/ci-cd-integration#integrations-github-actions)
- [Integrations: Gitlab Pipelines](https://docs.nestjs.com/devtools/ci-cd-integration#integrations-gitlab-pipelines)
- [Other CI/CD tools](https://docs.nestjs.com/devtools/ci-cd-integration#other-cicd-tools)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/devtools/ci-cd.md "Suggest Edits")

### CI/CD integration

> **Hint** This chapter covers the Nest Devtools integration with the Nest framework. If you are looking for the Devtools application, please visit the [Devtools](https://devtools.nestjs.com/) website.

CI/CD integration is available for users with the **[Enterprise](https://docs.nestjs.com/settings)** plan.

You can watch this video to learn why & how CI/CD integration can help you:

NestJS Devtools: CI/CD Integration Use Cases with Kamil Mysliwiec - YouTube

[Photo image of NestJS](https://www.youtube.com/channel/UCNuGHuz7gG91Q01nFWZPFvg?embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

NestJS

2.16K subscribers

[NestJS Devtools: CI/CD Integration Use Cases with Kamil Mysliwiec](https://www.youtube.com/watch?v=r5RXcBrnEQ8)

NestJS

Search

Watch later

Share

Copy link

Info

Shopping

Tap to unmute

If playback doesn't begin shortly, try restarting your device.

More videos

## More videos

You're signed out

Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer.

CancelConfirm

Share

Include playlist

An error occurred while retrieving sharing information. Please try again later.

[Watch on](https://www.youtube.com/watch?v=r5RXcBrnEQ8&embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

0:00

0:00 / 1:48
•Live

•

#### Publishing graphs [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#publishing-graphs)

Let's first configure the application bootstrap file ( `main.ts`) to use the `GraphPublisher` class (exported from the `@nestjs/devtools-integration` \- see previous chapter for more details), as follows:

content\_copy

```typescript

async function bootstrap() {
  const shouldPublishGraph = process.env.PUBLISH_GRAPH === "true";

  const app = await NestFactory.create(AppModule, {
    snapshot: true,
    preview: shouldPublishGraph,
  });

  if (shouldPublishGraph) {
    await app.init();

    const publishOptions = { ... } // NOTE: this options object will vary depending on the CI/CD provider you're using
    const graphPublisher = new GraphPublisher(app);
    await graphPublisher.publish(publishOptions);

    await app.close();
  } else {
    await app.listen(process.env.PORT ?? 3000);
  }
}

```

As we can see, we're using the `GraphPublisher` here to publish our serialized graph to the centralized registry. The `PUBLISH_GRAPH` is a custom environment variable that will let us control whether the graph should be published (CI/CD workflow), or not (regular application bootstrap). Also, we set the `preview` attribute here to `true`. With this flag enabled, our application will bootstrap in the preview mode - which basically means that constructors (and lifecycle hooks) of all controllers, enhancers, and providers in our application will not be executed. Note - this isn't **required**, but makes things simpler for us since in this case we won't really have to connect to the database etc. when running our application in the CI/CD pipeline.

The `publishOptions` object will vary depending on the CI/CD provider you're using. We will provide you with instructions for the most popular CI/CD providers below, in later sections.

Once the graph is successfully published, you'll see the following output in your workflow view:

![](https://docs.nestjs.com/assets/devtools/graph-published-terminal.png)

Every time our graph is published, we should see a new entry in the project's corresponding page:

![](https://docs.nestjs.com/assets/devtools/project.png)

#### Reports [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#reports)

Devtools generate a report for every build **IF** there's a corresponding snapshot already stored in the centralized registry. So for example, if you create a PR against the `master` branch for which the graph was already published - then the application will be able to detect differences and generate a report. Otherwise, the report will not be generated.

To see reports, navigate to the project's corresponding page (see organizations).

![](https://docs.nestjs.com/assets/devtools/report.png)

This is particularly helpful in identifying changes that may have gone unnoticed during code reviews. For instance, let's say someone has changed the scope of a **deeply nested provider**. This change might not be immediately obvious to the reviewer, but with Devtools, we can easily spot such changes and make sure that they're intentional. Or if we remove a guard from a specific endpoint, it will show up as affected in the report. Now if we didn't have integration or e2e tests for that route, we might not notice that it's no longer protected, and by the time we do, it could be too late.

Similarly, if we're working on a **large codebase** and we modify a module to be global, we'll see how many edges were added to the graph, and this - in most cases - is a sign that we're doing something wrong.

#### Build preview [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#build-preview)

For every published graph we can go back in time and preview how it looked before by clicking at the **Preview** button. Furthermore, if the report was generated, we should see the differences highlighted on our graph:

- green nodes represent added elements
- light white nodes represent updated elements
- red nodes represent deleted elements

See screenshot below:

![](https://docs.nestjs.com/assets/devtools/nodes-selection.png)

The ability to go back in time lets you investigate and troubleshoot the issue by comparing the current graph with the previous one. Depending on how you set things up, every pull request (or even every commit) will have a corresponding snapshot in the registry, so you can easily go back in time and see what changed. Think of Devtools as a Git but with an understanding of how Nest constructs your application graph, and with the ability to **visualize** it.

#### Integrations: GitHub Actions [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#integrations-github-actions)

First let's start from creating a new GitHub workflow in the `.github/workflows` directory in our project and call it, for example, `publish-graph.yml`. Inside this file, let's use the following definition:

```yaml

name: Devtools

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - '*'

jobs:
  publish:
    if: github.actor!= 'dependabot[bot]'
    name: Publish graph
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Setup Environment (PR)
        if: ${{ github.event_name == 'pull_request' }}
        shell: bash
        run: |
          echo "COMMIT_SHA=${{ github.event.pull_request.head.sha }}" >>\${GITHUB_ENV}
      - name: Setup Environment (Push)
        if: ${{ github.event_name == 'push' }}
        shell: bash
        run: |
          echo "COMMIT_SHA=\${GITHUB_SHA}" >> \${GITHUB_ENV}
      - name: Publish
        run: PUBLISH_GRAPH=true npm run start
        env:
          DEVTOOLS_API_KEY: CHANGE_THIS_TO_YOUR_API_KEY
          REPOSITORY_NAME: ${{ github.event.repository.name }}
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
          TARGET_SHA: ${{ github.event.pull_request.base.sha }}

```

Ideally, `DEVTOOLS_API_KEY` environment variable should be retrieved from GitHub Secrets, read more [here](https://docs.github.com/en/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository) .

This workflow will run per each pull request that's targeting the `master` branch OR in case there's a direct commit to the `master` branch. Feel free to align this configuration to whatever your project needs. What's essential here is that we provide necessary environment variables for our `GraphPublisher` class (to run).

However, there's one variable that needs to be updated before we can start using this workflow - `DEVTOOLS_API_KEY`. We can generate an API key dedicated for our project on this [page](https://devtools.nestjs.com/settings/manage-api-keys).

Lastly, let's navigate to the `main.ts` file again and update the `publishOptions` object we previously left empty.

content\_copy

```typescript

const publishOptions = {
  apiKey: process.env.DEVTOOLS_API_KEY,
  repository: process.env.REPOSITORY_NAME,
  owner: process.env.GITHUB_REPOSITORY_OWNER,
  sha: process.env.COMMIT_SHA,
  target: process.env.TARGET_SHA,
  trigger: process.env.GITHUB_BASE_REF ? 'pull' : 'push',
  branch: process.env.BRANCH_NAME,
};

```

For the best developer experience, make sure to integrate the **GitHub application** for your project by clicking on the "Integrate GitHub app" button (see screenshot below). Note - this isn't required.

![](https://docs.nestjs.com/assets/devtools/integrate-github-app.png)

With this integration, you'll be able to see the status of the preview/report generation process right in your pull request:

![](https://docs.nestjs.com/assets/devtools/actions-preview.png)

#### Integrations: Gitlab Pipelines [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#integrations-gitlab-pipelines)

First let's start from creating a new Gitlab CI configuration file in the root directory of our project and call it, for example, `.gitlab-ci.yml`. Inside this file, let's use the following definition:

content\_copy

```typescript

const publishOptions = {
  apiKey: process.env.DEVTOOLS_API_KEY,
  repository: process.env.REPOSITORY_NAME,
  owner: process.env.GITHUB_REPOSITORY_OWNER,
  sha: process.env.COMMIT_SHA,
  target: process.env.TARGET_SHA,
  trigger: process.env.GITHUB_BASE_REF ? 'pull' : 'push',
  branch: process.env.BRANCH_NAME,
};

```

> **Hint** Ideally, `DEVTOOLS_API_KEY` environment variable should be retrieved from secrets.

This workflow will run per each pull request that's targeting the `master` branch OR in case there's a direct commit to the `master` branch. Feel free to align this configuration to whatever your project needs. What's essential here is that we provide necessary environment variables for our `GraphPublisher` class (to run).

However, there's one variable (in this workflow definition) that needs to be updated before we can start using this workflow - `DEVTOOLS_API_KEY`. We can generate an API key dedicated for our project on this **page** .

Lastly, let's navigate to the `main.ts` file again and update the `publishOptions` object we previously left empty.

```yaml

image: node:16

stages:
  - build

cache:
  key:
    files:
      - package-lock.json
  paths:
    - node_modules/

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "master" && $CI_PIPELINE_SOURCE == "push"
      when: always
    - when: never

install_dependencies:
  stage: build
  script:
    - npm ci

publish_graph:
  stage: build
  needs:
    - install_dependencies
  script: npm run start
  variables:
    PUBLISH_GRAPH: 'true'
    DEVTOOLS_API_KEY: 'CHANGE_THIS_TO_YOUR_API_KEY'

```

#### Other CI/CD tools [\#](https://docs.nestjs.com/devtools/ci-cd-integration\#other-cicd-tools)

Nest Devtools CI/CD integration can be used with any CI/CD tool of your choice (e.g., [Bitbucket Pipelines](https://bitbucket.org/product/features/pipelines) , [CircleCI](https://circleci.com/), etc) so don't feel limited to providers we described here.

Look at the following `publishOptions` object configuration to understand what information is required to publish the graph for a given commit/build/PR.

content\_copy

```typescript

const publishOptions = {
  apiKey: process.env.DEVTOOLS_API_KEY,
  repository: process.env.CI_PROJECT_NAME,
  owner: process.env.CI_PROJECT_ROOT_NAMESPACE,
  sha: process.env.CI_COMMIT_SHA,
  target: process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA,
  trigger: process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA ? 'pull' : 'push',
  branch: process.env.CI_COMMIT_BRANCH ?? process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME,
};

```

Most of this information is provided through CI/CD built-in environment variables (see [CircleCI built-in environment list](https://circleci.com/docs/variables/#built-in-environment-variables) and [Bitbucket variables](https://support.atlassian.com/bitbucket-cloud/docs/variables-and-secrets/) ).

When it comes to the pipeline configuration for publishing graphs, we recommend using the following triggers:

- `push` event - only if the current branch represents a deployment environment, for example `master`, `main`, `staging`, `production`, etc.
- `pull request` event - always, or when the **target branch** represents a deployment environment (see above)

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Execution Context
- [Execution context](https://docs.nestjs.com/fundamentals/execution-context#execution-context)
- [ArgumentsHost class](https://docs.nestjs.com/fundamentals/execution-context#argumentshost-class)
- [Current application context](https://docs.nestjs.com/fundamentals/execution-context#current-application-context)
- [Host handler arguments](https://docs.nestjs.com/fundamentals/execution-context#host-handler-arguments)
- [ExecutionContext class](https://docs.nestjs.com/fundamentals/execution-context#executioncontext-class)
- [Reflection and metadata](https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata)
- [Low-level approach](https://docs.nestjs.com/fundamentals/execution-context#low-level-approach)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/execution-context.md "Suggest Edits")

### Execution context

Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic [guards](https://docs.nestjs.com/guards), [filters](https://docs.nestjs.com/exception-filters), and [interceptors](https://docs.nestjs.com/interceptors) that can work across a broad set of controllers, methods, and execution contexts.

We cover two such classes in this chapter: `ArgumentsHost` and `ExecutionContext`.

#### ArgumentsHost class [\#](https://docs.nestjs.com/fundamentals/execution-context\#argumentshost-class)

The `ArgumentsHost` class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of `ArgumentsHost`, typically referenced as a `host` parameter, in places where you may want to access it. For example, the `catch()` method of an [exception filter](https://docs.nestjs.com/exception-filters#arguments-host) is called with an `ArgumentsHost` instance.

`ArgumentsHost` simply acts as an abstraction over a handler's arguments. For example, for HTTP server applications (when `@nestjs/platform-express` is being used), the `host` object encapsulates Express's `[request, response, next]` array, where `request` is the request object, `response` is the response object, and `next` is a function that controls the application's request-response cycle. On the other hand, for [GraphQL](https://docs.nestjs.com/graphql/quick-start) applications, the `host` object contains the `[root, args, context, info]` array.

#### Current application context [\#](https://docs.nestjs.com/fundamentals/execution-context\#current-application-context)

When building generic [guards](https://docs.nestjs.com/guards), [filters](https://docs.nestjs.com/exception-filters), and [interceptors](https://docs.nestjs.com/interceptors) which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the `getType()` method of `ArgumentsHost`:

content\_copy

```typescript

if (host.getType() === 'http') {
  // do something that is only important in the context of regular HTTP requests (REST)
} else if (host.getType() === 'rpc') {
  // do something that is only important in the context of Microservice requests
} else if (host.getType<GqlContextType>() === 'graphql') {
  // do something that is only important in the context of GraphQL requests
}

```

> **Hint** The `GqlContextType` is imported from the `@nestjs/graphql` package.

With the application type available, we can write more generic components, as shown below.

#### Host handler arguments [\#](https://docs.nestjs.com/fundamentals/execution-context\#host-handler-arguments)

To retrieve the array of arguments being passed to the handler, one approach is to use the host object's `getArgs()` method.

content\_copy

```typescript

const [req, res, next] = host.getArgs();

```

You can pluck a particular argument by index using the `getArgByIndex()` method:

content\_copy

```typescript

const request = host.getArgByIndex(0);
const response = host.getArgByIndex(1);

```

In these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the `host` object's utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below.

content\_copy

```typescript

/**
 * Switch context to RPC.
 */
switchToRpc(): RpcArgumentsHost;
/**
 * Switch context to HTTP.
 */
switchToHttp(): HttpArgumentsHost;
/**
 * Switch context to WebSockets.
 */
switchToWs(): WsArgumentsHost;

```

Let's rewrite the previous example using the `switchToHttp()` method. The `host.switchToHttp()` helper call returns an `HttpArgumentsHost` object that is appropriate for the HTTP application context. The `HttpArgumentsHost` object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:

content\_copy

```typescript

const ctx = host.switchToHttp();
const request = ctx.getRequest<Request>();
const response = ctx.getResponse<Response>();

```

Similarly `WsArgumentsHost` and `RpcArgumentsHost` have methods to return appropriate objects in the microservices and WebSockets contexts. Here are the methods for `WsArgumentsHost`:

content\_copy

```typescript

export interface WsArgumentsHost {
  /**
   * Returns the data object.
   */
  getData<T>(): T;
  /**
   * Returns the client object.
   */
  getClient<T>(): T;
}

```

Following are the methods for `RpcArgumentsHost`:

content\_copy

```typescript

export interface RpcArgumentsHost {
  /**
   * Returns the data object.
   */
  getData<T>(): T;

  /**
   * Returns the context object.
   */
  getContext<T>(): T;
}

```

#### ExecutionContext class [\#](https://docs.nestjs.com/fundamentals/execution-context\#executioncontext-class)

`ExecutionContext` extends `ArgumentsHost`, providing additional details about the current execution process. Like `ArgumentsHost`, Nest provides an instance of `ExecutionContext` in places you may need it, such as in the `canActivate()` method of a [guard](https://docs.nestjs.com/guards#execution-context) and the `intercept()` method of an [interceptor](https://docs.nestjs.com/interceptors#execution-context). It provides the following methods:

content\_copy

```typescript

export interface ExecutionContext extends ArgumentsHost {
  /**
   * Returns the type of the controller class which the current handler belongs to.
   */
  getClass<T>(): Type<T>;
  /**
   * Returns a reference to the handler (method) that will be invoked next in the
   * request pipeline.
   */
  getHandler(): Function;
}

```

The `getHandler()` method returns a reference to the handler about to be invoked. The `getClass()` method returns the type of the `Controller` class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a `POST` request, bound to the `create()` method on the `CatsController`, `getHandler()` returns a reference to the `create()` method and `getClass()` returns the `CatsController` **class** (not instance).

content\_copy

```typescript

const methodKey = ctx.getHandler().name; // "create"
const className = ctx.getClass().name; // "CatsController"

```

The ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through either decorators created via `Reflector#createDecorator` or the built-in `@SetMetadata()` decorator from within guards or interceptors. We cover this use case below.

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Reflection and metadata [\#](https://docs.nestjs.com/fundamentals/execution-context\#reflection-and-metadata)

Nest provides the ability to attach **custom metadata** to route handlers through decorators created via `Reflector#createDecorator` method, and the built-in `@SetMetadata()` decorator. In this section, let's compare the two approaches and see how to access the metadata from within a guard or interceptor.

To create strongly-typed decorators using `Reflector#createDecorator`, we need to specify the type argument. For example, let's create a `Roles` decorator that takes an array of strings as an argument.

content\_copy roles.decorator.ts

JS  TS

```ts

import { Reflector } from '@nestjs/core';

export const Roles = Reflector.createDecorator<string[]>();

```

The `Roles` decorator here is a function that takes a single argument of type `string[]`.

Now, to use this decorator, we simply annotate the handler with it:

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@Roles(['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@Roles(['admin'])
@Bind(Body())
async create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

Here we've attached the `Roles` decorator metadata to the `create()` method, indicating that only users with the `admin` role should be allowed to access this route.

To access the route's role(s) (custom metadata), we'll use the `Reflector` helper class again. `Reflector` can be injected into a class in the normal way:

content\_copy roles.guard.ts

JS  TS

```typescript

@Injectable()
export class RolesGuard {
  constructor(private reflector: Reflector) {}
}

```

```typescript

@Injectable()
@Dependencies(Reflector)
export class CatsService {
  constructor(reflector) {
    this.reflector = reflector;
  }
}

```

> **Hint** The `Reflector` class is imported from the `@nestjs/core` package.

Now, to read the handler metadata, use the `get()` method:

content\_copy

```typescript

const roles = this.reflector.get(Roles, context.getHandler());

```

The `Reflector#get` method allows us to easily access the metadata by passing in two arguments: a decorator reference and a **context** (decorator target) to retrieve the metadata from. In this example, the specified **decorator** is `Roles` (refer back to the `roles.decorator.ts` file above). The context is provided by the call to `context.getHandler()`, which results in extracting the metadata for the currently processed route handler. Remember, `getHandler()` gives us a **reference** to the route handler function.

Alternatively, we may organize our controller by applying metadata at the controller level, applying to all routes in the controller class.

content\_copy cats.controller.ts

JS  TS

```typescript

@Roles(['admin'])
@Controller('cats')
export class CatsController {}

```

```typescript

@Roles(['admin'])
@Controller('cats')
export class CatsController {}

```

In this case, to extract controller metadata, we pass `context.getClass()` as the second argument (to provide the controller class as the context for metadata extraction) instead of `context.getHandler()`:

content\_copy roles.guard.ts

JS  TS

```typescript

const roles = this.reflector.get(Roles, context.getClass());

```

Given the ability to provide metadata at multiple levels, you may need to extract and merge metadata from several contexts. The `Reflector` class provides two utility methods used to help with this. These methods extract **both** controller and method metadata at once, and combine them in different ways.

Consider the following scenario, where you've supplied `Roles` metadata at both levels.

content\_copy cats.controller.ts

JS  TS

```typescript

@Roles(['user'])
@Controller('cats')
export class CatsController {
  @Post()
  @Roles(['admin'])
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }
}

```

```typescript

@Roles(['user'])
@Controller('cats')
export class CatsController {}
  @Post()
  @Roles(['admin'])
  @Bind(Body())
  async create(createCatDto) {
    this.catsService.create(createCatDto);
  }
}

```

If your intent is to specify `'user'` as the default role, and override it selectively for certain methods, you would probably use the `getAllAndOverride()` method.

content\_copy

```typescript

const roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()]);

```

A guard with this code, running in the context of the `create()` method, with the above metadata, would result in `roles` containing `['admin']`.

To get metadata for both and merge it (this method merges both arrays and objects), use the `getAllAndMerge()` method:

content\_copy

```typescript

const roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()]);

```

This would result in `roles` containing `['user', 'admin']`.

For both of these merge methods, you pass the metadata key as the first argument, and an array of metadata target contexts (i.e., calls to the `getHandler()` and/or `getClass()` methods) as the second argument.

#### Low-level approach [\#](https://docs.nestjs.com/fundamentals/execution-context\#low-level-approach)

As mentioned earlier, instead of using `Reflector#createDecorator`, you can also use the built-in `@SetMetadata()` decorator to attach metadata to a handler.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@SetMetadata('roles', ['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@SetMetadata('roles', ['admin'])
@Bind(Body())
async create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

> **Hint** The `@SetMetadata()` decorator is imported from the `@nestjs/common` package.

With the construction above, we attached the `roles` metadata ( `roles` is a metadata key and `['admin']` is the associated value) to the `create()` method. While this works, it's not good practice to use `@SetMetadata()` directly in your routes. Instead, you can create your own decorators, as shown below:

content\_copy roles.decorator.ts

JS  TS

```typescript

import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

```

```typescript

import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles) => SetMetadata('roles', roles);

```

This approach is much cleaner and more readable, and somewhat resembles the `Reflector#createDecorator` approach. The difference is that with `@SetMetadata` you have more control over the metadata key and value, and also can create decorators that take more than one argument.

Now that we have a custom `@Roles()` decorator, we can use it to decorate the `create()` method.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@Roles('admin')
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@Roles('admin')
@Bind(Body())
async create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

To access the route's role(s) (custom metadata), we'll use the `Reflector` helper class again:

content\_copy roles.guard.ts

JS  TS

```typescript

@Injectable()
export class RolesGuard {
  constructor(private reflector: Reflector) {}
}

```

```typescript

@Injectable()
@Dependencies(Reflector)
export class CatsService {
  constructor(reflector) {
    this.reflector = reflector;
  }
}

```

> **Hint** The `Reflector` class is imported from the `@nestjs/core` package.

Now, to read the handler metadata, use the `get()` method.

content\_copy

```typescript

const roles = this.reflector.get<string[]>('roles', context.getHandler());

```

Here instead of passing a decorator reference, we pass the metadata **key** as the first argument (which in our case is `'roles'`). Everything else remains the same as in the `Reflector#createDecorator` example.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Custom Decorators in NestJS
- [Custom route decorators](https://docs.nestjs.com/custom-decorators#custom-route-decorators)
- [Param decorators](https://docs.nestjs.com/custom-decorators#param-decorators)
- [Passing data](https://docs.nestjs.com/custom-decorators#passing-data)
- [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
- [Decorator composition](https://docs.nestjs.com/custom-decorators#decorator-composition)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/custom-decorators.md "Suggest Edits")

### Custom route decorators

Nest is built around a language feature called **decorators**. Decorators are a well-known concept in a lot of commonly used programming languages, but in the JavaScript world, they're still relatively new. In order to better understand how decorators work, we recommend reading [this article](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841). Here's a simple definition:

> An ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments. You apply it by prefixing the decorator with an `@` character and placing this at the very top of what you are trying to decorate. Decorators can be defined for either a class, a method or a property.

#### Param decorators [\#](https://docs.nestjs.com/custom-decorators\#param-decorators)

Nest provides a set of useful **param decorators** that you can use together with the HTTP route handlers. Below is a list of the provided decorators and the plain Express (or Fastify) objects they represent

|     |     |
| --- | --- |
| `@Request(), @Req()` | `req` |
| `@Response(), @Res()` | `res` |
| `@Next()` | `next` |
| `@Session()` | `req.session` |
| `@Param(param?: string)` | `req.params` / `req.params[param]` |
| `@Body(param?: string)` | `req.body` / `req.body[param]` |
| `@Query(param?: string)` | `req.query` / `req.query[param]` |
| `@Headers(param?: string)` | `req.headers` / `req.headers[param]` |
| `@Ip()` | `req.ip` |
| `@HostParam()` | `req.hosts` |

Additionally, you can create your own **custom decorators**. Why is this useful?

In the node.js world, it's common practice to attach properties to the **request** object. Then you manually extract them in each route handler, using code like the following:

content\_copy

```typescript

const user = req.user;

```

In order to make your code more readable and transparent, you can create a `@User()` decorator and reuse it across all of your controllers.

content\_copy user.decorator.ts

JS  TS

```typescript

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);

```

Then, you can simply use it wherever it fits your requirements.

content\_copy

JS  TS

```typescript

@Get()
async findOne(@User() user: UserEntity) {
  console.log(user);
}

```

```typescript

@Get()
@Bind(User())
async findOne(user) {
  console.log(user);
}

```

#### Passing data [\#](https://docs.nestjs.com/custom-decorators\#passing-data)

When the behavior of your decorator depends on some conditions, you can use the `data` parameter to pass an argument to the decorator's factory function. One use case for this is a custom decorator that extracts properties from the request object by key. Let's assume, for example, that our [authentication layer](https://docs.nestjs.com/techniques/authentication#implementing-passport-strategies) validates requests and attaches a user entity to the request object. The user entity for an authenticated request might look like:

```json

{
  "id": 101,
  "firstName": "Alan",
  "lastName": "Turing",
  "email": "alan@email.com",
  "roles": ["admin"]
}

```

Let's define a decorator that takes a property name as key, and returns the associated value if it exists (or undefined if it doesn't exist, or if the `user` object has not been created).

content\_copy user.decorator.ts

JS  TS

```typescript

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    return data ? user?.[data] : user;
  },
);

```

```typescript

import { createParamDecorator } from '@nestjs/common';

export const User = createParamDecorator((data, ctx) => {
  const request = ctx.switchToHttp().getRequest();
  const user = request.user;

  return data ? user && user[data] : user;
});

```

Here's how you could then access a particular property via the `@User()` decorator in the controller:

content\_copy

JS  TS

```typescript

@Get()
async findOne(@User('firstName') firstName: string) {
  console.log(`Hello ${firstName}`);
}

```

```typescript

@Get()
@Bind(User('firstName'))
async findOne(firstName) {
  console.log(`Hello ${firstName}`);
}

```

You can use this same decorator with different keys to access different properties. If the `user` object is deep or complex, this can make for easier and more readable request handler implementations.

> **Hint** For TypeScript users, note that `createParamDecorator<T>()` is a generic. This means you can explicitly enforce type safety, for example `createParamDecorator<string>((data, ctx) => ...)`. Alternatively, specify a parameter type in the factory function, for example `createParamDecorator((data: string, ctx) => ...)`. If you omit both, the type for `data` will be `any`.

#### Working with pipes [\#](https://docs.nestjs.com/custom-decorators\#working-with-pipes)

Nest treats custom param decorators in the same fashion as the built-in ones ( `@Body()`, `@Param()` and `@Query()`). This means that pipes are executed for the custom annotated parameters as well (in our examples, the `user` argument). Moreover, you can apply the pipe directly to the custom decorator:

content\_copy

JS  TS

```typescript

@Get()
async findOne(
  @User(new ValidationPipe({ validateCustomDecorators: true }))
  user: UserEntity,
) {
  console.log(user);
}

```

```typescript

@Get()
@Bind(User(new ValidationPipe({ validateCustomDecorators: true })))
async findOne(user) {
  console.log(user);
}

```

> **Hint** Note that `validateCustomDecorators` option must be set to true. `ValidationPipe` does not validate arguments annotated with the custom decorators by default.

#### Decorator composition [\#](https://docs.nestjs.com/custom-decorators\#decorator-composition)

Nest provides a helper method to compose multiple decorators. For example, suppose you want to combine all decorators related to authentication into a single decorator. This could be done with the following construction:

content\_copy auth.decorator.ts

JS  TS

```typescript

import { applyDecorators } from '@nestjs/common';

export function Auth(...roles: Role[]) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: 'Unauthorized' }),
  );
}

```

```typescript

import { applyDecorators } from '@nestjs/common';

export function Auth(...roles) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: 'Unauthorized' }),
  );
}

```

You can then use this custom `@Auth()` decorator as follows:

content\_copy

```typescript

@Get('users')
@Auth('admin')
findAllUsers() {}

```

This has the effect of applying all four decorators with a single declaration.

> **Warning** The `@ApiHideProperty()` decorator from the `@nestjs/swagger` package is not composable and won't work properly with the `applyDecorators` function.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Passport Authentication
- [Passport (authentication)](https://docs.nestjs.com/recipes/passport#passport-authentication)
- [Authentication requirements](https://docs.nestjs.com/recipes/passport#authentication-requirements)
- [Implementing Passport strategies](https://docs.nestjs.com/recipes/passport#implementing-passport-strategies)
- [Implementing Passport local](https://docs.nestjs.com/recipes/passport#implementing-passport-local)
- [Built-in Passport Guards](https://docs.nestjs.com/recipes/passport#built-in-passport-guards)
- [Login route](https://docs.nestjs.com/recipes/passport#login-route)
- [Logout route](https://docs.nestjs.com/recipes/passport#logout-route)
- [JWT functionality](https://docs.nestjs.com/recipes/passport#jwt-functionality)
- [Implementing Passport JWT](https://docs.nestjs.com/recipes/passport#implementing-passport-jwt)
- [Implement protected route and JWT strategy guards](https://docs.nestjs.com/recipes/passport#implement-protected-route-and-jwt-strategy-guards)
- [Extending guards](https://docs.nestjs.com/recipes/passport#extending-guards)
- [Enable authentication globally](https://docs.nestjs.com/recipes/passport#enable-authentication-globally)
- [Request-scoped strategies](https://docs.nestjs.com/recipes/passport#request-scoped-strategies)
- [Customize Passport](https://docs.nestjs.com/recipes/passport#customize-passport)
- [Named strategies](https://docs.nestjs.com/recipes/passport#named-strategies)
- [GraphQL](https://docs.nestjs.com/recipes/passport#graphql)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/passport.md "Suggest Edits")

### Passport (authentication)

[Passport](https://github.com/jaredhanson/passport) is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a **Nest** application using the `@nestjs/passport` module. At a high level, Passport executes a series of steps to:

- Authenticate a user by verifying their "credentials" (such as username/password, JSON Web Token ( [JWT](https://jwt.io/)), or identity token from an Identity Provider)
- Manage authenticated state (by issuing a portable token, such as a JWT, or creating an [Express session](https://github.com/expressjs/session))
- Attach information about the authenticated user to the `Request` object for further use in route handlers

Passport has a rich ecosystem of [strategies](http://www.passportjs.org/) that implement various authentication mechanisms. While simple in concept, the set of Passport strategies you can choose from is large and presents a lot of variety. Passport abstracts these varied steps into a standard pattern, and the `@nestjs/passport` module wraps and standardizes this pattern into familiar Nest constructs.

In this chapter, we'll implement a complete end-to-end authentication solution for a RESTful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example.

#### Authentication requirements [\#](https://docs.nestjs.com/recipes/passport\#authentication-requirements)

Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a [bearer token in an authorization header](https://tools.ietf.org/html/rfc6750) on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT.

We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request.

First we need to install the required packages. Passport provides a strategy called [passport-local](https://github.com/jaredhanson/passport-local) that implements a username/password authentication mechanism, which suits our needs for this portion of our use case.

```bash

$ npm install --save @nestjs/passport passport passport-local
$ npm install --save-dev @types/passport-local

```

> **Notice** For **any** Passport strategy you choose, you'll always need the `@nestjs/passport` and `passport` packages. Then, you'll need to install the strategy-specific package (e.g., `passport-jwt` or `passport-local`) that implements the particular authentication strategy you are building. In addition, you can also install the type definitions for any Passport strategy, as shown above with `@types/passport-local`, which provides assistance while writing TypeScript code.

#### Implementing Passport strategies [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-strategies)

We're now ready to implement the authentication feature. We'll start with an overview of the process used for **any** Passport strategy. It's helpful to think of Passport as a mini framework in itself. The elegance of the framework is that it abstracts the authentication process into a few basic steps that you customize based on the strategy you're implementing. It's like a framework because you configure it by supplying customization parameters (as plain JSON objects) and custom code in the form of callback functions, which Passport calls at the appropriate time. The `@nestjs/passport` module wraps this framework in a Nest style package, making it easy to integrate into a Nest application. We'll use `@nestjs/passport` below, but first let's consider how **vanilla Passport** works.

In vanilla Passport, you configure a strategy by providing two things:

1. A set of options that are specific to that strategy. For example, in a JWT strategy, you might provide a secret to sign tokens.
2. A "verify callback", which is where you tell Passport how to interact with your user store (where you manage user accounts). Here, you verify whether a user exists (and/or create a new user), and whether their credentials are valid. The Passport library expects this callback to return a full user if the validation succeeds, or a null if it fails (failure is defined as either the user is not found, or, in the case of passport-local, the password does not match).

With `@nestjs/passport`, you configure a Passport strategy by extending the `PassportStrategy` class. You pass the strategy options (item 1 above) by calling the `super()` method in your subclass, optionally passing in an options object. You provide the verify callback (item 2 above) by implementing a `validate()` method in your subclass.

We'll start by generating an `AuthModule` and in it, an `AuthService`:

```bash

$ nest g module auth
$ nest g service auth

```

As we implement the `AuthService`, we'll find it useful to encapsulate user operations in a `UsersService`, so let's generate that module and service now:

```bash

$ nest g module users
$ nest g service users

```

Replace the default contents of these generated files as shown below. For our sample app, the `UsersService` simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.).

content\_copy users/users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';

// This should be a real class/interface representing a user entity
export type User = any;

@Injectable()
export class UsersService {
  private readonly users = [\
    {\
      userId: 1,\
      username: 'john',\
      password: 'changeme',\
    },\
    {\
      userId: 2,\
      username: 'maria',\
      password: 'guess',\
    },\
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find(user => user.username === username);
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  constructor() {
    this.users = [\
      {\
        userId: 1,\
        username: 'john',\
        password: 'changeme',\
      },\
      {\
        userId: 2,\
        username: 'maria',\
        password: 'guess',\
      },\
    ];
  }

  async findOne(username) {
    return this.users.find(user => user.username === username);
  }
}

```

In the `UsersModule`, the only change needed is to add the `UsersService` to the exports array of the `@Module` decorator so that it is visible outside this module (we'll soon use it in our `AuthService`).

content\_copy users/users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

```

Our `AuthService` has the job of retrieving a user and verifying the password. We create a `validateUser()` method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. We'll be calling into the `validateUser()` method from our Passport local strategy in a moment.

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
@Dependencies(UsersService)
export class AuthService {
  constructor(usersService) {
    this.usersService = usersService;
  }

  async validateUser(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }
}

```

> **Warning** Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like [bcrypt](https://github.com/kelektiv/node.bcrypt.js#readme), with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the **incoming** password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. **Don't do this in your real app!**

Now, we update our `AuthModule` to import the `UsersModule`.

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
})
export class AuthModule {}

```

#### Implementing Passport local [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-local)

Now we can implement our Passport **local authentication strategy**. Create a file called `local.strategy.ts` in the `auth` folder, and add the following code:

content\_copy auth/local.strategy.ts

JS  TS

```typescript

import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

```

```typescript

import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException, Dependencies } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
@Dependencies(AuthService)
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(authService) {
    super();
    this.authService = authService;
  }

  async validate(username, password) {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

```

We've followed the recipe described earlier for all Passport strategies. In our use case with passport-local, there are no configuration options, so our constructor simply calls `super()`, without an options object.

> **Hint** We can pass an options object in the call to `super()` to customize the behavior of the passport strategy. In this example, the passport-local strategy by default expects properties called `username` and `password` in the request body. Pass an options object to specify different property names, for example: `super({ usernameField: 'email' })`. See the [Passport documentation](http://www.passportjs.org/docs/configure/) for more information.

We've also implemented the `validate()` method. For each strategy, Passport will call the verify function (implemented with the `validate()` method in `@nestjs/passport`) using an appropriate strategy-specific set of parameters. For the local-strategy, Passport expects a `validate()` method with the following signature: `validate(username: string, password:string): any`.

Most of the validation work is done in our `AuthService` (with the help of our `UsersService`), so this method is quite straightforward. The `validate()` method for **any** Passport strategy will follow a similar pattern, varying only in the details of how credentials are represented. If a user is found and the credentials are valid, the user is returned so Passport can complete its tasks (e.g., creating the `user` property on the `Request` object), and the request handling pipeline can continue. If it's not found, we throw an exception and let our [exceptions layer](https://docs.nestjs.com/exception-filters) handle it.

Typically, the only significant difference in the `validate()` method for each strategy is **how** you determine if a user exists and is valid. For example, in a JWT strategy, depending on requirements, we may evaluate whether the `userId` carried in the decoded token matches a record in our user database, or matches a list of revoked tokens. Hence, this pattern of sub-classing and implementing strategy-specific validation is consistent, elegant and extensible.

We need to configure our `AuthModule` to use the Passport features we just defined. Update `auth.module.ts` to look like this:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [UsersModule, PassportModule],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [UsersModule, PassportModule],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}

```

#### Built-in Passport Guards [\#](https://docs.nestjs.com/recipes/passport\#built-in-passport-guards)

The [Guards](https://docs.nestjs.com/guards) chapter describes the primary function of Guards: to determine whether a request will be handled by the route handler or not. That remains true, and we'll use that standard capability soon. However, in the context of using the `@nestjs/passport` module, we will also introduce a slight new wrinkle that may at first be confusing, so let's discuss that now. Consider that your app can exist in two states, from an authentication perspective:

1. the user/client is **not** logged in (is not authenticated)
2. the user/client **is** logged in (is authenticated)

In the first case (user is not logged in), we need to perform two distinct functions:

- Restrict the routes an unauthenticated user can access (i.e., deny access to restricted routes). We'll use Guards in their familiar capacity to handle this function, by placing a Guard on the protected routes. As you may anticipate, we'll be checking for the presence of a valid JWT in this Guard, so we'll work on this Guard later, once we are successfully issuing JWTs.

- Initiate the **authentication step** itself when a previously unauthenticated user attempts to login. This is the step where we'll **issue** a JWT to a valid user. Thinking about this for a moment, we know we'll need to `POST` username/password credentials to initiate authentication, so we'll set up a `POST /auth/login` route to handle that. This raises the question: how exactly do we invoke the passport-local strategy in that route?


The answer is straightforward: by using another, slightly different type of Guard. The `@nestjs/passport` module provides us with a built-in Guard that does this for us. This Guard invokes the Passport strategy and kicks off the steps described above (retrieving credentials, running the verify function, creating the `user` property, etc).

The second case enumerated above (logged in user) simply relies on the standard type of Guard we already discussed to enable access to protected routes for logged in users.

## Learn the right way!

- 19 chapters
- Authn & Authz
- Official certificate
- Deep-dive sessions

[Purchase the Authentication course](https://courses.nestjs.com/#authentication "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Login route [\#](https://docs.nestjs.com/recipes/passport\#login-route)

With the strategy in place, we can now implement a bare-bones `/auth/login` route, and apply the built-in Guard to initiate the passport-local flow.

Open the `app.controller.ts` file and replace its contents with the following:

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Request, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AppController {
  @UseGuards(AuthGuard('local'))
  @Post('auth/login')
  async login(@Request() req) {
    return req.user;
  }
}

```

```typescript

import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AppController {
  @UseGuards(AuthGuard('local'))
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return req.user;
  }
}

```

With `@UseGuards(AuthGuard('local'))` we are using an `AuthGuard` that `@nestjs/passport` **automatically provisioned** for us when we extended the passport-local strategy. Let's break that down. Our Passport local strategy has a default name of `'local'`. We reference that name in the `@UseGuards()` decorator to associate it with code supplied by the `passport-local` package. This is used to disambiguate which strategy to invoke in case we have multiple Passport strategies in our app (each of which may provision a strategy-specific `AuthGuard`). While we only have one such strategy so far, we'll shortly add a second, so this is needed for disambiguation.

In order to test our route we'll have our `/auth/login` route simply return the user for now. This also lets us demonstrate another Passport feature: Passport automatically creates a `user` object, based on the value we return from the `validate()` method, and assigns it to the `Request` object as `req.user`. Later, we'll replace this with code to create and return a JWT instead.

Since these are API routes, we'll test them using the commonly available [cURL](https://curl.haxx.se/) library. You can test with any of the `user` objects hard-coded in the `UsersService`.

```bash

$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"userId":1,"username":"john"}

```

While this works, passing the strategy name directly to the `AuthGuard()` introduces magic strings in the codebase. Instead, we recommend creating your own class, as shown below:

content\_copy auth/local-auth.guard.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

```

Now, we can update the `/auth/login` route handler and use the `LocalAuthGuard` instead:

content\_copy

```typescript

@UseGuards(LocalAuthGuard)
@Post('auth/login')
async login(@Request() req) {
  return req.user;
}

```

#### Logout route [\#](https://docs.nestjs.com/recipes/passport\#logout-route)

To log out, we can create an additional route that invokes `req.logout()` to clear the user's session. This is a typical approach used in session-based authentication, but it does not apply to JWTs.

content\_copy

```typescript

@UseGuards(LocalAuthGuard)
@Post('auth/logout')
async logout(@Request() req) {
  return req.logout();
}

```

#### JWT functionality [\#](https://docs.nestjs.com/recipes/passport\#jwt-functionality)

We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:

- Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT.
- Create API routes which are protected based on the presence of a valid JWT as a bearer token

We'll need to install a couple more packages to support our JWT requirements:

```bash

$ npm install --save @nestjs/jwt passport-jwt
$ npm install --save-dev @types/passport-jwt

```

The `@nestjs/jwt` package (see more [here](https://github.com/nestjs/jwt)) is a utility package that helps with JWT manipulation. The `passport-jwt` package is the Passport package that implements the JWT strategy and `@types/passport-jwt` provides the TypeScript type definitions.

Let's take a closer look at how a `POST /auth/login` request is handled. We've decorated the route using the built-in `AuthGuard` provided by the passport-local strategy. This means that:

1. The route handler **will only be invoked if the user has been validated**
2. The `req` parameter will contain a `user` property (populated by Passport during the passport-local authentication flow)

With this in mind, we can now finally generate a real JWT, and return it in this route. To keep our services cleanly modularized, we'll handle generating the JWT in the `authService`. Open the `auth.service.ts` file in the `auth` folder, and add the `login()` method, and import the `JwtService` as shown:

content\_copy auth/auth.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Dependencies(UsersService, JwtService)
@Injectable()
export class AuthService {
  constructor(usersService, jwtService) {
    this.usersService = usersService;
    this.jwtService = jwtService;
  }

  async validateUser(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}

```

We're using the `@nestjs/jwt` library, which supplies a `sign()` function to generate our JWT from a subset of the `user` object properties, which we then return as a simple object with a single `access_token` property. Note: we choose a property name of `sub` to hold our `userId` value to be consistent with JWT standards. Don't forget to inject the JwtService provider into the `AuthService`.

We now need to update the `AuthModule` to import the new dependencies and configure the `JwtModule`.

First, create `constants.ts` in the `auth` folder, and add the following code:

content\_copy auth/constants.ts

JS  TS

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

```typescript

export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};

```

We'll use this to share our key between the JWT signing and verifying steps.

> **Warning** **Do not expose this key publicly**. We have done so here to make it clear what the code is doing, but in a production system **you must protect this key** using appropriate measures such as a secrets vault, environment variable, or configuration service.

Now, open `auth.module.ts` in the `auth` folder and update it to look like this:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

We configure the `JwtModule` using `register()`, passing in a configuration object. See [here](https://github.com/nestjs/jwt/blob/master/README.md) for more on the Nest `JwtModule` and [here](https://github.com/auth0/node-jsonwebtoken#usage) for more details on the available configuration options.

Now we can update the `/auth/login` route to return a JWT.

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Request, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }
}

```

```typescript

import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return this.authService.login(req.user);
  }
}

```

Let's go ahead and test our routes using cURL again. You can test with any of the `user` objects hard-coded in the `UsersService`.

```bash

$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
$ # Note: above JWT truncated

```

#### Implementing Passport JWT [\#](https://docs.nestjs.com/recipes/passport\#implementing-passport-jwt)

We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. Passport can help us here too. It provides the [passport-jwt](https://github.com/mikenicholson/passport-jwt) strategy for securing RESTful endpoints with JSON Web Tokens. Start by creating a file called `jwt.strategy.ts` in the `auth` folder, and add the following code:

content\_copy auth/jwt.strategy.ts

JS  TS

```typescript

import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { jwtConstants } from './constants';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}

```

```typescript

import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { jwtConstants } from './constants';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload) {
    return { userId: payload.sub, username: payload.username };
  }
}

```

With our `JwtStrategy`, we've followed the same recipe described earlier for all Passport strategies. This strategy requires some initialization, so we do that by passing in an options object in the `super()` call. You can read more about the available options [here](https://github.com/mikenicholson/passport-jwt#configure-strategy). In our case, these options are:

- `jwtFromRequest`: supplies the method by which the JWT will be extracted from the `Request`. We will use the standard approach of supplying a bearer token in the Authorization header of our API requests. Other options are described [here](https://github.com/mikenicholson/passport-jwt#extracting-the-jwt-from-the-request).
- `ignoreExpiration`: just to be explicit, we choose the default `false` setting, which delegates the responsibility of ensuring that a JWT has not expired to the Passport module. This means that if our route is supplied with an expired JWT, the request will be denied and a `401 Unauthorized` response sent. Passport conveniently handles this automatically for us.
- `secretOrKey`: we are using the expedient option of supplying a symmetric secret for signing the token. Other options, such as a PEM-encoded public key, may be more appropriate for production apps (see [here](https://github.com/mikenicholson/passport-jwt#configure-strategy) for more information). In any case, as cautioned earlier, **do not expose this secret publicly**.

The `validate()` method deserves some discussion. For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our `validate()` method passing the decoded JSON as its single parameter. Based on the way JWT signing works, **we're guaranteed that we're receiving a valid token** that we have previously signed and issued to a valid user.

As a result of all this, our response to the `validate()` callback is trivial: we simply return an object containing the `userId` and `username` properties. Recall again that Passport will build a `user` object based on the return value of our `validate()` method, and attach it as a property on the `Request` object.

Additionally, you can return an array, where the first value is used to create a `user` object and the second value is used to create an `authInfo` object.

It's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our `validate()` method to extract more information about the user, resulting in a more enriched `user` object being available in our `Request`. This is also the place we may decide to do further token validation, such as looking up the `userId` in a list of revoked tokens, enabling us to perform token revocation. The model we've implemented here in our sample code is a fast, "stateless JWT" model, where each API call is immediately authorized based on the presence of a valid JWT, and a small bit of information about the requester (its `userId` and `username`) is available in our Request pipeline.

Add the new `JwtStrategy` as a provider in the `AuthModule`:

content\_copy auth/auth.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

```typescript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalStrategy } from './local.strategy';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { jwtConstants } from './constants';

@Module({
  imports: [\
    UsersModule,\
    PassportModule,\
    JwtModule.register({\
      secret: jwtConstants.secret,\
      signOptions: { expiresIn: '60s' },\
    }),\
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}

```

By importing the same secret used when we signed the JWT, we ensure that the **verify** phase performed by Passport, and the **sign** phase performed in our AuthService, use a common secret.

Finally, we define the `JwtAuthGuard` class which extends the built-in `AuthGuard`:

content\_copy auth/jwt-auth.guard.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

```

#### Implement protected route and JWT strategy guards [\#](https://docs.nestjs.com/recipes/passport\#implement-protected-route-and-jwt-strategy-guards)

We can now implement our protected route and its associated Guard.

Open the `app.controller.ts` file and update it as shown below:

content\_copy app.controller.ts

JS  TS

```typescript

import { Controller, Get, Request, Post, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './auth/jwt-auth.guard';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Controller()
export class AppController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}

```

```typescript

import { Controller, Dependencies, Bind, Get, Request, Post, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './auth/jwt-auth.guard';
import { LocalAuthGuard } from './auth/local-auth.guard';
import { AuthService } from './auth/auth.service';

@Dependencies(AuthService)
@Controller()
export class AppController {
  constructor(authService) {
    this.authService = authService;
  }

  @UseGuards(LocalAuthGuard)
  @Post('auth/login')
  @Bind(Request())
  async login(req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  @Bind(Request())
  getProfile(req) {
    return req.user;
  }
}

```

Once again, we're applying the `AuthGuard` that the `@nestjs/passport` module has automatically provisioned for us when we configured the passport-jwt module. This Guard is referenced by its default name, `jwt`. When our `GET /profile` route is hit, the Guard will automatically invoke our passport-jwt custom configured strategy, validate the JWT, and assign the `user` property to the `Request` object.

Ensure the app is running, and test the routes using `cURL`.

```bash

$ # GET /profile
$ curl http://localhost:3000/profile
$ # result -> {"statusCode":401,"message":"Unauthorized"}

$ # POST /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm... }

$ # GET /profile using access_token returned from previous step as bearer code
$ curl http://localhost:3000/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."
$ # result -> {"userId":1,"username":"john"}

```

Note that in the `AuthModule`, we configured the JWT to have an expiration of `60 seconds`. This is probably too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs and the passport-jwt strategy. If you wait 60 seconds after authenticating before attempting a `GET /profile` request, you'll receive a `401 Unauthorized` response. This is because Passport automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application.

We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server.

#### Extending guards [\#](https://docs.nestjs.com/recipes/passport\#extending-guards)

In most cases, using a provided `AuthGuard` class is sufficient. However, there might be use-cases when you would like to simply extend the default error handling or authentication logic. For this, you can extend the built-in class and override methods within a sub-class.

content\_copy

```typescript

import {
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    // Add your custom authentication logic here
    // for example, call super.logIn(request) to establish a session.
    return super.canActivate(context);
  }

  handleRequest(err, user, info) {
    // You can throw an exception based on either "info" or "err" arguments
    if (err || !user) {
      throw err || new UnauthorizedException();
    }
    return user;
  }
}

```

In addition to extending the default error handling and authentication logic, we can allow authentication to go through a chain of strategies. The first strategy to succeed, redirect, or error will halt the chain. Authentication failures will proceed through each strategy in series, ultimately failing if all strategies fail.

content\_copy

```typescript

export class JwtAuthGuard extends AuthGuard(['strategy_jwt_1', 'strategy_jwt_2', '...']) { ... }

```

#### Enable authentication globally [\#](https://docs.nestjs.com/recipes/passport\#enable-authentication-globally)

If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a [global guard](https://docs.nestjs.com/guards#binding-guards) and instead of using `@UseGuards()` decorator on top of each controller, you could simply flag which routes should be public.

First, register the `JwtAuthGuard` as a global guard using the following construction (in any module):

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useClass: JwtAuthGuard,\
  },\
],

```

With this in place, Nest will automatically bind `JwtAuthGuard` to all endpoints.

Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the `SetMetadata` decorator factory function.

content\_copy

```typescript

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

```

In the file above, we exported two constants. One being our metadata key named `IS_PUBLIC_KEY`, and the other being our new decorator itself that we’re going to call `Public` (you can alternatively name it `SkipAuth` or `AllowAnon`, whatever fits your project).

Now that we have a custom `@Public()` decorator, we can use it to decorate any method, as follows:

content\_copy

```typescript

@Public()
@Get()
findAll() {
  return [];
}

```

Lastly, we need the `JwtAuthGuard` to return `true` when the `"isPublic"` metadata is found. For this, we'll use the `Reflector` class (read more [here](https://docs.nestjs.com/guards#putting-it-all-together)).

content\_copy

```typescript

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\
      context.getHandler(),\
      context.getClass(),\
    ]);
    if (isPublic) {
      return true;
    }
    return super.canActivate(context);
  }
}

```

#### Request-scoped strategies [\#](https://docs.nestjs.com/recipes/passport\#request-scoped-strategies)

The passport API is based on registering strategies to the global instance of the library. Therefore strategies are not designed to have request-dependent options or to be dynamically instantiated per request (read more about the [request-scoped](https://docs.nestjs.com/fundamentals/injection-scopes) providers). When you configure your strategy to be request-scoped, Nest will never instantiate it since it's not tied to any specific route. There is no physical way to determine which "request-scoped" strategies should be executed per request.

However, there are ways to dynamically resolve request-scoped providers within the strategy. For this, we leverage the [module reference](https://docs.nestjs.com/fundamentals/module-ref) feature.

First, open the `local.strategy.ts` file and inject the `ModuleRef` in the normal way:

content\_copy

```typescript

constructor(private moduleRef: ModuleRef) {
  super({
    passReqToCallback: true,
  });
}

```

> **Hint** The `ModuleRef` class is imported from the `@nestjs/core` package.

Be sure to set the `passReqToCallback` configuration property to `true`, as shown above.

In the next step, the request instance will be used to obtain the current context identifier, instead of generating a new one (read more about request context [here](https://docs.nestjs.com/fundamentals/module-ref#getting-current-sub-tree)).

Now, inside the `validate()` method of the `LocalStrategy` class, use the `getByRequest()` method of the `ContextIdFactory` class to create a context id based on the request object, and pass this to the `resolve()` call:

content\_copy

```typescript

async validate(
  request: Request,
  username: string,
  password: string,
) {
  const contextId = ContextIdFactory.getByRequest(request);
  // "AuthService" is a request-scoped provider
  const authService = await this.moduleRef.resolve(AuthService, contextId);
  ...
}

```

In the example above, the `resolve()` method will asynchronously return the request-scoped instance of the `AuthService` provider (we assumed that `AuthService` is marked as a request-scoped provider).

#### Customize Passport [\#](https://docs.nestjs.com/recipes/passport\#customize-passport)

Any standard Passport customization options can be passed the same way, using the `register()` method. The available options depend on the strategy being implemented. For example:

content\_copy

```typescript

PassportModule.register({ session: true });

```

You can also pass strategies an options object in their constructors to configure them.
For the local strategy you can pass e.g.:

content\_copy

```typescript

constructor(private authService: AuthService) {
  super({
    usernameField: 'email',
    passwordField: 'password',
  });
}

```

Take a look at the official [Passport Website](http://www.passportjs.org/docs/oauth/) for property names.

#### Named strategies [\#](https://docs.nestjs.com/recipes/passport\#named-strategies)

When implementing a strategy, you can provide a name for it by passing a second argument to the `PassportStrategy` function. If you don't do this, each strategy will have a default name (e.g., 'jwt' for jwt-strategy):

content\_copy

```typescript

export class JwtStrategy extends PassportStrategy(Strategy, 'myjwt')

```

Then, you refer to this via a decorator like `@UseGuards(AuthGuard('myjwt'))`.

#### GraphQL [\#](https://docs.nestjs.com/recipes/passport\#graphql)

In order to use an AuthGuard with [GraphQL](https://docs.nestjs.com/graphql/quick-start), extend the built-in `AuthGuard` class and override the `getRequest()` method.

content\_copy

```typescript

@Injectable()
export class GqlAuthGuard extends AuthGuard('jwt') {
  getRequest(context: ExecutionContext) {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req;
  }
}

```

To get the current authenticated user in your graphql resolver, you can define a `@CurrentUser()` decorator:

content\_copy

```typescript

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext) => {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req.user;
  },
);

```

To use above decorator in your resolver, be sure to include it as a parameter of your query or mutation:

content\_copy

```typescript

@Query(() => User)
@UseGuards(GqlAuthGuard)
whoAmI(@CurrentUser() user: User) {
  return this.usersService.findById(user.id);
}

```

For the passport-local strategy, you'll also need to add the GraphQL context's arguments to the request body so Passport can access them for validation. Otherwise, you'll get an Unauthorized error.

content\_copy

```typescript

@Injectable()
export class GqlLocalAuthGuard extends AuthGuard('local') {
  getRequest(context: ExecutionContext) {
    const gqlExecutionContext = GqlExecutionContext.create(context);
    const gqlContext = gqlExecutionContext.getContext();
    const gqlArgs = gqlExecutionContext.getArgs();

    gqlContext.req.body = { ...gqlContext.req.body, ...gqlArgs };
    return gqlContext.req;
  }
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## OpenAPI Integration Guide
- [Introduction](https://docs.nestjs.com/openapi/introduction#introduction)
- [Installation](https://docs.nestjs.com/openapi/introduction#installation)
- [Bootstrap](https://docs.nestjs.com/openapi/introduction#bootstrap)
- [Document options](https://docs.nestjs.com/openapi/introduction#document-options)
- [Setup options](https://docs.nestjs.com/openapi/introduction#setup-options)
- [Example](https://docs.nestjs.com/openapi/introduction#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/introduction.md "Suggest Edits")

### Introduction

The [OpenAPI](https://swagger.io/specification/) specification is a language-agnostic definition format used to describe RESTful APIs. Nest provides a dedicated [module](https://github.com/nestjs/swagger) which allows generating such a specification by leveraging decorators.

#### Installation [\#](https://docs.nestjs.com/openapi/introduction\#installation)

To begin using it, we first install the required dependency.

```bash

$ npm install --save @nestjs/swagger

```

#### Bootstrap [\#](https://docs.nestjs.com/openapi/introduction\#bootstrap)

Once the installation process is complete, open the `main.ts` file and initialize Swagger using the `SwaggerModule` class:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
    .setTitle('Cats example')
    .setDescription('The cats API description')
    .setVersion('1.0')
    .addTag('cats')
    .build();
  const documentFactory = () => SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, documentFactory);

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

> **Hint** The factory method `SwaggerModule.createDocument()` is used specifically to generate the Swagger document when you request it. This approach helps save some initialization time, and the resulting document is a serializable object that conforms to the [OpenAPI Document](https://swagger.io/specification/#openapi-document) specification. Instead of serving the document over HTTP, you can also save it as a JSON or YAML file and use it in various ways.

The `DocumentBuilder` helps to structure a base document that conforms to the OpenAPI Specification. It provides several methods that allow setting such properties as title, description, version, etc. In order to create a full document (with all HTTP routes defined) we use the `createDocument()` method of the `SwaggerModule` class. This method takes two arguments, an application instance and a Swagger options object. Alternatively, we can provide a third argument, which should be of type `SwaggerDocumentOptions`. More on this in the [Document options section](https://docs.nestjs.com/openapi/introduction#document-options).

Once we create a document, we can call the `setup()` method. It accepts:

1. The path to mount the Swagger UI
2. An application instance
3. The document object instantiated above
4. Optional configuration parameter (read more [here](https://docs.nestjs.com/openapi/introduction#setup-options))

Now you can run the following command to start the HTTP server:

```bash

$ npm run start

```

While the application is running, open your browser and navigate to `http://localhost:3000/api`. You should see the Swagger UI.

![](https://docs.nestjs.com/assets/swagger1.png)

As you can see, the `SwaggerModule` automatically reflects all of your endpoints.

> **Hint** To generate and download a Swagger JSON file, navigate to `http://localhost:3000/api-json` (assuming that your Swagger documentation is available under `http://localhost:3000/api`).
> It is also possible to expose it on a route of your choice using only the setup method from `@nestjs/swagger`, like this:
> content\_copy
>
> ```typescript
>
> SwaggerModule.setup('swagger', app, documentFactory, {
>   jsonDocumentUrl: 'swagger/json',
> });
>
> ```
>
> Which would expose it at `http://localhost:3000/swagger/json`

> **Warning** When using `fastify` and `helmet`, there may be a problem with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), to solve this collision, configure the CSP as shown below:
> content\_copy
>
> ```typescript
>
> app.register(helmet, {
>   contentSecurityPolicy: {
>     directives: {
>       defaultSrc: [`'self'`],
>       styleSrc: [`'self'`, `'unsafe-inline'`],
>       imgSrc: [`'self'`, 'data:', 'validator.swagger.io'],
>       scriptSrc: [`'self'`, `https: 'unsafe-inline'`],
>     },
>   },
> });
>
> // If you are not going to use CSP at all, you can use this:
> app.register(helmet, {
>   contentSecurityPolicy: false,
> });
>
> ```

#### Document options [\#](https://docs.nestjs.com/openapi/introduction\#document-options)

When creating a document, it is possible to provide some extra options to fine tune the library's behavior. These options should be of type `SwaggerDocumentOptions`, which can be the following:

```typescript

export interface SwaggerDocumentOptions {
  /**
   * List of modules to include in the specification
   */
  include?: Function[];

  /**
   * Additional, extra models that should be inspected and included in the specification
   */
  extraModels?: Function[];

  /**
   * If `true`, swagger will ignore the global prefix set through `setGlobalPrefix()` method
   */
  ignoreGlobalPrefix?: boolean;

  /**
   * If `true`, swagger will also load routes from the modules imported by `include` modules
   */
  deepScanRoutes?: boolean;

  /**
   * Custom operationIdFactory that will be used to generate the `operationId`
   * based on the `controllerKey`, `methodKey`, and version.
   * @default () => controllerKey_methodKey_version
   */
  operationIdFactory?: OperationIdFactory;

  /**
   * Custom linkNameFactory that will be used to generate the name of links
   * in the `links` field of responses
   *
   * @see [Link objects](https://swagger.io/docs/specification/links/)
   *
   * @default () => `${controllerKey}_${methodKey}_from_${fieldKey}`
   */
  linkNameFactory?: (
    controllerKey: string,
    methodKey: string,
    fieldKey: string
  ) => string;

  /*
   * Generate tags automatically based on the controller name.
   * If `false`, you must use the `@ApiTags()` decorator to define tags.
   * Otherwise, the controller name without the suffix `Controller` will be used.
   * @default true
   */
  autoTagControllers?: boolean;
}

```

For example, if you want to make sure that the library generates operation names like `createUser` instead of `UsersController_createUser`, you can set the following:

```typescript

const options: SwaggerDocumentOptions =  {
  operationIdFactory: (
    controllerKey: string,
    methodKey: string
  ) => methodKey
};
const documentFactory = () => SwaggerModule.createDocument(app, config, options);

```

#### Setup options [\#](https://docs.nestjs.com/openapi/introduction\#setup-options)

You can configure Swagger UI by passing the options object which fulfills the `SwaggerCustomOptions` interface as a fourth argument of the `SwaggerModule#setup` method.

```typescript

export interface SwaggerCustomOptions {
  /**
   * If `true`, Swagger resources paths will be prefixed by the global prefix set through `setGlobalPrefix()`.
   * Default: `false`.
   * @see https://docs.nestjs.com/faq/global-prefix
   */
  useGlobalPrefix?: boolean;

  /**
   * If `false`, the Swagger UI will not be served. Only API definitions (JSON and YAML)
   * will be accessible (on `/{path}-json` and `/{path}-yaml`). To fully disable both the Swagger UI and API definitions, use `raw: false`.
   * Default: `true`.
   * @deprecated Use `ui` instead.
   */
  swaggerUiEnabled?: boolean;

  /**
   * If `false`, the Swagger UI will not be served. Only API definitions (JSON and YAML)
   * will be accessible (on `/{path}-json` and `/{path}-yaml`). To fully disable both the Swagger UI and API definitions, use `raw: false`.
   * Default: `true`.
   */
  ui?: boolean;

  /**
   * If `true`, raw definitions for all formats will be served.
   * Alternatively, you can pass an array to specify the formats to be served, e.g., `raw: ['json']` to serve only JSON definitions.
   * If omitted or set to an empty array, no definitions (JSON or YAML) will be served.
   * Use this option to control the availability of Swagger-related endpoints.
   * Default: `true`.
   */
  raw?: boolean | Array<'json' | 'yaml'>;

  /**
   * Url point the API definition to load in Swagger UI.
   */
  swaggerUrl?: string;

  /**
   * Path of the JSON API definition to serve.
   * Default: `<path>-json`.
   */
  jsonDocumentUrl?: string;

  /**
   * Path of the YAML API definition to serve.
   * Default: `<path>-yaml`.
   */
  yamlDocumentUrl?: string;

  /**
   * Hook allowing to alter the OpenAPI document before being served.
   * It's called after the document is generated and before it is served as JSON & YAML.
   */
  patchDocumentOnRequest?: <TRequest = any, TResponse = any>(
    req: TRequest,
    res: TResponse,
    document: OpenAPIObject
  ) => OpenAPIObject;

  /**
   * If `true`, the selector of OpenAPI definitions is displayed in the Swagger UI interface.
   * Default: `false`.
   */
  explorer?: boolean;

  /**
   * Additional Swagger UI options
   */
  swaggerOptions?: SwaggerUiOptions;

  /**
   * Custom CSS styles to inject in Swagger UI page.
   */
  customCss?: string;

  /**
   * URL(s) of a custom CSS stylesheet to load in Swagger UI page.
   */
  customCssUrl?: string | string[];

  /**
   * URL(s) of custom JavaScript files to load in Swagger UI page.
   */
  customJs?: string | string[];

  /**
   * Custom JavaScript scripts to load in Swagger UI page.
   */
  customJsStr?: string | string[];

  /**
   * Custom favicon for Swagger UI page.
   */
  customfavIcon?: string;

  /**
   * Custom title for Swagger UI page.
   */
  customSiteTitle?: string;

  /**
   * File system path (ex: ./node_modules/swagger-ui-dist) containing static Swagger UI assets.
   */
  customSwaggerUiPath?: string;

  /**
   * @deprecated This property has no effect.
   */
  validatorUrl?: string;

  /**
   * @deprecated This property has no effect.
   */
  url?: string;

  /**
   * @deprecated This property has no effect.
   */
  urls?: Record<'url' | 'name', string>[];
}

```

> **Hint** `ui` and `raw` are independent options. Disabling Swagger UI ( `ui: false`) does not disable API definitions (JSON/YAML). Conversely, disabling API definitions ( `raw: []`) does not disable the Swagger UI.
>
> For example, the following configuration will disable the Swagger UI but still allow access to API definitions:
>
> content\_copy
>
> ```typescript
>
> const options: SwaggerCustomOptions = {
>   ui: false, // Swagger UI is disabled
>   raw: ['json'], // JSON API definition is still accessible (YAML is disabled)
> };
> SwaggerModule.setup('api', app, options);
>
> ```
>
> In this case, [http://localhost:3000/api-json](http://localhost:3000/api-json) will still be accessible, but [http://localhost:3000/api](http://localhost:3000/api) (Swagger UI) will not.

#### Example [\#](https://docs.nestjs.com/openapi/introduction\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/11-swagger).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Lazy Loading Modules
- [Lazy loading modules](https://docs.nestjs.com/fundamentals/lazy-loading-modules#lazy-loading-modules)
- [Getting started](https://docs.nestjs.com/fundamentals/lazy-loading-modules#getting-started)
- [Lazy loading controllers, gateways, and resolvers](https://docs.nestjs.com/fundamentals/lazy-loading-modules#lazy-loading-controllers-gateways-and-resolvers)
- [Common use-cases](https://docs.nestjs.com/fundamentals/lazy-loading-modules#common-use-cases)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/lazy-loading-modules.md "Suggest Edits")

### Lazy loading modules

By default, modules are eagerly loaded, which means that as soon as the application loads, so do all the modules, whether or not they are immediately necessary. While this is fine for most applications, it may become a bottleneck for apps/workers running in the **serverless environment**, where the startup latency ("cold start") is crucial.

Lazy loading can help decrease bootstrap time by loading only modules required by the specific serverless function invocation. In addition, you could also load other modules asynchronously once the serverless function is "warm" to speed-up the bootstrap time for subsequent calls even further (deferred modules registration).

> **Hint** If you're familiar with the **[Angular](https://angular.dev/)** framework, you might have seen the " [lazy-loading modules](https://angular.dev/guide/ngmodules/lazy-loading#lazy-loading-basics)" term before. Be aware that this technique is **functionally different** in Nest and so think about this as an entirely different feature that shares similar naming conventions.

> **Warning** Do note that [lifecycle hooks methods](https://docs.nestjs.com/fundamentals/lifecycle-events) are not invoked in lazy loaded modules and services.

#### Getting started [\#](https://docs.nestjs.com/fundamentals/lazy-loading-modules\#getting-started)

To load modules on-demand, Nest provides the `LazyModuleLoader` class that can be injected into a class in the normal way:

content\_copy cats.service.ts

JS  TS

```typescript

@Injectable()
export class CatsService {
  constructor(private lazyModuleLoader: LazyModuleLoader) {}
}

```

```typescript

@Injectable()
@Dependencies(LazyModuleLoader)
export class CatsService {
  constructor(lazyModuleLoader) {
    this.lazyModuleLoader = lazyModuleLoader;
  }
}

```

> **Hint** The `LazyModuleLoader` class is imported from the `@nestjs/core` package.

Alternatively, you can obtain a reference to the `LazyModuleLoader` provider from within your application bootstrap file ( `main.ts`), as follows:

content\_copy

```typescript

// "app" represents a Nest application instance
const lazyModuleLoader = app.get(LazyModuleLoader);

```

With this in place, you can now load any module using the following construction:

content\_copy

```typescript

const { LazyModule } = await import('./lazy.module');
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule);

```

> **Hint** "Lazy loaded" modules are **cached** upon the first `LazyModuleLoader#load` method invocation. That means, each consecutive attempt to load `LazyModule` will be **very fast** and will return a cached instance, instead of loading the module again.
>
> ```bash
>
> Load "LazyModule" attempt: 1
> time: 2.379ms
> Load "LazyModule" attempt: 2
> time: 0.294ms
> Load "LazyModule" attempt: 3
> time: 0.303ms
>
> ```
>
> Also, "lazy loaded" modules share the same modules graph as those eagerly loaded on the application bootstrap as well as any other lazy modules registered later in your app.

Where `lazy.module.ts` is a TypeScript file that exports a **regular Nest module** (no extra changes are required).

The `LazyModuleLoader#load` method returns the [module reference](https://docs.nestjs.com/fundamentals/module-ref) (of `LazyModule`) that lets you navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key.

For example, let's say we have a `LazyModule` with the following definition:

content\_copy

```typescript

@Module({
  providers: [LazyService],
  exports: [LazyService],
})
export class LazyModule {}

```

> **Hint** Lazy loaded modules cannot be registered as **global modules** as it simply makes no sense (since they are registered lazily, on-demand when all the statically registered modules have been already instantiated). Likewise, registered **global enhancers** (guards/interceptors/etc.) **will not work** properly either.

With this, we could obtain a reference to the `LazyService` provider, as follows:

content\_copy

```typescript

const { LazyModule } = await import('./lazy.module');
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule);

const { LazyService } = await import('./lazy.service');
const lazyService = moduleRef.get(LazyService);

```

> **Warning** If you use **Webpack**, make sure to update your `tsconfig.json` file - setting `compilerOptions.module` to `"esnext"` and adding `compilerOptions.moduleResolution` property with `"node"` as a value:
>
> ```json
>
> {
>   "compilerOptions": {
>     "module": "esnext",
>     "moduleResolution": "node",
>     ...
>   }
> }
>
> ```
>
> With these options set up, you'll be able to leverage the [code splitting](https://webpack.js.org/guides/code-splitting/) feature.

#### Lazy loading controllers, gateways, and resolvers [\#](https://docs.nestjs.com/fundamentals/lazy-loading-modules\#lazy-loading-controllers-gateways-and-resolvers)

Since controllers (or resolvers in GraphQL applications) in Nest represent sets of routes/paths/topics (or queries/mutations), you **cannot lazy load them** using the `LazyModuleLoader` class.

> **Warning** Controllers, [resolvers](https://docs.nestjs.com/graphql/resolvers), and [gateways](https://docs.nestjs.com/websockets/gateways) registered inside lazy loaded modules will not behave as expected. Similarly, you cannot register middleware functions (by implementing the `MiddlewareConsumer` interface) on-demand.

For example, let's say you're building a REST API (HTTP application) with a Fastify driver under the hood (using the `@nestjs/platform-fastify` package). Fastify does not let you register routes after the application is ready/successfully listening to messages. That means even if we analyzed route mappings registered in the module's controllers, all lazy loaded routes wouldn't be accessible since there is no way to register them at runtime.

Likewise, some transport strategies we provide as part of the `@nestjs/microservices` package (including Kafka, gRPC, or RabbitMQ) require to subscribe/listen to specific topics/channels before the connection is established. Once your application starts listening to messages, the framework would not be able to subscribe/listen to new topics.

Lastly, the `@nestjs/graphql` package with the code first approach enabled automatically generates the GraphQL schema on-the-fly based on the metadata. That means, it requires all classes to be loaded beforehand. Otherwise, it would not be doable to create the appropriate, valid schema.

#### Common use-cases [\#](https://docs.nestjs.com/fundamentals/lazy-loading-modules\#common-use-cases)

Most commonly, you will see lazy loaded modules in situations when your worker/cron job/lambda & serverless function/webhook must trigger different services (different logic) based on the input arguments (route path/date/query parameters, etc.). On the other hand, lazy loading modules may not make too much sense for monolithic applications, where the startup time is rather irrelevant.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS gRPC Guide
- [gRPC](https://docs.nestjs.com/microservices/grpc#grpc)
- [Installation](https://docs.nestjs.com/microservices/grpc#installation)
- [Overview](https://docs.nestjs.com/microservices/grpc#overview)
- [Options](https://docs.nestjs.com/microservices/grpc#options)
- [Sample gRPC service](https://docs.nestjs.com/microservices/grpc#sample-grpc-service)
- [Client](https://docs.nestjs.com/microservices/grpc#client)
- [Example](https://docs.nestjs.com/microservices/grpc#example)
- [gRPC Reflection](https://docs.nestjs.com/microservices/grpc#grpc-reflection)
- [gRPC Streaming](https://docs.nestjs.com/microservices/grpc#grpc-streaming)
- [Streaming sample](https://docs.nestjs.com/microservices/grpc#streaming-sample)
- [Subject strategy](https://docs.nestjs.com/microservices/grpc#subject-strategy)
- [Call stream handler](https://docs.nestjs.com/microservices/grpc#call-stream-handler)
- [Health checks](https://docs.nestjs.com/microservices/grpc#health-checks)
- [gRPC Metadata](https://docs.nestjs.com/microservices/grpc#grpc-metadata)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/grpc.md "Suggest Edits")

### gRPC

[gRPC](https://github.com/grpc/grpc-node) is a modern, open source, high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication.

Like many RPC systems, gRPC is based on the concept of defining a service in terms of functions (methods) that can be called remotely. For each method, you define the parameters and return types. Services, parameters, and return types are defined in `.proto` files using Google's open source language-neutral [protocol buffers](https://protobuf.dev/) mechanism.

With the gRPC transporter, Nest uses `.proto` files to dynamically bind clients and servers to make it easy to implement remote procedure calls, automatically serializing and deserializing structured data.

#### Installation [\#](https://docs.nestjs.com/microservices/grpc\#installation)

To start building gRPC-based microservices, first install the required packages:

```bash

$ npm i --save @grpc/grpc-js @grpc/proto-loader

```

#### Overview [\#](https://docs.nestjs.com/microservices/grpc\#overview)

Like other Nest microservices transport layer implementations, you select the gRPC transporter mechanism using the `transport` property of the options object passed to the `createMicroservice()` method. In the following example, we'll set up a hero service. The `options` property provides metadata about that service; its properties are described [below](https://docs.nestjs.com/microservices/grpc#options).

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.GRPC,
  options: {
    package: 'hero',
    protoPath: join(__dirname, 'hero/hero.proto'),
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.GRPC,
  options: {
    package: 'hero',
    protoPath: join(__dirname, 'hero/hero.proto'),
  },
});

```

> **Hint** The `join()` function is imported from the `path` package; the `Transport` enum is imported from the `@nestjs/microservices` package.

In the `nest-cli.json` file, we add the `assets` property that allows us to distribute non-TypeScript files, and `watchAssets` \- to turn on watching all non-TypeScript assets. In our case, we want `.proto` files to be automatically copied to the `dist` folder.

```json

{
  "compilerOptions": {
    "assets": ["**/*.proto"],
    "watchAssets": true
  }
}

```

#### Options [\#](https://docs.nestjs.com/microservices/grpc\#options)

The **gRPC** transporter options object exposes the properties described below.

|     |     |
| --- | --- |
| `package` | Protobuf package name (matches `package` setting from `.proto` file). Required |
| `protoPath` | Absolute (or relative to the root dir) path to the `.proto` file. Required |
| `url` | Connection url. String in the format `ip address/dns name:port` (for example, `'0.0.0.0:50051'` for a Docker server) defining the address/port on which the transporter establishes a connection. Optional. Defaults to `'localhost:5000'` |
| `protoLoader` | NPM package name for the utility to load `.proto` files. Optional. Defaults to `'@grpc/proto-loader'` |
| `loader` | `@grpc/proto-loader` options. These provide detailed control over the behavior of `.proto` files. Optional. See [here](https://github.com/grpc/grpc-node/blob/master/packages/proto-loader/README.md) for more details |
| `credentials` | Server credentials. Optional. [Read more here](https://grpc.io/grpc/node/grpc.ServerCredentials.html) |

#### Sample gRPC service [\#](https://docs.nestjs.com/microservices/grpc\#sample-grpc-service)

Let's define our sample gRPC service called `HeroesService`. In the above `options` object, the `protoPath` property sets a path to the `.proto` definitions file `hero.proto`. The `hero.proto` file is structured using [protocol buffers](https://developers.google.com/protocol-buffers). Here's what it looks like:

content\_copy

```typescript

// hero/hero.proto
syntax = "proto3";

package hero;

service HeroesService {
  rpc FindOne (HeroById) returns (Hero) {}
}

message HeroById {
  int32 id = 1;
}

message Hero {
  int32 id = 1;
  string name = 2;
}

```

Our `HeroesService` exposes a `FindOne()` method. This method expects an input argument of type `HeroById` and returns a `Hero` message (protocol buffers use `message` elements to define both parameter types and return types).

Next, we need to implement the service. To define a handler that fulfills this definition, we use the `@GrpcMethod()` decorator in a controller, as shown below. This decorator provides the metadata needed to declare a method as a gRPC service method.

> **Hint** The `@MessagePattern()` decorator ( [read more](https://docs.nestjs.com/microservices/basics#request-response)) introduced in previous microservices chapters is not used with gRPC-based microservices. The `@GrpcMethod()` decorator effectively takes its place for gRPC-based microservices.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesController {
  @GrpcMethod('HeroesService', 'FindOne')
  findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

```typescript

@Controller()
export class HeroesController {
  @GrpcMethod('HeroesService', 'FindOne')
  findOne(data, metadata, call) {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

> **Hint** The `@GrpcMethod()` decorator is imported from the `@nestjs/microservices` package, while `Metadata` and `ServerUnaryCall` from the `grpc` package.

The decorator shown above takes two arguments. The first is the service name (e.g., `'HeroesService'`), corresponding to the `HeroesService` service definition in `hero.proto`. The second (the string `'FindOne'`) corresponds to the `FindOne()` rpc method defined within `HeroesService` in the `hero.proto` file.

The `findOne()` handler method takes three arguments, the `data` passed from the caller, `metadata` that stores gRPC
request metadata and `call` to obtain the `GrpcCall` object properties such as `sendMetadata` for send metadata to client.

Both `@GrpcMethod()` decorator arguments are optional. If called without the second argument (e.g., `'FindOne'`), Nest will automatically associate the `.proto` file rpc method with the handler based on converting the handler name to upper camel case (e.g., the `findOne` handler is associated with the `FindOne` rpc call definition). This is shown below.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesController {
  @GrpcMethod('HeroesService')
  findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

```typescript

@Controller()
export class HeroesController {
  @GrpcMethod('HeroesService')
  findOne(data, metadata, call) {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

You can also omit the first `@GrpcMethod()` argument. In this case, Nest automatically associates the handler with the service definition from the proto definitions file based on the **class** name where the handler is defined. For example, in the following code, class `HeroesService` associates its handler methods with the `HeroesService` service definition in the `hero.proto` file based on the matching of the name `'HeroesService'`.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesService {
  @GrpcMethod()
  findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

```typescript

@Controller()
export class HeroesService {
  @GrpcMethod()
  findOne(data, metadata, call) {
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];
    return items.find(({ id }) => id === data.id);
  }
}

```

#### Client [\#](https://docs.nestjs.com/microservices/grpc\#client)

Nest applications can act as gRPC clients, consuming services defined in `.proto` files. You access remote services through a `ClientGrpc` object. You can obtain a `ClientGrpc` object in several ways.

The preferred technique is to import the `ClientsModule`. Use the `register()` method to bind a package of services defined in a `.proto` file to an injection token, and to configure the service. The `name` property is the injection token. For gRPC services, use `transport: Transport.GRPC`. The `options` property is an object with the same properties described [above](https://docs.nestjs.com/microservices/grpc#options).

content\_copy

```typescript

imports: [\
  ClientsModule.register([\
    {\
      name: 'HERO_PACKAGE',\
      transport: Transport.GRPC,\
      options: {\
        package: 'hero',\
        protoPath: join(__dirname, 'hero/hero.proto'),\
      },\
    },\
  ]),\
];

```

> **Hint** The `register()` method takes an array of objects. Register multiple packages by providing a comma separated list of registration objects.

Once registered, we can inject the configured `ClientGrpc` object with `@Inject()`. Then we use the `ClientGrpc` object's `getService()` method to retrieve the service instance, as shown below.

content\_copy

```typescript

@Injectable()
export class AppService implements OnModuleInit {
  private heroesService: HeroesService;

  constructor(@Inject('HERO_PACKAGE') private client: ClientGrpc) {}

  onModuleInit() {
    this.heroesService = this.client.getService<HeroesService>('HeroesService');
  }

  getHero(): Observable<string> {
    return this.heroesService.findOne({ id: 1 });
  }
}

```

> **Warning** gRPC Client will not send fields that contain underscore `_` in their names unless the `keepCase` options is set to `true` in the proto loader configuration ( `options.loader.keepcase` in the microservice transporter configuration).

Notice that there is a small difference compared to the technique used in other microservice transport methods. Instead of the `ClientProxy` class, we use the `ClientGrpc` class, which provides the `getService()` method. The `getService()` generic method takes a service name as an argument and returns its instance (if available).

Alternatively, you can use the `@Client()` decorator to instantiate a `ClientGrpc` object, as follows:

content\_copy

```typescript

@Injectable()
export class AppService implements OnModuleInit {
  @Client({
    transport: Transport.GRPC,
    options: {
      package: 'hero',
      protoPath: join(__dirname, 'hero/hero.proto'),
    },
  })
  client: ClientGrpc;

  private heroesService: HeroesService;

  onModuleInit() {
    this.heroesService = this.client.getService<HeroesService>('HeroesService');
  }

  getHero(): Observable<string> {
    return this.heroesService.findOne({ id: 1 });
  }
}

```

Finally, for more complex scenarios, we can inject a dynamically configured client using the `ClientProxyFactory` class as described [here](https://docs.nestjs.com/microservices/basics#client).

In either case, we end up with a reference to our `HeroesService` proxy object, which exposes the same set of methods that are defined inside the `.proto` file. Now, when we access this proxy object (i.e., `heroesService`), the gRPC system automatically serializes requests, forwards them to the remote system, returns a response, and deserializes the response. Because gRPC shields us from these network communication details, `heroesService` looks and acts like a local provider.

Note, all service methods are **lower camel cased** (in order to follow the natural convention of the language). So, for example, while our `.proto` file `HeroesService` definition contains the `FindOne()` function, the `heroesService` instance will provide the `findOne()` method.

content\_copy

```typescript

interface HeroesService {
  findOne(data: { id: number }): Observable<any>;
}

```

A message handler is also able to return an `Observable`, in which case the result values will be emitted until the stream is completed.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Get()
call(): Observable<any> {
  return this.heroesService.findOne({ id: 1 });
}

```

```typescript

@Get()
call() {
  return this.heroesService.findOne({ id: 1 });
}

```

To send gRPC metadata (along with the request), you can pass a second argument, as follows:

content\_copy

```typescript

call(): Observable<any> {
  const metadata = new Metadata();
  metadata.add('Set-Cookie', 'yummy_cookie=choco');

  return this.heroesService.findOne({ id: 1 }, metadata);
}

```

> **Hint** The `Metadata` class is imported from the `grpc` package.

Please note that this would require updating the `HeroesService` interface that we've defined a few steps earlier.

#### Example [\#](https://docs.nestjs.com/microservices/grpc\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/04-grpc).

#### gRPC Reflection [\#](https://docs.nestjs.com/microservices/grpc\#grpc-reflection)

The [gRPC Server Reflection Specification](https://grpc.io/docs/guides/reflection/#overview) is a standard which allows gRPC clients to request details about the API that the server exposes, akin to exposing an OpenAPI document for a REST API. This can make working with developer debugging tools such as grpc-ui or postman significantly easier.

To add gRPC reflection support to your server, first install the required implementation package:

```bash

$ npm i --save @grpc/reflection

```

Then it can be hooked into the gRPC server using the `onLoadPackageDefinition` hook in your gRPC server options, as follows:

content\_copy main.ts

JS  TS

```typescript

import { ReflectionService } from '@grpc/reflection';

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  options: {
    onLoadPackageDefinition: (pkg, server) => {
      new ReflectionService(pkg).addToServer(server);
    },
  },
});

```

Now your server will respond to messages requesting API details using the reflection specification.

#### gRPC Streaming [\#](https://docs.nestjs.com/microservices/grpc\#grpc-streaming)

gRPC on its own supports long-term live connections, conventionally known as `streams`. Streams are useful for cases such as Chatting, Observations or Chunk-data transfers. Find more details in the official documentation [here](https://grpc.io/docs/guides/concepts/).

Nest supports GRPC stream handlers in two possible ways:

- RxJS `Subject` \+ `Observable` handler: can be useful to write responses right inside of a Controller method or to be passed down to `Subject`/ `Observable` consumer
- Pure GRPC call stream handler: can be useful to be passed to some executor which will handle the rest of dispatch for the Node standard `Duplex` stream handler.

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Streaming sample [\#](https://docs.nestjs.com/microservices/grpc\#streaming-sample)

Let's define a new sample gRPC service called `HelloService`. The `hello.proto` file is structured using [protocol buffers](https://developers.google.com/protocol-buffers). Here's what it looks like:

content\_copy

```typescript

// hello/hello.proto
syntax = "proto3";

package hello;

service HelloService {
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}

```

> **Hint** The `LotsOfGreetings` method can be simply implemented with the `@GrpcMethod` decorator (as in the examples above) since the returned stream can emit multiple values.

Based on this `.proto` file, let's define the `HelloService` interface:

content\_copy

```typescript

interface HelloService {
  bidiHello(upstream: Observable<HelloRequest>): Observable<HelloResponse>;
  lotsOfGreetings(
    upstream: Observable<HelloRequest>,
  ): Observable<HelloResponse>;
}

interface HelloRequest {
  greeting: string;
}

interface HelloResponse {
  reply: string;
}

```

> **Hint** The proto interface can be automatically generated by the [ts-proto](https://github.com/stephenh/ts-proto) package, learn more [here](https://github.com/stephenh/ts-proto/blob/main/NESTJS.markdown).

#### Subject strategy [\#](https://docs.nestjs.com/microservices/grpc\#subject-strategy)

The `@GrpcStreamMethod()` decorator provides the function parameter as an RxJS `Observable`. Thus, we can receive and process multiple messages.

content\_copy

```typescript

@GrpcStreamMethod()
bidiHello(messages: Observable<any>, metadata: Metadata, call: ServerDuplexStream<any, any>): Observable<any> {
  const subject = new Subject();

  const onNext = message => {
    console.log(message);
    subject.next({
      reply: 'Hello, world!'
    });
  };
  const onComplete = () => subject.complete();
  messages.subscribe({
    next: onNext,
    complete: onComplete,
  });

  return subject.asObservable();
}

```

> **Warning** For supporting full-duplex interaction with the `@GrpcStreamMethod()` decorator, the controller method must return an RxJS `Observable`.

> **Hint** The `Metadata` and `ServerUnaryCall` classes/interfaces are imported from the `grpc` package.

According to the service definition (in the `.proto` file), the `BidiHello` method should stream requests to the service. To send multiple asynchronous messages to the stream from a client, we leverage an RxJS `ReplaySubject` class.

content\_copy

```typescript

const helloService = this.client.getService<HelloService>('HelloService');
const helloRequest$ = new ReplaySubject<HelloRequest>();

helloRequest$.next({ greeting: 'Hello (1)!' });
helloRequest$.next({ greeting: 'Hello (2)!' });
helloRequest$.complete();

return helloService.bidiHello(helloRequest$);

```

In the example above, we wrote two messages to the stream ( `next()` calls) and notified the service that we've completed sending the data ( `complete()` call).

#### Call stream handler [\#](https://docs.nestjs.com/microservices/grpc\#call-stream-handler)

When the method return value is defined as `stream`, the `@GrpcStreamCall()` decorator provides the function parameter as `grpc.ServerDuplexStream`, which supports standard methods like `.on('data', callback)`, `.write(message)` or `.cancel()`. Full documentation on available methods can be found [here](https://grpc.github.io/grpc/node/grpc-ClientDuplexStream.html).

Alternatively, when the method return value is not a `stream`, the `@GrpcStreamCall()` decorator provides two function parameters, respectively `grpc.ServerReadableStream` (read more [here](https://grpc.github.io/grpc/node/grpc-ServerReadableStream.html)) and `callback`.

Let's start with implementing the `BidiHello` which should support a full-duplex interaction.

content\_copy

```typescript

@GrpcStreamCall()
bidiHello(requestStream: any) {
  requestStream.on('data', message => {
    console.log(message);
    requestStream.write({
      reply: 'Hello, world!'
    });
  });
}

```

> **Hint** This decorator does not require any specific return parameter to be provided. It is expected that the stream will be handled similar to any other standard stream type.

In the example above, we used the `write()` method to write objects to the response stream. The callback passed into the `.on()` method as a second parameter will be called every time our service receives a new chunk of data.

Let's implement the `LotsOfGreetings` method.

content\_copy

```typescript

@GrpcStreamCall()
lotsOfGreetings(requestStream: any, callback: (err: unknown, value: HelloResponse) => void) {
  requestStream.on('data', message => {
    console.log(message);
  });
  requestStream.on('end', () => callback(null, { reply: 'Hello, world!' }));
}

```

Here we used the `callback` function to send the response once processing of the `requestStream` has been completed.

#### Health checks [\#](https://docs.nestjs.com/microservices/grpc\#health-checks)

When running a gRPC application in an orchestrator such a Kubernetes, you may need to know if it is running and in a healthy state. The [gRPC Health Check specification](https://grpc.io/docs/guides/health-checking/) is a standard that allow gRPC clients to expose their health status to allow the orchestrator to act accordingly.

To add gRPC health check support, first install the [grpc-node](https://github.com/grpc/grpc-node/tree/master/packages/grpc-health-check) package:

```bash

$ npm i --save grpc-health-check

```

Then it can be hooked into the gRPC service using the `onLoadPackageDefinition` hook in your gRPC server options, as follows. Note that the `protoPath` needs to have both the health check and the hero package.

content\_copy main.ts

JS  TS

```typescript

import { HealthImplementation, protoPath as healthCheckProtoPath } from 'grpc-health-check';

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  options: {
    protoPath: [\
      healthCheckProtoPath,\
      protoPath: join(__dirname, 'hero/hero.proto'),\
    ],
    onLoadPackageDefinition: (pkg, server) => {
      const healthImpl = new HealthImplementation({
        '': 'UNKNOWN',
      });

      healthImpl.addToServer(server);
      healthImpl.setStatus('', 'SERVING');
    },
  },
});

```

> **Hint** The [gRPC health probe](https://github.com/grpc-ecosystem/grpc-health-probe) is a useful CLI to test gRPC health checks in a containerized environment.

#### gRPC Metadata [\#](https://docs.nestjs.com/microservices/grpc\#grpc-metadata)

Metadata is information about a particular RPC call in the form of a list of key-value pairs, where the keys are strings and the values are typically strings but can be binary data. Metadata is opaque to gRPC itself - it lets the client provide information associated with the call to the server and vice versa. Metadata may include authentication tokens, request identifiers and tags for monitoring purposes, and data information such as the number of records in a data set.

To read the metadata in `@GrpcMethod()` handler, use the second argument (metadata), which is of type `Metadata` (imported from the `grpc` package).

To send back metadata from the handler, use the `ServerUnaryCall#sendMetadata()` method (third handler argument).

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesService {
  @GrpcMethod()
  findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {
    const serverMetadata = new Metadata();
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];

    serverMetadata.add('Set-Cookie', 'yummy_cookie=choco');
    call.sendMetadata(serverMetadata);

    return items.find(({ id }) => id === data.id);
  }
}

```

```typescript

@Controller()
export class HeroesService {
  @GrpcMethod()
  findOne(data, metadata, call) {
    const serverMetadata = new Metadata();
    const items = [\
      { id: 1, name: 'John' },\
      { id: 2, name: 'Doe' },\
    ];

    serverMetadata.add('Set-Cookie', 'yummy_cookie=choco');
    call.sendMetadata(serverMetadata);

    return items.find(({ id }) => id === data.id);
  }
}

```

Likewise, to read the metadata in handlers annotated with the `@GrpcStreamMethod()` handler ( [subject strategy](https://docs.nestjs.com/microservices/grpc#subject-strategy)), use the second argument (metadata), which is of type `Metadata` (imported from the `grpc` package).

To send back metadata from the handler, use the `ServerDuplexStream#sendMetadata()` method (third handler argument).

To read metadata from within the [call stream handlers](https://docs.nestjs.com/microservices/grpc#call-stream-handler) (handlers annotated with `@GrpcStreamCall()` decorator), listen to the `metadata` event on the `requestStream` reference, as follows:

content\_copy

```typescript

requestStream.on('metadata', (metadata: Metadata) => {
  const meta = metadata.get('X-Meta');
});

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Lifecycle Events
- [Lifecycle Events](https://docs.nestjs.com/fundamentals/lifecycle-events#lifecycle-events)
- [Lifecycle sequence](https://docs.nestjs.com/fundamentals/lifecycle-events#lifecycle-sequence)
- [Lifecycle events](https://docs.nestjs.com/fundamentals/lifecycle-events#lifecycle-events-1)
- [Usage](https://docs.nestjs.com/fundamentals/lifecycle-events#usage)
- [Asynchronous initialization](https://docs.nestjs.com/fundamentals/lifecycle-events#asynchronous-initialization)
- [Application shutdown](https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/lifecycle-events.md "Suggest Edits")

### Lifecycle Events

A Nest application, as well as every application element, has a lifecycle managed by Nest. Nest provides **lifecycle hooks** that give visibility into key lifecycle events, and the ability to act (run registered code on your modules, providers or controllers) when they occur.

#### Lifecycle sequence [\#](https://docs.nestjs.com/fundamentals/lifecycle-events\#lifecycle-sequence)

The following diagram depicts the sequence of key application lifecycle events, from the time the application is bootstrapped until the node process exits. We can divide the overall lifecycle into three phases: **initializing**, **running** and **terminating**. Using this lifecycle, you can plan for appropriate initialization of modules and services, manage active connections, and gracefully shutdown your application when it receives a termination signal.

![](https://docs.nestjs.com/assets/lifecycle-events.png)

#### Lifecycle events [\#](https://docs.nestjs.com/fundamentals/lifecycle-events\#lifecycle-events-1)

Lifecycle events happen during application bootstrapping and shutdown. Nest calls registered lifecycle hook methods on modules, providers and controllers at each of the following lifecycle events ( **shutdown hooks** need to be enabled first, as described [below](https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown)). As shown in the diagram above, Nest also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections.

In the following table, `onModuleInit` and `onApplicationBootstrap` are only triggered if you explicitly call `app.init()` or `app.listen()`.

In the following table, `onModuleDestroy`, `beforeApplicationShutdown` and `onApplicationShutdown` are only triggered if you explicitly call `app.close()` or if the process receives a special system signal (such as SIGTERM) and you have correctly called `enableShutdownHooks` at application bootstrap (see below **Application shutdown** part).

| Lifecycle hook method | Lifecycle event triggering the hook method call |
| --- | --- |
| `onModuleInit()` | Called once the host module's dependencies have been resolved. |
| `onApplicationBootstrap()` | Called once all modules have been initialized, but before listening for connections. |
| `onModuleDestroy()`\* | Called after a termination signal (e.g., `SIGTERM`) has been received. |
| `beforeApplicationShutdown()`\* | Called after all `onModuleDestroy()` handlers have completed (Promises resolved or rejected);<br>once complete (Promises resolved or rejected), all existing connections will be closed ( `app.close()` called). |
| `onApplicationShutdown()`\* | Called after connections close ( `app.close()` resolves). |

\\* For these events, if you're not calling `app.close()` explicitly, you must opt-in to make them work with system signals such as `SIGTERM`. See [Application shutdown](https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown) below.

> **Warning** The lifecycle hooks listed above are not triggered for **request-scoped** classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and automatically garbage-collected after the response is sent.

> **Hint** Execution order of `onModuleInit()` and `onApplicationBootstrap()` directly depends on the order of module imports, awaiting the previous hook.

#### Usage [\#](https://docs.nestjs.com/fundamentals/lifecycle-events\#usage)

Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it's good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called during module initialization on a particular class (e.g., Controller, Provider or Module), implement the `OnModuleInit` interface by supplying an `onModuleInit()` method, as shown below:

content\_copy

JS  TS

```typescript

import { Injectable, OnModuleInit } from '@nestjs/common';

@Injectable()
export class UsersService implements OnModuleInit {
  onModuleInit() {
    console.log(`The module has been initialized.`);
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  onModuleInit() {
    console.log(`The module has been initialized.`);
  }
}

```

#### Asynchronous initialization [\#](https://docs.nestjs.com/fundamentals/lifecycle-events\#asynchronous-initialization)

Both the `OnModuleInit` and `OnApplicationBootstrap` hooks allow you to defer the application initialization process (return a `Promise` or mark the method as `async` and `await` an asynchronous method completion in the method body).

content\_copy

JS  TS

```typescript

async onModuleInit(): Promise<void> {
  await this.fetch();
}

```

```typescript

async onModuleInit() {
  await this.fetch();
}

```

#### Application shutdown [\#](https://docs.nestjs.com/fundamentals/lifecycle-events\#application-shutdown)

The `onModuleDestroy()`, `beforeApplicationShutdown()` and `onApplicationShutdown()` hooks are called in the terminating phase (in response to an explicit call to `app.close()` or upon receipt of system signals such as SIGTERM if opted-in). This feature is often used with [Kubernetes](https://kubernetes.io/) to manage containers' lifecycles, by [Heroku](https://www.heroku.com/) for dynos or similar services.

Shutdown hook listeners consume system resources, so they are disabled by default. To use shutdown hooks, you **must enable listeners** by calling `enableShutdownHooks()`:

content\_copy

```typescript

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Starts listening for shutdown hooks
  app.enableShutdownHooks();

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

> **warning** Due to inherent platform limitations, NestJS has limited support for application shutdown hooks on Windows. You can expect `SIGINT` to work, as well as `SIGBREAK` and to some extent `SIGHUP` \- [read more](https://nodejs.org/api/process.html#process_signal_events). However `SIGTERM` will never work on Windows because killing a process in the task manager is unconditional, "i.e., there's no way for an application to detect or prevent it". Here's some [relevant documentation](https://docs.libuv.org/en/v1.x/signal.html) from libuv to learn more about how `SIGINT`, `SIGBREAK` and others are handled on Windows. Also, see Node.js documentation of [Process Signal Events](https://nodejs.org/api/process.html#process_signal_events)

> **Info** `enableShutdownHooks` consumes memory by starting listeners. In cases where you are running multiple Nest apps in a single Node process (e.g., when running parallel tests with Jest), Node may complain about excessive listener processes. For this reason, `enableShutdownHooks` is not enabled by default. Be aware of this condition when you are running multiple instances in a single Node process.

When the application receives a termination signal it will call any registered `onModuleDestroy()`, `beforeApplicationShutdown()`, then `onApplicationShutdown()` methods (in the sequence described above) with the corresponding signal as the first parameter. If a registered function awaits an asynchronous call (returns a promise), Nest will not continue in the sequence until the promise is resolved or rejected.

content\_copy

JS  TS

```typescript

@Injectable()
class UsersService implements OnApplicationShutdown {
  onApplicationShutdown(signal: string) {
    console.log(signal); // e.g. "SIGINT"
  }
}

```

```typescript

@Injectable()
class UsersService implements OnApplicationShutdown {
  onApplicationShutdown(signal) {
    console.log(signal); // e.g. "SIGINT"
  }
}

```

> **Info** Calling `app.close()` doesn't terminate the Node process but only triggers the `onModuleDestroy()` and `onApplicationShutdown()` hooks, so if there are some intervals, long-running background tasks, etc. the process won't be automatically terminated.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS CLI Commands
- [CLI command reference](https://docs.nestjs.com/cli/usages#cli-command-reference)
- [nest new](https://docs.nestjs.com/cli/usages#nest-new)
- [nest generate](https://docs.nestjs.com/cli/usages#nest-generate)
- [nest build](https://docs.nestjs.com/cli/usages#nest-build)
- [nest start](https://docs.nestjs.com/cli/usages#nest-start)
- [nest add](https://docs.nestjs.com/cli/usages#nest-add)
- [nest info](https://docs.nestjs.com/cli/usages#nest-info)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/cli/usages.md "Suggest Edits")

### CLI command reference

#### nest new [\#](https://docs.nestjs.com/cli/usages\#nest-new)

Creates a new (standard mode) Nest project.

```bash

$ nest new <name> [options]
$ nest n <name> [options]

```

##### Description

Creates and initializes a new Nest project. Prompts for package manager.

- Creates a folder with the given `<name>`
- Populates the folder with configuration files
- Creates sub-folders for source code ( `/src`) and end-to-end tests ( `/test`)
- Populates the sub-folders with default files for app components and tests

##### Arguments

| Argument | Description |
| --- | --- |
| `<name>` | The name of the new project |

##### Options

| Option | Description |
| --- | --- |
| `--dry-run` | Reports changes that would be made, but does not change the filesystem.<br> Alias: `-d` |
| `--skip-git` | Skip git repository initialization.<br> Alias: `-g` |
| `--skip-install` | Skip package installation.<br> Alias: `-s` |
| `--package-manager [package-manager]` | Specify package manager. Use `npm`, `yarn`, or `pnpm`. Package manager must be installed globally.<br> Alias: `-p` |
| `--language [language]` | Specify programming language ( `TS` or `JS`).<br> Alias: `-l` |
| `--collection [collectionName]` | Specify schematics collection. Use package name of installed npm package containing schematic.<br> Alias: `-c` |
| `--strict` | Start the project with the following TypeScript compiler flags enabled: `strictNullChecks`, `noImplicitAny`, `strictBindCallApply`, `forceConsistentCasingInFileNames`, `noFallthroughCasesInSwitch` |

#### nest generate [\#](https://docs.nestjs.com/cli/usages\#nest-generate)

Generates and/or modifies files based on a schematic

```bash

$ nest generate <schematic> <name> [options]
$ nest g <schematic> <name> [options]

```

##### Arguments

| Argument | Description |
| --- | --- |
| `<schematic>` | The `schematic` or `collection:schematic` to generate. See the table below for the available schematics. |
| `<name>` | The name of the generated component. |

##### Schematics

| Name | Alias | Description |
| --- | --- | --- |
| `app` |  | Generate a new application within a monorepo (converting to monorepo if it's a standard structure). |
| `library` | `lib` | Generate a new library within a monorepo (converting to monorepo if it's a standard structure). |
| `class` | `cl` | Generate a new class. |
| `controller` | `co` | Generate a controller declaration. |
| `decorator` | `d` | Generate a custom decorator. |
| `filter` | `f` | Generate a filter declaration. |
| `gateway` | `ga` | Generate a gateway declaration. |
| `guard` | `gu` | Generate a guard declaration. |
| `interface` | `itf` | Generate an interface. |
| `interceptor` | `itc` | Generate an interceptor declaration. |
| `middleware` | `mi` | Generate a middleware declaration. |
| `module` | `mo` | Generate a module declaration. |
| `pipe` | `pi` | Generate a pipe declaration. |
| `provider` | `pr` | Generate a provider declaration. |
| `resolver` | `r` | Generate a resolver declaration. |
| `resource` | `res` | Generate a new CRUD resource. See the [CRUD (resource) generator](https://docs.nestjs.com/recipes/crud-generator) for more details. (TS only) |
| `service` | `s` | Generate a service declaration. |

##### Options

| Option | Description |
| --- | --- |
| `--dry-run` | Reports changes that would be made, but does not change the filesystem.<br> Alias: `-d` |
| `--project [project]` | Project that element should be added to.<br> Alias: `-p` |
| `--flat` | Do not generate a folder for the element. |
| `--collection [collectionName]` | Specify schematics collection. Use package name of installed npm package containing schematic.<br> Alias: `-c` |
| `--spec` | Enforce spec files generation (default) |
| `--no-spec` | Disable spec files generation |

#### nest build [\#](https://docs.nestjs.com/cli/usages\#nest-build)

Compiles an application or workspace into an output folder.

Also, the `build` command is responsible for:

- mapping paths (if using path aliases) via `tsconfig-paths`
- annotating DTOs with OpenAPI decorators (if `@nestjs/swagger` CLI plugin is enabled)
- annotating DTOs with GraphQL decorators (if `@nestjs/graphql` CLI plugin is enabled)

```bash

$ nest build <name> [options]

```

##### Arguments

| Argument | Description |
| --- | --- |
| `<name>` | The name of the project to build. |

##### Options

| Option | Description |
| --- | --- |
| `--path [path]` | Path to `tsconfig` file. <br>Alias `-p` |
| `--config [path]` | Path to `nest-cli` configuration file. <br>Alias `-c` |
| `--watch` | Run in watch mode (live-reload).<br> If you're using `tsc` for compilation, you can type `rs` to restart the application (when `manualRestart` option is set to `true`). <br>Alias `-w` |
| `--builder [name]` | Specify the builder to use for compilation ( `tsc`, `swc`, or `webpack`). <br>Alias `-b` |
| `--webpack` | Use webpack for compilation (deprecated: use `--builder webpack` instead). |
| `--webpackPath` | Path to webpack configuration. |
| `--tsc` | Force use `tsc` for compilation. |
| `--watchAssets` | Watch non-TS files (assets like `.graphql` etc.). See [Assets](https://docs.nestjs.com/cli/monorepo#assets) for more details. |
| `--type-check` | Enable type checking (when SWC is used). |
| `--all` | Build all projects in a monorepo. |
| `--preserveWatchOutput` | Keep outdated console output in watch mode instead of clearing the screen. ( `tsc` watch mode only) |

#### nest start [\#](https://docs.nestjs.com/cli/usages\#nest-start)

Compiles and runs an application (or default project in a workspace).

```bash

$ nest start <name> [options]

```

##### Arguments

| Argument | Description |
| --- | --- |
| `<name>` | The name of the project to run. |

##### Options

| Option | Description |
| --- | --- |
| `--path [path]` | Path to `tsconfig` file. <br>Alias `-p` |
| `--config [path]` | Path to `nest-cli` configuration file. <br>Alias `-c` |
| `--watch` | Run in watch mode (live-reload) <br>Alias `-w` |
| `--builder [name]` | Specify the builder to use for compilation ( `tsc`, `swc`, or `webpack`). <br>Alias `-b` |
| `--preserveWatchOutput` | Keep outdated console output in watch mode instead of clearing the screen. ( `tsc` watch mode only) |
| `--watchAssets` | Run in watch mode (live-reload), watching non-TS files (assets). See [Assets](https://docs.nestjs.com/cli/monorepo#assets) for more details. |
| `--debug [hostport]` | Run in debug mode (with --inspect flag) <br>Alias `-d` |
| `--webpack` | Use webpack for compilation. (deprecated: use `--builder webpack` instead) |
| `--webpackPath` | Path to webpack configuration. |
| `--tsc` | Force use `tsc` for compilation. |
| `--exec [binary]` | Binary to run (default: `node`). <br>Alias `-e` |
| `--no-shell` | Do not spawn child processes within a shell (see node's `child_process.spawn()` method docs). |
| `--env-file` | Loads environment variables from a file relative to the current directory, making them available to applications on `process.env`. |
| `-- [key=value]` | Command-line arguments that can be referenced with `process.argv`. |

#### nest add [\#](https://docs.nestjs.com/cli/usages\#nest-add)

Imports a library that has been packaged as a **nest library**, running its install schematic.

```bash

$ nest add <name> [options]

```

##### Arguments

| Argument | Description |
| --- | --- |
| `<name>` | The name of the library to import. |

#### nest info [\#](https://docs.nestjs.com/cli/usages\#nest-info)

Displays information about installed nest packages and other helpful system info. For example:

```bash

$ nest info

```

```bash

 _   _             _      ___  _____  _____  _     _____
| \ | |           | |    |_  |/  ___|/  __ \| |   |_   _|
|  \| |  ___  ___ | |_     | |\ `--. | /  \/| |     | |
| . ` | / _ \/ __|| __|    | | `--. \| |    | |     | |
| |\  ||  __/\__ \| |_ /\__/ //\__/ /| \__/\| |_____| |_
\_| \_/ \___||___/ \__|\____/ \____/  \____/\_____/\___/

[System Information]
OS Version : macOS High Sierra
NodeJS Version : v20.18.0
[Nest Information]
microservices version : 10.0.0
websockets version : 10.0.0
testing version : 10.0.0
common version : 10.0.0
core version : 10.0.0

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Keep-Alive Connections
- [Keep alive connections](https://docs.nestjs.com/faq/keep-alive-connections#keep-alive-connections)
- [Usage](https://docs.nestjs.com/faq/keep-alive-connections#usage)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/keep-alive-connections.md "Suggest Edits")

### Keep alive connections

By default, the HTTP adapters of NestJS will wait until the response is finished before closing the application. But sometimes, this behavior is not desired, or unexpected. There might be some requests that use `Connection: Keep-Alive` headers that live for a long time.

For these scenarios where you always want your application to exit without waiting for requests to end, you can enable the `forceCloseConnections` option when creating your NestJS application.

> **Tip** Most users will not need to enable this option. But the symptom of needing this option is that your application will not exit when you expect it to. Usually when `app.enableShutdownHooks()` is enabled and you notice that the application is not restarting/exiting. Most likely while running the NestJS application during development with `--watch`.

#### Usage [\#](https://docs.nestjs.com/faq/keep-alive-connections\#usage)

In your `main.ts` file, enable the option when creating your NestJS application:

content\_copy

```typescript

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    forceCloseConnections: true,
  });
  await app.listen(process.env.PORT ?? 3000);
}

bootstrap();

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Prisma with NestJS
- [Prisma](https://docs.nestjs.com/recipes/prisma#prisma)
- [Getting started](https://docs.nestjs.com/recipes/prisma#getting-started)
- [Create your NestJS project](https://docs.nestjs.com/recipes/prisma#create-your-nestjs-project)
- [Set up Prisma](https://docs.nestjs.com/recipes/prisma#set-up-prisma)
- [Set the database connection](https://docs.nestjs.com/recipes/prisma#set-the-database-connection)
- [Create two database tables with Prisma Migrate](https://docs.nestjs.com/recipes/prisma#create-two-database-tables-with-prisma-migrate)
- [Install and generate Prisma Client](https://docs.nestjs.com/recipes/prisma#install-and-generate-prisma-client)
- [Use Prisma Client in your NestJS services](https://docs.nestjs.com/recipes/prisma#use-prisma-client-in-your-nestjs-services)
- [Summary](https://docs.nestjs.com/recipes/prisma#summary)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/prisma.md "Suggest Edits")

### Prisma

[Prisma](https://www.prisma.io/) is an [open-source](https://github.com/prisma/prisma) ORM for Node.js and TypeScript. It is used as an **alternative** to writing plain SQL, or using another database access tool such as SQL query builders (like [knex.js](https://knexjs.org/)) or ORMs (like [TypeORM](https://typeorm.io/) and [Sequelize](https://sequelize.org/)). Prisma currently supports PostgreSQL, MySQL, SQL Server, SQLite, MongoDB and CockroachDB ( [Preview](https://www.prisma.io/docs/reference/database-reference/supported-databases)).

While Prisma can be used with plain JavaScript, it embraces TypeScript and provides a level to type-safety that goes beyond the guarantees other ORMs in the TypeScript ecosystem. You can find an in-depth comparison of the type-safety guarantees of Prisma and TypeORM [here](https://www.prisma.io/docs/concepts/more/comparisons/prisma-and-typeorm#type-safety).

> **Note** If you want to get a quick overview of how Prisma works, you can follow the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart) or read the [Introduction](https://www.prisma.io/docs/understand-prisma/introduction) in the [documentation](https://www.prisma.io/docs/). There also are ready-to-run examples for [REST](https://github.com/prisma/prisma-examples/tree/b53fad046a6d55f0090ddce9fd17ec3f9b95cab3/orm/nest) and [GraphQL](https://github.com/prisma/prisma-examples/tree/b53fad046a6d55f0090ddce9fd17ec3f9b95cab3/orm/nest-graphql) in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repo.

#### Getting started [\#](https://docs.nestjs.com/recipes/prisma\#getting-started)

In this recipe, you'll learn how to get started with NestJS and Prisma from scratch. You are going to build a sample NestJS application with a REST API that can read and write data in a database.

For the purpose of this guide, you'll use a [SQLite](https://sqlite.org/) database to save the overhead of setting up a database server. Note that you can still follow this guide, even if you're using PostgreSQL or MySQL – you'll get extra instructions for using these databases at the right places.

> **Note** If you already have an existing project and consider migrating to Prisma, you can follow the guide for [adding Prisma to an existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project-typescript-postgres). If you are migrating from TypeORM, you can read the guide [Migrating from TypeORM to Prisma](https://www.prisma.io/docs/guides/migrate-to-prisma/migrate-from-typeorm).

#### Create your NestJS project [\#](https://docs.nestjs.com/recipes/prisma\#create-your-nestjs-project)

To get started, install the NestJS CLI and create your app skeleton with the following commands:

```bash

$ npm install -g @nestjs/cli
$ nest new hello-prisma

```

See the [First steps](https://docs.nestjs.com/first-steps) page to learn more about the project files created by this command. Note also that you can now run `npm start` to start your application. The REST API running at `http://localhost:3000/` currently serves a single route that's implemented in `src/app.controller.ts`. Over the course of this guide, you'll implement additional routes to store and retrieve data about _users_ and _posts_.

#### Set up Prisma [\#](https://docs.nestjs.com/recipes/prisma\#set-up-prisma)

Start by installing the Prisma CLI as a development dependency in your project:

```bash

$ cd hello-prisma
$ npm install prisma --save-dev

```

In the following steps, we'll be utilizing the [Prisma CLI](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-cli). As a best practice, it's recommended to invoke the CLI locally by prefixing it with `npx`:

```bash

$ npx prisma

```

Expand if you're using Yarn

If you're using Yarn, then you can install the Prisma CLI as follows:

```bash

$ yarn add prisma --dev

```

Once installed, you can invoke it by prefixing it with `yarn`:

```bash

$ yarn prisma

```

Now create your initial Prisma setup using the `init` command of the Prisma CLI:

```bash

$ npx prisma init

```

This command creates a new `prisma` directory with the following contents:

- `schema.prisma`: Specifies your database connection and contains the database schema
- `.env`: A [dotenv](https://github.com/motdotla/dotenv) file, typically used to store your database credentials in a group of environment variables

#### Set the database connection [\#](https://docs.nestjs.com/recipes/prisma\#set-the-database-connection)

Your database connection is configured in the `datasource` block in your `schema.prisma` file. By default it's set to `postgresql`, but since you're using a SQLite database in this guide you need to adjust the `provider` field of the `datasource` block to `sqlite`:

```groovy

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

```

Now, open up `.env` and adjust the `DATABASE_URL` environment variable to look as follows:

```bash

DATABASE_URL="file:./dev.db"

```

Make sure you have a [ConfigModule](https://docs.nestjs.com/techniques/configuration) configured, otherwise the `DATABASE_URL` variable will not be picked up from `.env`.

SQLite databases are simple files; no server is required to use a SQLite database. So instead of configuring a connection URL with a _host_ and _port_, you can just point it to a local file which in this case is called `dev.db`. This file will be created in the next step.

Expand if you're using PostgreSQL, MySQL, MsSQL or Azure SQL

With PostgreSQL and MySQL, you need to configure the connection URL to point to the _database server_. You can learn more about the required connection URL format [here](https://www.prisma.io/docs/reference/database-reference/connection-urls).

**PostgreSQL**

If you're using PostgreSQL, you have to adjust the `schema.prisma` and `.env` files as follows:

**`schema.prisma`**

```groovy

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

```

**`.env`**

```bash

DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA"

```

Replace the placeholders spelled in all uppercase letters with your database credentials. Note that if you're unsure what to provide for the `SCHEMA` placeholder, it's most likely the default value `public`:

```bash

DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public"

```

If you want to learn how to set up a PostgreSQL database, you can follow this guide on [setting up a free PostgreSQL database on Heroku](https://dev.to/prisma/how-to-setup-a-free-postgresql-database-on-heroku-1dc1).

**MySQL**

If you're using MySQL, you have to adjust the `schema.prisma` and `.env` files as follows:

**`schema.prisma`**

```groovy

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

```

**`.env`**

```bash

DATABASE_URL="mysql://USER:PASSWORD@HOST:PORT/DATABASE"

```

Replace the placeholders spelled in all uppercase letters with your database credentials.

**Microsoft SQL Server / Azure SQL Server**

If you're using Microsoft SQL Server or Azure SQL Server, you have to adjust the `schema.prisma` and `.env` files as follows:

**`schema.prisma`**

```groovy

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

```

**`.env`**

Replace the placeholders spelled in all uppercase letters with your database credentials. Note that if you're unsure what to provide for the `encrypt` placeholder, it's most likely the default value `true`:

```bash

DATABASE_URL="sqlserver://HOST:PORT;database=DATABASE;user=USER;password=PASSWORD;encrypt=true"

```

#### Create two database tables with Prisma Migrate [\#](https://docs.nestjs.com/recipes/prisma\#create-two-database-tables-with-prisma-migrate)

In this section, you'll create two new tables in your database using [Prisma Migrate](https://www.prisma.io/docs/concepts/components/prisma-migrate). Prisma Migrate generates SQL migration files for your declarative data model definition in the Prisma schema. These migration files are fully customizable so that you can configure any additional features of the underlying database or include additional commands, e.g. for seeding.

Add the following two models to your `schema.prisma` file:

```groovy

model User {
  id    Int     @default(autoincrement()) @id
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @default(autoincrement()) @id
  title     String
  content   String?
  published Boolean? @default(false)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

```

With your Prisma models in place, you can generate your SQL migration files and run them against the database. Run the following commands in your terminal:

```bash

$ npx prisma migrate dev --name init

```

This `prisma migrate dev` command generates SQL files and directly runs them against the database. In this case, the following migration files was created in the existing `prisma` directory:

```bash

$ tree prisma
prisma
├── dev.db
├── migrations
│   └── 20201207100915_init
│       └── migration.sql
└── schema.prisma

```

Expand to view the generated SQL statements

The following tables were created in your SQLite database:

```sql

-- CreateTable
CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "email" TEXT NOT NULL,
    "name" TEXT
);

-- CreateTable
CREATE TABLE "Post" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "title" TEXT NOT NULL,
    "content" TEXT,
    "published" BOOLEAN DEFAULT false,
    "authorId" INTEGER,

    FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "User.email_unique" ON "User"("email");

```

#### Install and generate Prisma Client [\#](https://docs.nestjs.com/recipes/prisma\#install-and-generate-prisma-client)

Prisma Client is a type-safe database client that's _generated_ from your Prisma model definition. Because of this approach, Prisma Client can expose [CRUD](https://www.prisma.io/docs/concepts/components/prisma-client/crud) operations that are _tailored_ specifically to your models.

To install Prisma Client in your project, run the following command in your terminal:

```bash

$ npm install @prisma/client

```

Note that during installation, Prisma automatically invokes the `prisma generate` command for you. In the future, you need to run this command after _every_ change to your Prisma models to update your generated Prisma Client.

> **Note** The `prisma generate` command reads your Prisma schema and updates the generated Prisma Client library inside `node_modules/@prisma/client`.

#### Use Prisma Client in your NestJS services [\#](https://docs.nestjs.com/recipes/prisma\#use-prisma-client-in-your-nestjs-services)

You're now able to send database queries with Prisma Client. If you want to learn more about building queries with Prisma Client, check out the [API documentation](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud).

When setting up your NestJS application, you'll want to abstract away the Prisma Client API for database queries within a service. To get started, you can create a new `PrismaService` that takes care of instantiating `PrismaClient` and connecting to your database.

Inside the `src` directory, create a new file called `prisma.service.ts` and add the following code to it:

content\_copy

```typescript

import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}

```

> **Note** The `onModuleInit` is optional — if you leave it out, Prisma will connect lazily on its first call to the database.

Next, you can write services that you can use to make database calls for the `User` and `Post` models from your Prisma schema.

Still inside the `src` directory, create a new file called `user.service.ts` and add the following code to it:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { User, Prisma } from '@prisma/client';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async user(
    userWhereUniqueInput: Prisma.UserWhereUniqueInput,
  ): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: userWhereUniqueInput,
    });
  }

  async users(params: {
    skip?: number;
    take?: number;
    cursor?: Prisma.UserWhereUniqueInput;
    where?: Prisma.UserWhereInput;
    orderBy?: Prisma.UserOrderByWithRelationInput;
  }): Promise<User[]> {
    const { skip, take, cursor, where, orderBy } = params;
    return this.prisma.user.findMany({
      skip,
      take,
      cursor,
      where,
      orderBy,
    });
  }

  async createUser(data: Prisma.UserCreateInput): Promise<User> {
    return this.prisma.user.create({
      data,
    });
  }

  async updateUser(params: {
    where: Prisma.UserWhereUniqueInput;
    data: Prisma.UserUpdateInput;
  }): Promise<User> {
    const { where, data } = params;
    return this.prisma.user.update({
      data,
      where,
    });
  }

  async deleteUser(where: Prisma.UserWhereUniqueInput): Promise<User> {
    return this.prisma.user.delete({
      where,
    });
  }
}

```

Notice how you're using Prisma Client's generated types to ensure that the methods that are exposed by your service are properly typed. You therefore save the boilerplate of typing your models and creating additional interface or DTO files.

Now do the same for the `Post` model.

Still inside the `src` directory, create a new file called `post.service.ts` and add the following code to it:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { Post, Prisma } from '@prisma/client';

@Injectable()
export class PostsService {
  constructor(private prisma: PrismaService) {}

  async post(
    postWhereUniqueInput: Prisma.PostWhereUniqueInput,
  ): Promise<Post | null> {
    return this.prisma.post.findUnique({
      where: postWhereUniqueInput,
    });
  }

  async posts(params: {
    skip?: number;
    take?: number;
    cursor?: Prisma.PostWhereUniqueInput;
    where?: Prisma.PostWhereInput;
    orderBy?: Prisma.PostOrderByWithRelationInput;
  }): Promise<Post[]> {
    const { skip, take, cursor, where, orderBy } = params;
    return this.prisma.post.findMany({
      skip,
      take,
      cursor,
      where,
      orderBy,
    });
  }

  async createPost(data: Prisma.PostCreateInput): Promise<Post> {
    return this.prisma.post.create({
      data,
    });
  }

  async updatePost(params: {
    where: Prisma.PostWhereUniqueInput;
    data: Prisma.PostUpdateInput;
  }): Promise<Post> {
    const { data, where } = params;
    return this.prisma.post.update({
      data,
      where,
    });
  }

  async deletePost(where: Prisma.PostWhereUniqueInput): Promise<Post> {
    return this.prisma.post.delete({
      where,
    });
  }
}

```

Your `UsersService` and `PostsService` currently wrap the CRUD queries that are available in Prisma Client. In a real world application, the service would also be the place to add business logic to your application. For example, you could have a method called `updatePassword` inside the `UsersService` that would be responsible for updating the password of a user.

Remember to register the new services in the app module.

##### Implement your REST API routes in the main app controller

Finally, you'll use the services you created in the previous sections to implement the different routes of your app. For the purpose of this guide, you'll put all your routes into the already existing `AppController` class.

Replace the contents of the `app.controller.ts` file with the following code:

content\_copy

```typescript

import {
  Controller,
  Get,
  Param,
  Post,
  Body,
  Put,
  Delete,
} from '@nestjs/common';
import { UsersService } from './user.service';
import { PostsService } from './post.service';
import { User as UserModel, Post as PostModel } from '@prisma/client';

@Controller()
export class AppController {
  constructor(
    private readonly userService: UsersService,
    private readonly postService: PostsService,
  ) {}

  @Get('post/:id')
  async getPostById(@Param('id') id: string): Promise<PostModel> {
    return this.postService.post({ id: Number(id) });
  }

  @Get('feed')
  async getPublishedPosts(): Promise<PostModel[]> {
    return this.postService.posts({
      where: { published: true },
    });
  }

  @Get('filtered-posts/:searchString')
  async getFilteredPosts(
    @Param('searchString') searchString: string,
  ): Promise<PostModel[]> {
    return this.postService.posts({
      where: {
        OR: [\
          {\
            title: { contains: searchString },\
          },\
          {\
            content: { contains: searchString },\
          },\
        ],
      },
    });
  }

  @Post('post')
  async createDraft(
    @Body() postData: { title: string; content?: string; authorEmail: string },
  ): Promise<PostModel> {
    const { title, content, authorEmail } = postData;
    return this.postService.createPost({
      title,
      content,
      author: {
        connect: { email: authorEmail },
      },
    });
  }

  @Post('user')
  async signupUser(
    @Body() userData: { name?: string; email: string },
  ): Promise<UserModel> {
    return this.userService.createUser(userData);
  }

  @Put('publish/:id')
  async publishPost(@Param('id') id: string): Promise<PostModel> {
    return this.postService.updatePost({
      where: { id: Number(id) },
      data: { published: true },
    });
  }

  @Delete('post/:id')
  async deletePost(@Param('id') id: string): Promise<PostModel> {
    return this.postService.deletePost({ id: Number(id) });
  }
}

```

This controller implements the following routes:

###### `GET`

- `/post/:id`: Fetch a single post by its `id`
- `/feed`: Fetch all _published_ posts
- `/filter-posts/:searchString`: Filter posts by `title` or `content`

###### `POST`

- `/post`: Create a new post
  - Body:
    - `title: String` (required): The title of the post
    - `content: String` (optional): The content of the post
    - `authorEmail: String` (required): The email of the user that creates the post
- `/user`: Create a new user
  - Body:
    - `email: String` (required): The email address of the user
    - `name: String` (optional): The name of the user

###### `PUT`

- `/publish/:id`: Publish a post by its `id`

###### `DELETE`

- `/post/:id`: Delete a post by its `id`

#### Summary [\#](https://docs.nestjs.com/recipes/prisma\#summary)

In this recipe, you learned how to use Prisma along with NestJS to implement a REST API. The controller that implements the routes of the API is calling a `PrismaService` which in turn uses Prisma Client to send queries to a database to fulfill the data needs of incoming requests.

If you want to learn more about using NestJS with Prisma, be sure to check out the following resources:

- [NestJS & Prisma](https://www.prisma.io/nestjs)
- [Ready-to-run example projects for REST & GraphQL](https://github.com/prisma/prisma-examples/)
- [Production-ready starter kit](https://github.com/notiz-dev/nestjs-prisma-starter#instructions)
- [Video: Accessing Databases using NestJS with Prisma (5min)](https://www.youtube.com/watch?v=UlVJ340UEuk&ab_channel=Prisma) by [Marc Stammerjohann](https://github.com/marcjulian)

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Modules Overview
- [Modules](https://docs.nestjs.com/modules#modules)
- [Feature modules](https://docs.nestjs.com/modules#feature-modules)
- [Shared modules](https://docs.nestjs.com/modules#shared-modules)
- [Module re-exporting](https://docs.nestjs.com/modules#module-re-exporting)
- [Dependency injection](https://docs.nestjs.com/modules#dependency-injection)
- [Global modules](https://docs.nestjs.com/modules#global-modules)
- [Dynamic modules](https://docs.nestjs.com/modules#dynamic-modules)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/modules.md "Suggest Edits")

### Modules

A module is a class that is annotated with the `@Module()` decorator. This decorator provides metadata that **Nest** uses to organize and manage the application structure efficiently.

![](https://docs.nestjs.com/assets/Modules_1.png)

Every Nest application has at least one module, the **root module**, which serves as the starting point for Nest to build the **application graph**. This graph is an internal structure that Nest uses to resolve relationships and dependencies between modules and providers. While small applications might only have a root module, this is generally not the case. Modules are **highly recommended** as an effective way to organize your components. For most applications, you'll likely have multiple modules, each encapsulating a closely related set of **capabilities**.

The `@Module()` decorator takes a single object with properties that describe the module:

| `providers` | the providers that will be instantiated by the Nest injector and that may be shared at least across this module |
| `controllers` | the set of controllers defined in this module which have to be instantiated |
| `imports` | the list of imported modules that export the providers which are required in this module |
| `exports` | the subset of `providers` that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token ( `provide` value) |

The module **encapsulates** providers by default, meaning you can only inject providers that are either part of the current module or explicitly exported from other imported modules. The exported providers from a module essentially serve as the module's public interface or API.

#### Feature modules [\#](https://docs.nestjs.com/modules\#feature-modules)

In our example, the `CatsController` and `CatsService` are closely related and serve the same application domain. It makes sense to group them into a feature module. A feature module organizes code that is relevant to a specific feature, helping to maintain clear boundaries and better organization. This is particularly important as the application or team grows, and it aligns with the [SOLID](https://en.wikipedia.org/wiki/SOLID) principles.

Next, we'll create the `CatsModule` to demonstrate how to group the controller and service.

content\_copy cats/cats.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}

```

> **Hint** To create a module using the CLI, simply execute the `$ nest g module cats` command.

Above, we defined the `CatsModule` in the `cats.module.ts` file, and moved everything related to this module into the `cats` directory. The last thing we need to do is import this module into the root module (the `AppModule`, defined in the `app.module.ts` file).

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {}

```

Here is how our directory structure looks now:

src

cats

dto

create-cat.dto.ts

interfaces

cat.interface.ts

cats.controller.ts

cats.module.ts

cats.service.ts

app.module.ts

main.ts

#### Shared modules [\#](https://docs.nestjs.com/modules\#shared-modules)

In Nest, modules are **singletons** by default, and thus you can share the same instance of any provider between multiple modules effortlessly.

![](https://docs.nestjs.com/assets/Shared_Module_1.png)

Every module is automatically a **shared module**. Once created it can be reused by any module. Let's imagine that we want to share an instance of the `CatsService` between several other modules. In order to do that, we first need to **export** the `CatsService` provider by adding it to the module's `exports` array, as shown below:

content\_copy cats.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}

```

Now any module that imports the `CatsModule` has access to the `CatsService` and will share the same instance with all other modules that import it as well.

If we were to directly register the `CatsService` in every module that requires it, it would indeed work, but it would result in each module getting its own separate instance of the `CatsService`. This can lead to increased memory usage since multiple instances of the same service are created, and it could also cause unexpected behavior, such as state inconsistency if the service maintains any internal state.

By encapsulating the `CatsService` inside a module, such as the `CatsModule`, and exporting it, we ensure that the same instance of `CatsService` is reused across all modules that import `CatsModule`. This not only reduces memory consumption but also leads to more predictable behavior, as all modules share the same instance, making it easier to manage shared states or resources. This is one of the key benefits of modularity and dependency injection in frameworks like NestJS—allowing services to be efficiently shared throughout the application.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Module re-exporting [\#](https://docs.nestjs.com/modules\#module-re-exporting)

As seen above, Modules can export their internal providers. In addition, they can re-export modules that they import. In the example below, the `CommonModule` is both imported into **and** exported from the `CoreModule`, making it available for other modules which import this one.

content\_copy

```typescript

@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}

```

#### Dependency injection [\#](https://docs.nestjs.com/modules\#dependency-injection)

A module class can **inject** providers as well (e.g., for configuration purposes):

content\_copy cats.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private catsService: CatsService) {}
}

```

```typescript

import { Module, Dependencies } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
@Dependencies(CatsService)
export class CatsModule {
  constructor(catsService) {
    this.catsService = catsService;
  }
}

```

However, module classes themselves cannot be injected as providers due to [circular dependency](https://docs.nestjs.com/fundamentals/circular-dependency) .

#### Global modules [\#](https://docs.nestjs.com/modules\#global-modules)

If you have to import the same set of modules everywhere, it can get tedious. Unlike in Nest, [Angular](https://angular.dev/) `providers` are registered in the global scope. Once defined, they're available everywhere. Nest, however, encapsulates providers inside the module scope. You aren't able to use a module's providers elsewhere without first importing the encapsulating module.

When you want to provide a set of providers which should be available everywhere out-of-the-box (e.g., helpers, database connections, etc.), make the module **global** with the `@Global()` decorator.

content\_copy

```typescript

import { Module, Global } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}

```

The `@Global()` decorator makes the module global-scoped. Global modules should be registered **only once**, generally by the root or core module. In the above example, the `CatsService` provider will be ubiquitous, and modules that wish to inject the service will not need to import the `CatsModule` in their imports array.

> **Hint** Making everything global is not recommended as a design practice. While global modules can help reduce boilerplate, it's generally better to use the `imports` array to make a module's API available to other modules in a controlled and clear way. This approach provides better structure and maintainability, ensuring that only the necessary parts of the module are shared with others while avoiding unnecessary coupling between unrelated parts of the application.

#### Dynamic modules [\#](https://docs.nestjs.com/modules\#dynamic-modules)

Dynamic modules in Nest allow you to create modules that can be configured at runtime. This is especially useful when you need to provide flexible, customizable modules where the providers can be created based on certain options or configurations. Here's a brief overview of how **dynamic modules** work.

content\_copy

JS  TS

```typescript

import { Module, DynamicModule } from '@nestjs/common';
import { createDatabaseProviders } from './database.providers';
import { Connection } from './connection.provider';

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}

```

```typescript

import { Module } from '@nestjs/common';
import { createDatabaseProviders } from './database.providers';
import { Connection } from './connection.provider';

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options) {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}

```

> **Hint** The `forRoot()` method may return a dynamic module either synchronously or asynchronously (i.e., via a `Promise`).

This module defines the `Connection` provider by default (in the `@Module()` decorator metadata), but additionally - depending on the `entities` and `options` objects passed into the `forRoot()` method - exposes a collection of providers, for example, repositories. Note that the properties returned by the dynamic module **extend** (rather than override) the base module metadata defined in the `@Module()` decorator. That's how both the statically declared `Connection` provider **and** the dynamically generated repository providers are exported from the module.

If you want to register a dynamic module in the global scope, set the `global` property to `true`.

content\_copy

```typescript

{
  global: true,
  module: DatabaseModule,
  providers: providers,
  exports: providers,
}

```

> **Warning** As mentioned above, making everything global **is not a good design decision**.

The `DatabaseModule` can be imported and configured in the following manner:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { DatabaseModule } from './database/database.module';
import { User } from './users/entities/user.entity';

@Module({
  imports: [DatabaseModule.forRoot([User])],
})
export class AppModule {}

```

If you want to in turn re-export a dynamic module, you can omit the `forRoot()` method call in the exports array:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { DatabaseModule } from './database/database.module';
import { User } from './users/entities/user.entity';

@Module({
  imports: [DatabaseModule.forRoot([User])],
  exports: [DatabaseModule],
})
export class AppModule {}

```

The [Dynamic modules](https://docs.nestjs.com/fundamentals/dynamic-modules) chapter covers this topic in greater detail, and includes a [working example](https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules).

> **Hint** Learn how to build highly customizable dynamic modules with the use of `ConfigurableModuleBuilder` here in [this chapter](https://docs.nestjs.com/fundamentals/dynamic-modules#configurable-module-builder).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Deployment Guide
- [Deployment](https://docs.nestjs.com/deployment#deployment)
- [Prerequisites](https://docs.nestjs.com/deployment#prerequisites)
- [Building your application](https://docs.nestjs.com/deployment#building-your-application)
- [Production environment](https://docs.nestjs.com/deployment#production-environment)
- [NODE\_ENV=production](https://docs.nestjs.com/deployment#node_envproduction)
- [Running your application](https://docs.nestjs.com/deployment#running-your-application)
- [Health checks](https://docs.nestjs.com/deployment#health-checks)
- [Logging](https://docs.nestjs.com/deployment#logging)
- [Scaling up or out](https://docs.nestjs.com/deployment#scaling-up-or-out)
- [Some other tips](https://docs.nestjs.com/deployment#some-other-tips)
- [Dockerizing your application](https://docs.nestjs.com/deployment#dockerizing-your-application)
- [Easy deployment with Mau](https://docs.nestjs.com/deployment#easy-deployment-with-mau)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/deployment.md "Suggest Edits")

### Deployment

When you're ready to deploy your NestJS application to production, there are key steps you can take to ensure it runs as efficiently as possible. In this guide, we'll explore essential tips and best practices to help you deploy your NestJS application successfully.

#### Prerequisites [\#](https://docs.nestjs.com/deployment\#prerequisites)

Before deploying your NestJS application, ensure you have:

- A working NestJS application that is ready for deployment.
- Access to a deployment platform or server where you can host your application.
- All necessary environment variables set up for your application.
- Any required services, like a database, set up and ready to go.
- At least an LTS version of Node.js installed on your deployment platform.

> **Hint** If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com/ "Deploy Nest"), our official platform for deploying NestJS applications on AWS. With Mau, deploying your NestJS application is as simple as clicking a few buttons and running a single command:
>
> ```bash
>
> $ npm install -g @nestjs/mau
> $ mau deploy
>
> ```
>
> Once the deployment is complete, you'll have your NestJS application up and running on AWS in seconds!

#### Building your application [\#](https://docs.nestjs.com/deployment\#building-your-application)

To build your NestJS application, you need to compile your TypeScript code into JavaScript. This process generates a `dist` directory containing the compiled files. You can build your application by running the following command:

```bash

$ npm run build

```

This command typically runs the `nest build` command under the hood, which is basically a wrapper around the TypeScript compiler with some additional features (assets copying, etc.). In case you have a custom build script, you can run it directly. Also, for NestJS CLI mono-repos, make sure to pass the name of the project to build as an argument ( `npm run build my-app`).

Upon successful compilation, you should see a `dist` directory in your project root containing the compiled files, with the entry point being `main.js`. If you have any `.ts` files located in the root directory of your project (and your `tsconfig.json` configured to compile them), they will be copied to the `dist` directory as well, modifying the directory structure a bit (instead of `dist/main.js`, you will have `dist/src/main.js` so keep that in mind when configuring your server).

#### Production environment [\#](https://docs.nestjs.com/deployment\#production-environment)

Your production environment is where your application will be accessible to external users. This could be a cloud-based platform like [AWS](https://aws.amazon.com/) (with EC2, ECS, etc.), [Azure](https://azure.microsoft.com/), or [Google Cloud](https://cloud.google.com/), or even a dedicated server you manage, such as [Hetzner](https://www.hetzner.com/).

To simplify the deployment process and avoid manual setup, you can use a service like [Mau](https://mau.nestjs.com/ "Deploy Nest"), our official platform for deploying NestJS applications on AWS. For more details, check out [this section](https://docs.nestjs.com/deployment/todo).

Some of the pros of using a **cloud-based platform** or service like [Mau](https://mau.nestjs.com/ "Deploy Nest") include:

- Scalability: Easily scale your application as your user base grows.
- Security: Benefit from built-in security features and compliance certifications.
- Monitoring: Monitor your application's performance and health in real-time.
- Reliability: Ensure your application is always available with high uptime guarantees.

On the other hand, cloud-based platforms are typically more expensive than self-hosting, and you may have less control over the underlying infrastructure. Simple VPS can be a good choice if you're looking for a more cost-effective solution and have the technical expertise to manage the server yourself, but keep in mind that you'll need to handle tasks like server maintenance, security, and backups manually.

#### NODE\_ENV=production [\#](https://docs.nestjs.com/deployment\#node_envproduction)

While there's technically no difference between development and production in Node.js and NestJS, it's a good practice to set the `NODE_ENV` environment variable to `production` when running your application in a production environment, as some libraries in the ecosystem may behave differently based on this variable (e.g., enabling or disabling debugging output, etc.).

You can set the `NODE_ENV` environment variable when starting your application like so:

```bash

$ NODE_ENV=production node dist/main.js

```

Or just set it in your cloud provider's/Mau dashboard.

#### Running your application [\#](https://docs.nestjs.com/deployment\#running-your-application)

To run your NestJS application in production, just use the following command:

```bash

$ node dist/main.js # Adjust this based on your entry point location

```

This command starts your application, which will listen on the specified port (usually `3000` by default). Ensure that this matches the port you’ve configured in your application.

Alternatively, you can use the `nest start` command. This command is a wrapper around `node dist/main.js`, but it has one key difference: it automatically runs `nest build` before starting the application, so you don’t need to manually execute `npm run build`.

#### Health checks [\#](https://docs.nestjs.com/deployment\#health-checks)

Health checks are essential for monitoring the health and status of your NestJS application in production. By setting up a health check endpoint, you can regularly verify that your app is running as expected and respond to issues before they become critical.

In NestJS, you can easily implement health checks using the **@nestjs/terminus** package, which provides a powerful tool for adding health checks, including database connections, external services, and custom checks.

Check out [this guide](https://docs.nestjs.com/recipes/terminus) to learn how to implement health checks in your NestJS application, and ensure your app is always monitored and responsive.

#### Logging [\#](https://docs.nestjs.com/deployment\#logging)

Logging is essential for any production-ready application. It helps track errors, monitor behavior, and troubleshoot issues. In NestJS, you can easily manage logging with the built-in logger or opt for external libraries if you need more advanced features.

Best practices for logging:

- Log Errors, Not Exceptions: Focus on logging detailed error messages to speed up debugging and issue resolution.
- Avoid Sensitive Data: Never log sensitive information like passwords or tokens to protect security.
- Use Correlation IDs: In distributed systems, include unique identifiers (like correlation IDs) in your logs to trace requests across different services.
- Use Log Levels: Categorize logs by severity (e.g., `info`, `warn`, `error`) and disable debug or verbose logs in production to reduce noise.

> **Hint** If you're using [AWS](https://aws.amazon.com/) (with [Mau](https://mau.nestjs.com/ "Deploy Nest") or directly), consider JSON logging to make it easier to parse and analyze your logs.

For distributed applications, using a centralized logging service like ElasticSearch, Loggly, or Datadog can be incredibly useful. These tools offer powerful features like log aggregation, search, and visualization, making it easier to monitor and analyze your application's performance and behavior.

#### Scaling up or out [\#](https://docs.nestjs.com/deployment\#scaling-up-or-out)

Scaling your NestJS application effectively is crucial for handling increased traffic and ensuring optimal performance. There are two primary strategies for scaling: **vertical scaling** and **horizontal scaling**. Understanding these approaches will help you design your application to manage load efficiently.

**Vertical scaling**, often referred to as "scaling up" involves increasing the resources of a single server to enhance its performance. This could mean adding more CPU, RAM, or storage to your existing machine. Here are some key points to consider:

- Simplicity: Vertical scaling is generally simpler to implement since you only need to upgrade your existing server rather than manage multiple instances.
- Limitations: There are physical limits to how much you can scale a single machine. Once you reach the maximum capacity, you may need to consider other options.
- Cost-Effectiveness: For applications with moderate traffic, vertical scaling can be cost-effective, as it reduces the need for additional infrastructure.

Example: If your NestJS app is hosted on a virtual machine and you notice that it’s running slowly during peak hours, you can upgrade your VM to a larger instance with more resources. To upgrade your VM, just navigate to your current provider's dashboard and select a larger instance type.

**Horizontal scaling**, or "scaling out" involves adding more servers or instances to distribute the load. This strategy is widely used in cloud environments and is essential for applications expecting high traffic. Here are the benefits and considerations:

- Increased Capacity: By adding more instances of your application, you can handle a larger number of concurrent users without degrading performance.
- Redundancy: Horizontal scaling offers redundancy, as the failure of one server won't bring down your entire application. Traffic can be redistributed among the remaining servers.
- Load Balancing: To manage multiple instances effectively, use load balancers (like Nginx or AWS Elastic Load Balancing) to distribute incoming traffic evenly across your servers.

Example: For a NestJS application experiencing high traffic, you can deploy multiple instances of your app in a cloud environment and use a load balancer to route requests, ensuring that no single instance becomes a bottleneck.

This process is straightforward with containerization technologies like [Docker](https://www.docker.com/) and container orchestration platforms such as [Kubernetes](https://kubernetes.io/). Additionally, you can leverage cloud-specific load balancers like [AWS Elastic Load Balancing](https://aws.amazon.com/elasticloadbalancing/) or [Azure Load Balancer](https://azure.microsoft.com/en-us/services/load-balancer/) to distribute traffic across your application instances.

> **Hint** [Mau](https://mau.nestjs.com/ "Deploy Nest") offers built-in support for horizontal scaling on AWS, allowing you to easily deploy multiple instances of your NestJS application and manage them with just a few clicks.

#### Some other tips [\#](https://docs.nestjs.com/deployment\#some-other-tips)

There are a few more tips to keep in mind when deploying your NestJS application:

- **Security**: Ensure your application is secure and protected from common threats like SQL injection, XSS, etc. See the "Security" category for more details.
- **Monitoring**: Use monitoring tools like [Prometheus](https://prometheus.io/) or [New Relic](https://newrelic.com/) to track your application's performance and health. If you're using a cloud provider/Mau, they may offer built-in monitoring services (like [AWS CloudWatch](https://aws.amazon.com/cloudwatch/) etc.)
- **Do not hardcode environment variables**: Avoid hardcoding sensitive information like API keys, passwords, or tokens in your code. Use environment variables or a secrets manager to store and access these values securely.
- **Backups**: Regularly back up your data to prevent data loss in case of an incident.
- **Automate deployments**: Use CI/CD pipelines to automate your deployment process and ensure consistency across environments.
- **Rate limiting**: Implement rate limiting to prevent abuse and protect your application from DDoS attacks. Check out [Rate limiting chapter](https://docs.nestjs.com/security/rate-limiting) for more details, or use a service like [AWS WAF](https://aws.amazon.com/waf/) for advanced protection.

#### Dockerizing your application [\#](https://docs.nestjs.com/deployment\#dockerizing-your-application)

[Docker](https://www.docker.com/) is a platform that uses containerization to allow developers to package applications along with their dependencies into a standardized unit called a container. Containers are lightweight, portable, and isolated, making them ideal for deploying applications in various environments, from local development to production.

Benefits of Dockerizing your NestJS application:

- Consistency: Docker ensures that your application runs the same way on any machine, eliminating the "it works on my machine" problem.
- Isolation: Each container runs in its isolated environment, preventing conflicts between dependencies.
- Scalability: Docker makes it easy to scale your application by running multiple containers across different machines or cloud instances.
- Portability: Containers can be easily moved between environments, making it simple to deploy your application on different platforms.

To install Docker, follow the instructions on the [official website](https://www.docker.com/get-started). Once Docker is installed, you can create a `Dockerfile` in your NestJS project to define the steps for building your container image.

The `Dockerfile` is a text file that contains the instructions Docker uses to build your container image.

Here's a sample Dockerfile for a NestJS application:

```bash

# Use the official Node.js image as the base image
FROM node:20

# Set the working directory inside the container
WORKDIR /usr/src/app

# Copy package.json and package-lock.json to the working directory
COPY package*.json ./

# Install the application dependencies
RUN npm install

# Copy the rest of the application files
COPY . .

# Build the NestJS application
RUN npm run build

# Expose the application port
EXPOSE 3000

# Command to run the application
CMD ["node", "dist/main"]

```

> **Hint** Make sure to replace `node:20` with the appropriate Node.js version you're using in your project. You can find the available Node.js Docker images on the [official Docker Hub repository](https://hub.docker.com/_/node).

This is a basic Dockerfile that sets up a Node.js environment, installs the application dependencies, builds the NestJS application, and runs it. You can customize this file based on your project requirements (e.g., use different base images, optimize the build process, only install production dependencies, etc.).

Let's also create a `.dockerignore` file to specify which files and directories Docker should ignore when building the image. Create a `.dockerignore` file in your project root:

```bash

node_modules
dist
*.log
*.md
.git

```

This file ensures that unnecessary files are not included in the container image, keeping it lightweight. Now that you have your Dockerfile set up, you can build your Docker image. Open your terminal, navigate to your project directory, and run the following command:

```bash

docker build -t my-nestjs-app .

```

In this command:

- `-t my-nestjs-app`: Tags the image with the name `my-nestjs-app`.
- `.`: Indicates the current directory as the build context.

After building the image, you can run it as a container. Execute the following command:

```bash

docker run -p 3000:3000 my-nestjs-app

```

In this command:

- `-p 3000:3000`: Maps port 3000 on your host machine to port 3000 in the container.
- `my-nestjs-app`: Specifies the image to run.

Your NestJS application should now be running inside a Docker container.

If you want to deploy your Docker image to a cloud provider or share it with others, you'll need to push it to a Docker registry (like [Docker Hub](https://hub.docker.com/), [AWS ECR](https://aws.amazon.com/ecr/), or [Google Container Registry](https://cloud.google.com/container-registry)).

Once you decide on a registry, you can push your image by following these steps:

```bash

docker login # Log in to your Docker registry
docker tag my-nestjs-app your-dockerhub-username/my-nestjs-app # Tag your image
docker push your-dockerhub-username/my-nestjs-app # Push your image

```

Replace `your-dockerhub-username` with your Docker Hub username or the appropriate registry URL. After pushing your image, you can pull it on any machine and run it as a container.

Cloud providers like AWS, Azure, and Google Cloud offer managed container services that simplify deploying and managing containers at scale. These services provide features like auto-scaling, load balancing, and monitoring, making it easier to run your NestJS application in production.

#### Easy deployment with Mau [\#](https://docs.nestjs.com/deployment\#easy-deployment-with-mau)

[Mau](https://mau.nestjs.com/ "Deploy Nest") is our official platform for deploying NestJS applications on [AWS](https://aws.amazon.com/). If you're not ready to manage your infrastructure manually (or just want to save time), Mau is the perfect solution for you.

With Mau, provisioning and maintaining your infrastructure is as simple as clicking just a few buttons. Mau is designed to be simple and intuitive, so you can focus on building your applications and not worry about the underlying infrastructure. Under the hood, we use **Amazon Web Services** to provide you with a powerful and reliable platform, while abstracting away all the complexity of AWS. We take care of all the heavy lifting for you, so you can focus on building your applications and growing your business.

[Mau](https://mau.nestjs.com/ "Deploy Nest") is perfect for startups, small-to-medium businesses, large enterprises, and developers who want to get up and running quickly without having to spend a lot of time on learning and managing infrastructure. It's incredibly easy to use, and you can have your infrastructure up and running in minutes. It also leverages AWS behind the scenes, giving you all the advantages of AWS without the hassle of managing its complexities.

![](https://docs.nestjs.com/assets/mau-metrics.png)

With [Mau](https://mau.nestjs.com/ "Deploy Nest"), you can:

- Deploy your NestJS applications with just a few clicks (APIs, microservices, etc.).
- Provision **databases** such as:
  - PostgreSQL
  - MySQL
  - MongoDB (DocumentDB)
  - Redis
  - more
- Set up broker services like:
  - RabbitMQ
  - Kafka
  - NATS
- Deploy scheduled tasks ( **CRON jobs**) and background workers.
- Deploy lambda functions and serverless applications.
- Setup **CI/CD pipelines** for automated deployments.
- And much more!

To deploy your NestJS application with Mau, just run the following command:

```bash

$ npm install -g @nestjs/mau
$ mau deploy

```

Sign up today and [Deploy with Mau](https://mau.nestjs.com/ "Deploy Nest") to get your NestJS applications up and running on AWS in minutes!

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Controllers Guide
- [Controllers](https://docs.nestjs.com/controllers#controllers)
- [Routing](https://docs.nestjs.com/controllers#routing)
- [Request object](https://docs.nestjs.com/controllers#request-object)
- [Resources](https://docs.nestjs.com/controllers#resources)
- [Route wildcards](https://docs.nestjs.com/controllers#route-wildcards)
- [Status code](https://docs.nestjs.com/controllers#status-code)
- [Response headers](https://docs.nestjs.com/controllers#response-headers)
- [Redirection](https://docs.nestjs.com/controllers#redirection)
- [Route parameters](https://docs.nestjs.com/controllers#route-parameters)
- [Sub-domain routing](https://docs.nestjs.com/controllers#sub-domain-routing)
- [State sharing](https://docs.nestjs.com/controllers#state-sharing)
- [Asynchronicity](https://docs.nestjs.com/controllers#asynchronicity)
- [Request payloads](https://docs.nestjs.com/controllers#request-payloads)
- [Query parameters](https://docs.nestjs.com/controllers#query-parameters)
- [Handling errors](https://docs.nestjs.com/controllers#handling-errors)
- [Full resource sample](https://docs.nestjs.com/controllers#full-resource-sample)
- [Getting up and running](https://docs.nestjs.com/controllers#getting-up-and-running)
- [Library-specific approach](https://docs.nestjs.com/controllers#library-specific-approach)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/controllers.md "Suggest Edits")

### Controllers

Controllers are responsible for handling incoming **requests** and sending **responses** back to the client.

![](https://docs.nestjs.com/assets/Controllers_1.png)

A controller's purpose is to handle specific requests for the application. The **routing** mechanism determines which controller will handle each request. Often, a controller has multiple routes, and each route can perform a different action.

To create a basic controller, we use classes and **decorators**. Decorators link classes with the necessary metadata, allowing Nest to create a routing map that connects requests to their corresponding controllers.

> **Hint** To quickly create a CRUD controller with built-in [validation](https://docs.nestjs.com/techniques/validation), you can use the CLI's [CRUD generator](https://docs.nestjs.com/recipes/crud-generator#crud-generator): `nest g resource [name]`.

#### Routing [\#](https://docs.nestjs.com/controllers\#routing)

In the following example, we’ll use the `@Controller()` decorator, which is **required** to define a basic controller. We'll specify an optional route path prefix of `cats`. Using a path prefix in the `@Controller()` decorator helps us group related routes together and reduces repetitive code. For example, if we want to group routes that manage interactions with a cat entity under the `/cats` path, we can specify the `cats` path prefix in the `@Controller()` decorator. This way, we don't need to repeat that portion of the path for each route in the file.

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}

```

```typescript

import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll() {
    return 'This action returns all cats';
  }
}

```

> **Hint** To create a controller using the CLI, simply execute the `$ nest g controller [name]` command.

The `@Get()` HTTP request method decorator placed before the `findAll()` method tells Nest to create a handler for a specific endpoint for HTTP requests. This endpoint is defined by the HTTP request method (GET in this case) and the route path. So, what is the route path? The route path for a handler is determined by combining the (optional) prefix declared for the controller with any path specified in the method's decorator. Since we've set a prefix ( `cats`) for every route and haven't added any specific path in the method decorator, Nest will map `GET /cats` requests to this handler.

As mentioned, the route path includes both the optional controller path prefix **and** any path string specified in the method's decorator. For example, if the controller prefix is `cats` and the method decorator is `@Get('breed')`, the resulting route will be `GET /cats/breed`.

In our example above, when a GET request is made to this endpoint, Nest routes the request to the user-defined `findAll()` method. Note that the method name we choose here is entirely arbitrary. While we must declare a method to bind the route to, Nest doesn’t attach any specific significance to the method name.

This method will return a 200 status code along with the associated response, which in this case is just a string. Why does this happen? To explain, we first need to introduce the concept that Nest uses two **different** options for manipulating responses:

|     |     |
| --- | --- |
| Standard (recommended) | Using this built-in method, when a request handler returns a JavaScript object or array, it will **automatically** be serialized to JSON. When it returns a JavaScript primitive type (e.g., `string`, `number`, `boolean`), however, Nest will send just the value without attempting to serialize it. This makes response handling simple: just return the value, and Nest takes care of the rest. <br> Furthermore, the response's **status code** is always 200 by default, except for POST requests which use 201. We can easily change this behavior by adding the `@HttpCode(...)` decorator at a handler-level (see [Status codes](https://docs.nestjs.com/controllers#status-code)). |
| Library-specific | We can use the library-specific (e.g., Express) [response object](https://expressjs.com/en/api.html#res), which can be injected using the `@Res()` decorator in the method handler signature (e.g., `findAll(@Res() response)`). With this approach, you have the ability to use the native response handling methods exposed by that object. For example, with Express, you can construct responses using code like `response.status(200).send()`. |

> **Warning** Nest detects when the handler is using either `@Res()` or `@Next()`, indicating you have chosen the library-specific option. If both approaches are used at the same time, the Standard approach is **automatically disabled** for this single route and will no longer work as expected. To use both approaches at the same time (for example, by injecting the response object to only set cookies/headers but still leave the rest to the framework), you must set the `passthrough` option to `true` in the `@Res({ passthrough: true })` decorator.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Request object [\#](https://docs.nestjs.com/controllers\#request-object)

Handlers often need access to the client’s **request** details. Nest provides access to the [request object](https://expressjs.com/en/api.html#req) from the underlying platform (Express by default). You can access the request object by instructing Nest to inject it using the `@Req()` decorator in the handler’s signature.

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}

```

```typescript

import { Controller, Bind, Get, Req } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  @Bind(Req())
  findAll(request) {
    return 'This action returns all cats';
  }
}

```

> **Hint** To take advantage of `express` typings (like in the `request: Request` parameter example above), make sure to install the `@types/express` package.

The request object represents the HTTP request and contains properties for the query string, parameters, HTTP headers, and body (read more [here](https://expressjs.com/en/api.html#req)). In most cases, you don't need to manually access these properties. Instead, you can use dedicated decorators like `@Body()` or `@Query()`, which are available out of the box. Below is a list of the provided decorators and the corresponding platform-specific objects they represent.

|     |     |
| --- | --- |
| `@Request(), @Req()` | `req` |
| `@Response(), @Res()`\* | `res` |
| `@Next()` | `next` |
| `@Session()` | `req.session` |
| `@Param(key?: string)` | `req.params` / `req.params[key]` |
| `@Body(key?: string)` | `req.body` / `req.body[key]` |
| `@Query(key?: string)` | `req.query` / `req.query[key]` |
| `@Headers(name?: string)` | `req.headers` / `req.headers[name]` |
| `@Ip()` | `req.ip` |
| `@HostParam()` | `req.hosts` |

\\* For compatibility with typings across underlying HTTP platforms (e.g., Express and Fastify), Nest provides `@Res()` and `@Response()` decorators. `@Res()` is simply an alias for `@Response()`. Both directly expose the underlying native platform `response` object interface. When using them, you should also import the typings for the underlying library (e.g., `@types/express`) to take full advantage. Note that when you inject either `@Res()` or `@Response()` in a method handler, you put Nest into **Library-specific mode** for that handler, and you become responsible for managing the response. When doing so, you must issue some kind of response by making a call on the `response` object (e.g., `res.json(...)` or `res.send(...)`), or the HTTP server will hang.

> **Hint** To learn how to create your own custom decorators, visit [this](https://docs.nestjs.com/custom-decorators) chapter.

#### Resources [\#](https://docs.nestjs.com/controllers\#resources)

Earlier, we defined an endpoint to fetch the cats resource ( **GET** route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the **POST** handler:

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, Post } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Post()
  create(): string {
    return 'This action adds a new cat';
  }

  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}

```

```typescript

import { Controller, Get, Post } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Post()
  create() {
    return 'This action adds a new cat';
  }

  @Get()
  findAll() {
    return 'This action returns all cats';
  }
}

```

It's that simple. Nest provides decorators for all of the standard HTTP methods: `@Get()`, `@Post()`, `@Put()`, `@Delete()`, `@Patch()`, `@Options()`, and `@Head()`. In addition, `@All()` defines an endpoint that handles all of them.

#### Route wildcards [\#](https://docs.nestjs.com/controllers\#route-wildcards)

Pattern-based routes are also supported in NestJS. For example, the asterisk ( `*`) can be used as a wildcard to match any combination of characters in a route at the end of a path. In the following example, the `findAll()` method will be executed for any route that starts with `abcd/`, regardless of the number of characters that follow.

content\_copy

```typescript

@Get('abcd/*')
findAll() {
  return 'This route uses a wildcard';
}

```

The `'abcd/*'` route path will match `abcd/`, `abcd/123`, `abcd/abc`, and so on. The hyphen ( `-`) and the dot ( `.`) are interpreted literally by string-based paths.

This approach works on both Express and Fastify. However, with the latest release of Express (v5), the routing system has become more strict. In pure Express, you must use a named wildcard to make the route work—for example, `abcd/*splat`, where `splat` is simply the name of the wildcard parameter and has no special meaning. You can name it anything you like. That said, since Nest provides a compatibility layer for Express, you can still use the asterisk ( `*`) as a wildcard.

When it comes to asterisks used in the **middle of a route**, Express requires named wildcards (e.g., `ab{*splat}cd`), while Fastify does not support them at all.

#### Status code [\#](https://docs.nestjs.com/controllers\#status-code)

As mentioned, the default **status code** for responses is always **200**, except for POST requests, which default to **201**. You can easily change this behavior by using the `@HttpCode(...)` decorator at the handler level.

content\_copy

```typescript

@Post()
@HttpCode(204)
create() {
  return 'This action adds a new cat';
}

```

> **Hint** Import `HttpCode` from the `@nestjs/common` package.

Often, your status code isn't static but depends on various factors. In that case, you can use a library-specific **response** (inject using `@Res()`) object (or, in case of an error, throw an exception).

#### Response headers [\#](https://docs.nestjs.com/controllers\#response-headers)

To specify a custom response header, you can either use a `@Header()` decorator or a library-specific response object (and call `res.header()` directly).

content\_copy

```typescript

@Post()
@Header('Cache-Control', 'no-store')
create() {
  return 'This action adds a new cat';
}

```

> **Hint** Import `Header` from the `@nestjs/common` package.

#### Redirection [\#](https://docs.nestjs.com/controllers\#redirection)

To redirect a response to a specific URL, you can either use a `@Redirect()` decorator or a library-specific response object (and call `res.redirect()` directly).

`@Redirect()` takes two arguments, `url` and `statusCode`, both are optional. The default value of `statusCode` is `302` ( `Found`) if omitted.

content\_copy

```typescript

@Get()
@Redirect('https://nestjs.com', 301)

```

> **Hint** Sometimes you may want to determine the HTTP status code or the redirect URL dynamically. Do this by returning an object following the `HttpRedirectResponse` interface (from `@nestjs/common`).

Returned values will override any arguments passed to the `@Redirect()` decorator. For example:

content\_copy

```typescript

@Get('docs')
@Redirect('https://docs.nestjs.com', 302)
getDocs(@Query('version') version) {
  if (version && version === '5') {
    return { url: 'https://docs.nestjs.com/v5/' };
  }
}

```

#### Route parameters [\#](https://docs.nestjs.com/controllers\#route-parameters)

Routes with static paths won’t work when you need to accept **dynamic data** as part of the request (e.g., `GET /cats/1` to get the cat with id `1`). To define routes with parameters, you can add route parameter **tokens** in the route path to capture the dynamic values from the URL. The route parameter token in the `@Get()` decorator example below illustrates this approach. These route parameters can then be accessed using the `@Param()` decorator, which should be added to the method signature.

> **Hint** Routes with parameters should be declared after any static paths. This prevents the parameterized paths from intercepting traffic destined for the static paths.

content\_copy

JS  TS

```typescript

@Get(':id')
findOne(@Param() params: any): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}

```

```typescript

@Get(':id')
@Bind(Param())
findOne(params) {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}

```

The `@Param()` decorator is used to decorate a method parameter (in the example above, `params`), making the **route** parameters accessible as properties of that decorated method parameter inside the method. As shown in the code, you can access the `id` parameter by referencing `params.id`. Alternatively, you can pass a specific parameter token to the decorator and directly reference the route parameter by name within the method body.

> **Hint** Import `Param` from the `@nestjs/common` package.

content\_copy

JS  TS

```typescript

@Get(':id')
findOne(@Param('id') id: string): string {
  return `This action returns a #${id} cat`;
}

```

```typescript

@Get(':id')
@Bind(Param('id'))
findOne(id) {
  return `This action returns a #${id} cat`;
}

```

#### Sub-domain routing [\#](https://docs.nestjs.com/controllers\#sub-domain-routing)

The `@Controller` decorator can take a `host` option to require that the HTTP host of the incoming requests matches some specific value.

content\_copy

```typescript

@Controller({ host: 'admin.example.com' })
export class AdminController {
  @Get()
  index(): string {
    return 'Admin page';
  }
}

```

> **Warning** Since **Fastify** does not support nested routers, if you are using sub-domain routing, it is recommended to use the default Express adapter instead.

Similar to a route `path`, the `host` option can use tokens to capture the dynamic value at that position in the host name. The host parameter token in the `@Controller()` decorator example below demonstrates this usage. Host parameters declared in this way can be accessed using the `@HostParam()` decorator, which should be added to the method signature.

content\_copy

```typescript

@Controller({ host: ':account.example.com' })
export class AccountController {
  @Get()
  getInfo(@HostParam('account') account: string) {
    return account;
  }
}

```

#### State sharing [\#](https://docs.nestjs.com/controllers\#state-sharing)

For developers coming from other programming languages, it might be surprising to learn that in Nest, nearly everything is shared across incoming requests. This includes resources like the database connection pool, singleton services with global state, and more. It's important to understand that Node.js doesn't use the request/response Multi-Threaded Stateless Model, where each request is handled by a separate thread. As a result, using singleton instances in Nest is completely **safe** for our applications.

That said, there are specific edge cases where having request-based lifetimes for controllers may be necessary. Examples include per-request caching in GraphQL applications, request tracking, or implementing multi-tenancy. You can learn more about controlling injection scopes [here](https://docs.nestjs.com/fundamentals/injection-scopes).

#### Asynchronicity [\#](https://docs.nestjs.com/controllers\#asynchronicity)

We love modern JavaScript, especially its emphasis on **asynchronous** data handling. That’s why Nest fully supports `async` functions. Every `async` function must return a `Promise`, which allows you to return a deferred value that Nest can resolve automatically. Here's an example:

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
async findAll(): Promise<any[]> {
  return [];
}

```

```typescript

@Get()
async findAll() {
  return [];
}

```

This code is perfectly valid. But Nest takes it a step further by allowing route handlers to return RxJS [observable streams](https://rxjs-dev.firebaseapp.com/guide/observable) as well. Nest will handle the subscription internally and resolve the final emitted value once the stream completes.

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
findAll(): Observable<any[]> {
  return of([]);
}

```

```typescript

@Get()
findAll() {
  return of([]);
}

```

Both approaches are valid, and you can choose the one that best suits your needs.

#### Request payloads [\#](https://docs.nestjs.com/controllers\#request-payloads)

In our previous example, the POST route handler didn’t accept any client parameters. Let's fix that by adding the `@Body()` decorator.

Before we proceed (if you're using TypeScript), we need to define the **DTO** (Data Transfer Object) schema. A DTO is an object that specifies how data should be sent over the network. We could define the DTO schema using **TypeScript** interfaces or simple classes. However, we recommend using **classes** here. Why? Classes are part of the JavaScript ES6 standard, so they remain intact as real entities in the compiled JavaScript. In contrast, TypeScript interfaces are removed during transpilation, meaning Nest can't reference them at runtime. This is important because features like **Pipes** rely on having access to the metatype of variables at runtime, which is only possible with classes.

Let's create the `CreateCatDto` class:

content\_copy create-cat.dto.ts

JS  TS

```typescript

export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

```

It has only three basic properties. Thereafter we can use the newly created DTO inside the `CatsController`:

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
async create(@Body() createCatDto: CreateCatDto) {
  return 'This action adds a new cat';
}

```

```typescript

@Post()
@Bind(Body())
async create(createCatDto) {
  return 'This action adds a new cat';
}

```

> **Hint** Our `ValidationPipe` can filter out properties that should not be received by the method handler. In this case, we can whitelist the acceptable properties, and any property not included in the whitelist is automatically stripped from the resulting object. In the `CreateCatDto` example, our whitelist is the `name`, `age`, and `breed` properties. Learn more [here](https://docs.nestjs.com/techniques/validation#stripping-properties).

#### Query parameters [\#](https://docs.nestjs.com/controllers\#query-parameters)

When handling query parameters in your routes, you can use the `@Query()` decorator to extract them from incoming requests. Let's see how this works in practice.

Consider a route where we want to filter a list of cats based on query parameters like `age` and `breed`. First, define the query parameters in the `CatsController`:

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
async findAll(@Query('age') age: number, @Query('breed') breed: string) {
  return `This action returns all cats filtered by age: ${age} and breed: ${breed}`;
}

```

In this example, the `@Query()` decorator is used to extract the values of `age` and `breed` from the query string. For example, a request to:

```plaintext

GET /cats?age=2&breed=Persian

```

would result in `age` being `2` and `breed` being `Persian`.

If your application requires handling more complex query parameters, such as nested objects or arrays:

```plaintext

?filter[where][name]=John&filter[where][age]=30
?item[]=1&item[]=2

```

you'll need to configure your HTTP adapter (Express or Fastify) to use an appropriate query parser. In Express, you can use the `extended` parser, which allows for rich query objects:

content\_copy

```typescript

const app = await NestFactory.create<NestExpressApplication>(AppModule);
app.set('query parser', 'extended');

```

In Fastify, you can use the `querystringParser` option:

content\_copy

```typescript

const app = await NestFactory.create<NestFastifyApplication>(
  AppModule,
  new FastifyAdapter({
    querystringParser: (str) => qs.parse(str),
  }),
);

```

> **Hint** `qs` is a querystring parser that supports nesting and arrays. You can install it using `npm install qs`.

#### Handling errors [\#](https://docs.nestjs.com/controllers\#handling-errors)

There's a separate chapter about handling errors (i.e., working with exceptions) [here](https://docs.nestjs.com/exception-filters).

#### Full resource sample [\#](https://docs.nestjs.com/controllers\#full-resource-sample)

Below is an example that demonstrates the use of several available decorators to create a basic controller. This controller provides a few methods to access and manipulate internal data.

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common';
import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto';

@Controller('cats')
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return 'This action adds a new cat';
  }

  @Get()
  findAll(@Query() query: ListAllEntities) {
    return `This action returns all cats (limit: ${query.limit} items)`;
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return `This action returns a #${id} cat`;
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {
    return `This action updates a #${id} cat`;
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return `This action removes a #${id} cat`;
  }
}

```

```typescript

import { Controller, Get, Query, Post, Body, Put, Param, Delete, Bind } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Post()
  @Bind(Body())
  create(createCatDto) {
    return 'This action adds a new cat';
  }

  @Get()
  @Bind(Query())
  findAll(query) {
    console.log(query);
    return `This action returns all cats (limit: ${query.limit} items)`;
  }

  @Get(':id')
  @Bind(Param('id'))
  findOne(id) {
    return `This action returns a #${id} cat`;
  }

  @Put(':id')
  @Bind(Param('id'), Body())
  update(id, updateCatDto) {
    return `This action updates a #${id} cat`;
  }

  @Delete(':id')
  @Bind(Param('id'))
  remove(id) {
    return `This action removes a #${id} cat`;
  }
}

```

> **Hint** Nest CLI offers a generator (schematic) that automatically creates **all the boilerplate code**, saving you from doing this manually and improving the overall developer experience. Learn more about this feature [here](https://docs.nestjs.com/recipes/crud-generator).

#### Getting up and running [\#](https://docs.nestjs.com/controllers\#getting-up-and-running)

Even with the `CatsController` fully defined, Nest doesn't yet know about it and won't automatically create an instance of the class.

Controllers must always be part of a module, which is why we include the `controllers` array within the `@Module()` decorator. Since we haven’t defined any other modules apart from the root `AppModule`, we’ll use it to register the `CatsController`:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats/cats.controller';

@Module({
  controllers: [CatsController],
})
export class AppModule {}

```

We attached the metadata to the module class using the `@Module()` decorator, and now Nest can easily determine which controllers need to be mounted.

#### Library-specific approach [\#](https://docs.nestjs.com/controllers\#library-specific-approach)

So far, we've covered the standard Nest way of manipulating responses. Another approach is to use a library-specific [response object](https://expressjs.com/en/api.html#res). To inject a specific response object, we can use the `@Res()` decorator. To highlight the differences, let’s rewrite the `CatsController` like this:

content\_copy

JS  TS

```typescript

import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Controller('cats')
export class CatsController {
  @Post()
  create(@Res() res: Response) {
    res.status(HttpStatus.CREATED).send();
  }

  @Get()
  findAll(@Res() res: Response) {
     res.status(HttpStatus.OK).json([]);
  }
}

```

```typescript

import { Controller, Get, Post, Bind, Res, Body, HttpStatus } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Post()
  @Bind(Res(), Body())
  create(res, createCatDto) {
    res.status(HttpStatus.CREATED).send();
  }

  @Get()
  @Bind(Res())
  findAll(res) {
     res.status(HttpStatus.OK).json([]);
  }
}

```

While this approach works and offers more flexibility by giving full control over the response object (such as header manipulation and access to library-specific features), it should be used with caution. Generally, this method is less clear and comes with some downsides. The main disadvantage is that your code becomes platform-dependent, as different underlying libraries may have different APIs for the response object. Additionally, it can make testing more challenging, as you'll need to mock the response object, among other things.

Furthermore, by using this approach, you lose compatibility with Nest features that rely on standard response handling, such as Interceptors and the `@HttpCode()` / `@Header()` decorators. To address this, you can enable the `passthrough` option like this:

content\_copy

JS  TS

```typescript

@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.status(HttpStatus.OK);
  return [];
}

```

```typescript

@Get()
@Bind(Res({ passthrough: true }))
findAll(res) {
  res.status(HttpStatus.OK);
  return [];
}

```

With this approach, you can interact with the native response object (for example, setting cookies or headers based on specific conditions), while still allowing the framework to handle the rest.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Providers Overview
- [Providers](https://docs.nestjs.com/providers#providers)
- [Services](https://docs.nestjs.com/providers#services)
- [Dependency injection](https://docs.nestjs.com/providers#dependency-injection)
- [Scopes](https://docs.nestjs.com/providers#scopes)
- [Custom providers](https://docs.nestjs.com/providers#custom-providers)
- [Optional providers](https://docs.nestjs.com/providers#optional-providers)
- [Property-based injection](https://docs.nestjs.com/providers#property-based-injection)
- [Provider registration](https://docs.nestjs.com/providers#provider-registration)
- [Manual instantiation](https://docs.nestjs.com/providers#manual-instantiation)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/components.md "Suggest Edits")

### Providers

Providers are a core concept in Nest. Many of the basic Nest classes, such as services, repositories, factories, and helpers, can be treated as providers. The key idea behind a provider is that it can be **injected** as a dependency, allowing objects to form various relationships with each other. The responsibility of "wiring up" these objects is largely handled by the Nest runtime system.

![](https://docs.nestjs.com/assets/Components_1.png)

In the previous chapter, we created a simple `CatsController`. Controllers should handle HTTP requests and delegate more complex tasks to **providers**. Providers are plain JavaScript classes declared as `providers` in a NestJS module. For more details, refer to the "Modules" chapter.

> **Hint** Since Nest enables you to design and organize dependencies in an object-oriented manner, we strongly recommend following the [SOLID principles](https://en.wikipedia.org/wiki/SOLID).

#### Services [\#](https://docs.nestjs.com/providers\#services)

Let's begin by creating a simple `CatsService`. This service will handle data storage and retrieval, and it will be used by the `CatsController`. Because of its role in managing the application's logic, it’s an ideal candidate to be defined as a provider.

content\_copy cats.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class CatsService {
  constructor() {
    this.cats = [];
  }

  create(cat) {
    this.cats.push(cat);
  }

  findAll() {
    return this.cats;
  }
}

```

> **Hint** To create a service using the CLI, simply execute the `$ nest g service cats` command.

Our `CatsService` is a basic class with one property and two methods. The key addition here is the `@Injectable()` decorator. This decorator attaches metadata to the class, signaling that `CatsService` is a class that can be managed by the Nest [IoC](https://en.wikipedia.org/wiki/Inversion_of_control) container.

Additionally, this example makes use of a `Cat` interface, which likely looks something like this:

content\_copy interfaces/cat.interface.ts

JS  TS

```typescript

export interface Cat {
  name: string;
  age: number;
  breed: string;
}

```

Now that we have a service class to retrieve cats, let's use it inside the `CatsController`:

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}

```

```typescript

import { Controller, Get, Post, Body, Bind, Dependencies } from '@nestjs/common';
import { CatsService } from './cats.service';

@Controller('cats')
@Dependencies(CatsService)
export class CatsController {
  constructor(catsService) {
    this.catsService = catsService;
  }

  @Post()
  @Bind(Body())
  async create(createCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll() {
    return this.catsService.findAll();
  }
}

```

The `CatsService` is **injected** through the class constructor. Notice the use of the `private` keyword. This shorthand allows us to both declare and initialize the `catsService` member in the same line, streamlining the process.

#### Dependency injection [\#](https://docs.nestjs.com/providers\#dependency-injection)

Nest is built around the powerful design pattern known as **Dependency Injection**. We highly recommend reading a great article about this concept in the official [Angular documentation](https://angular.dev/guide/di).

In Nest, thanks to TypeScript's capabilities, managing dependencies is straightforward because they are resolved based on their type. In the example below, Nest will resolve the `catsService` by creating and returning an instance of `CatsService` (or, in the case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is then injected into your controller's constructor (or assigned to the specified property):

content\_copy

```typescript

constructor(private catsService: CatsService) {}

```

#### Scopes [\#](https://docs.nestjs.com/providers\#scopes)

Providers typically have a lifetime ("scope") that aligns with the application lifecycle. When the application is bootstrapped, each dependency must be resolved, meaning every provider gets instantiated. Similarly, when the application shuts down, all providers are destroyed. However, it’s also possible to make a provider **request-scoped**, meaning its lifetime is tied to a specific request rather than the application's lifecycle. You can learn more about these techniques in the [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes) chapter.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Custom providers [\#](https://docs.nestjs.com/providers\#custom-providers)

Nest comes with a built-in inversion of control ("IoC") container that manages the relationships between providers. This feature is the foundation of dependency injection, but it’s actually much more powerful than we've covered so far. There are several ways to define a provider: you can use plain values, classes, and both asynchronous or synchronous factories. For more examples of defining providers, check out the [Dependency Injection](https://docs.nestjs.com/fundamentals/dependency-injection) chapter.

#### Optional providers [\#](https://docs.nestjs.com/providers\#optional-providers)

Occasionally, you may have dependencies that don't always need to be resolved. For example, your class might depend on a **configuration object**, but if none is provided, default values should be used. In such cases, the dependency is considered optional, and the absence of the configuration provider should not result in an error.

To mark a provider as optional, use the `@Optional()` decorator in the constructor's signature.

content\_copy

```typescript

import { Injectable, Optional, Inject } from '@nestjs/common';

@Injectable()
export class HttpService<T> {
  constructor(@Optional() @Inject('HTTP_OPTIONS') private httpClient: T) {}
}

```

In the example above, we're using a custom provider, which is why we include the `HTTP_OPTIONS` custom **token**. Previous examples demonstrated constructor-based injection, where a dependency is indicated through a class in the constructor. For more details on custom providers and how their associated tokens work, check out the [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers) chapter.

#### Property-based injection [\#](https://docs.nestjs.com/providers\#property-based-injection)

The technique we've used so far is called constructor-based injection, where providers are injected through the constructor method. In certain specific cases, **property-based injection** can be useful. For example, if your top-level class depends on one or more providers, passing them all the way up through `super()` in sub-classes can become cumbersome. To avoid this, you can use the `@Inject()` decorator directly at the property level.

content\_copy

```typescript

import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class HttpService<T> {
  @Inject('HTTP_OPTIONS')
  private readonly httpClient: T;
}

```

> **Warning** If your class doesn't extend another class, it's generally better to use **constructor-based** injection. The constructor clearly specifies which dependencies are required, offering better visibility and making the code easier to understand compared to class properties annotated with `@Inject`.

#### Provider registration [\#](https://docs.nestjs.com/providers\#provider-registration)

Now that we've defined a provider ( `CatsService`) and a consumer ( `CatsController`), we need to register the service with Nest so that it can handle the injection. This is done by editing the module file ( `app.module.ts`) and adding the service to the `providers` array in the `@Module()` decorator.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats/cats.controller';
import { CatsService } from './cats/cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class AppModule {}

```

Nest will now be able to resolve the dependencies of the `CatsController` class.

At this point, our directory structure should look like this:

src

cats

dto

create-cat.dto.ts

interfaces

cat.interface.ts

cats.controller.ts

cats.service.ts

app.module.ts

main.ts

#### Manual instantiation [\#](https://docs.nestjs.com/providers\#manual-instantiation)

So far, we've covered how Nest automatically handles most of the details of resolving dependencies. However, in some cases, you might need to step outside of the built-in Dependency Injection system and manually retrieve or instantiate providers. Two such techniques are briefly discussed below.

- To retrieve existing instances or instantiate providers dynamically, you can use the [Module reference](https://docs.nestjs.com/fundamentals/module-ref).
- To get providers within the `bootstrap()` function (e.g., for standalone applications or to use a configuration service during bootstrapping), check out [Standalone applications](https://docs.nestjs.com/standalone-applications).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Pipes Overview
- [Pipes](https://docs.nestjs.com/pipes#pipes)
- [Built-in pipes](https://docs.nestjs.com/pipes#built-in-pipes)
- [Binding pipes](https://docs.nestjs.com/pipes#binding-pipes)
- [Custom pipes](https://docs.nestjs.com/pipes#custom-pipes)
- [Schema based validation](https://docs.nestjs.com/pipes#schema-based-validation)
- [Object schema validation](https://docs.nestjs.com/pipes#object-schema-validation)
- [Binding validation pipes](https://docs.nestjs.com/pipes#binding-validation-pipes)
- [Class validator](https://docs.nestjs.com/pipes#class-validator)
- [Global scoped pipes](https://docs.nestjs.com/pipes#global-scoped-pipes)
- [The built-in ValidationPipe](https://docs.nestjs.com/pipes#the-built-in-validationpipe)
- [Transformation use case](https://docs.nestjs.com/pipes#transformation-use-case)
- [Providing defaults](https://docs.nestjs.com/pipes#providing-defaults)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/pipes.md "Suggest Edits")

### Pipes

A pipe is a class annotated with the `@Injectable()` decorator, which implements the `PipeTransform` interface.

![](https://docs.nestjs.com/assets/Pipe_1.png)

Pipes have two typical use cases:

- **transformation**: transform input data to the desired form (e.g., from string to integer)
- **validation**: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception

In both cases, pipes operate on the `arguments` being processed by a [controller route handler](https://docs.nestjs.com/controllers#route-parameters). Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments.

Nest comes with a number of built-in pipes that you can use out-of-the-box. You can also build your own custom pipes. In this chapter, we'll introduce the built-in pipes and show how to bind them to route handlers. We'll then examine several custom-built pipes to show how you can build one from scratch.

> **Hint** Pipes run inside the exceptions zone. This means that when a Pipe throws an exception it is handled by the exceptions layer (global exceptions filter and any [exceptions filters](https://docs.nestjs.com/exception-filters) that are applied to the current context). Given the above, it should be clear that when an exception is thrown in a Pipe, no controller method is subsequently executed. This gives you a best-practice technique for validating data coming into the application from external sources at the system boundary.

#### Built-in pipes [\#](https://docs.nestjs.com/pipes\#built-in-pipes)

Nest comes with several pipes available out-of-the-box:

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`
- `ParseFilePipe`
- `ParseDatePipe`

They're exported from the `@nestjs/common` package.

Let's take a quick look at using `ParseIntPipe`. This is an example of the **transformation** use case, where the pipe ensures that a method handler parameter is converted to a JavaScript integer (or throws an exception if the conversion fails). Later in this chapter, we'll show a simple custom implementation for a `ParseIntPipe`. The example techniques below also apply to the other built-in transformation pipes ( `ParseBoolPipe`, `ParseFloatPipe`, `ParseEnumPipe`, `ParseArrayPipe`, `ParseDatePipe`, and `ParseUUIDPipe`, which we'll refer to as the `Parse*` pipes in this chapter).

#### Binding pipes [\#](https://docs.nestjs.com/pipes\#binding-pipes)

To use a pipe, we need to bind an instance of the pipe class to the appropriate context. In our `ParseIntPipe` example, we want to associate the pipe with a particular route handler method, and make sure it runs before the method is called. We do so with the following construct, which we'll refer to as binding the pipe at the method parameter level:

content\_copy

```typescript

@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}

```

This ensures that one of the following two conditions is true: either the parameter we receive in the `findOne()` method is a number (as expected in our call to `this.catsService.findOne()`), or an exception is thrown before the route handler is called.

For example, assume the route is called like:

```bash

GET localhost:3000/abc

```

Nest will throw an exception like this:

```json

{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}

```

The exception will prevent the body of the `findOne()` method from executing.

In the example above, we pass a class ( `ParseIntPipe`), not an instance, leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and guards, we can instead pass an in-place instance. Passing an in-place instance is useful if we want to customize the built-in pipe's behavior by passing options:

content\_copy

```typescript

@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}

```

Binding the other transformation pipes (all of the **Parse\*** pipes) works similarly. These pipes all work in the context of validating route parameters, query string parameters and request body values.

For example with a query string parameter:

content\_copy

```typescript

@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}

```

Here's an example of using the `ParseUUIDPipe` to parse a string parameter and validate if it is a UUID.

content\_copy

JS  TS

```typescript

@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}

```

```typescript

@Get(':uuid')
@Bind(Param('uuid', new ParseUUIDPipe()))
async findOne(uuid) {
  return this.catsService.findOne(uuid);
}

```

> **Hint** When using `ParseUUIDPipe()` you are parsing UUID in version 3, 4 or 5, if you only require a specific version of UUID you can pass a version in the pipe options.

Above we've seen examples of binding the various `Parse*` family of built-in pipes. Binding validation pipes is a little bit different; we'll discuss that in the following section.

> **Hint** Also, see [Validation techniques](https://docs.nestjs.com/techniques/validation) for extensive examples of validation pipes.

#### Custom pipes [\#](https://docs.nestjs.com/pipes\#custom-pipes)

As mentioned, you can build your own custom pipes. While Nest provides a robust built-in `ParseIntPipe` and `ValidationPipe`, let's build simple custom versions of each from scratch to see how custom pipes are constructed.

We start with a simple `ValidationPipe`. Initially, we'll have it simply take an input value and immediately return the same value, behaving like an identity function.

content\_copy validation.pipe.ts

JS  TS

```typescript

import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class ValidationPipe {
  transform(value, metadata) {
    return value;
  }
}

```

> **Hint** `PipeTransform<T, R>` is a generic interface that must be implemented by any pipe. The generic interface uses `T` to indicate the type of the input `value`, and `R` to indicate the return type of the `transform()` method.

Every pipe must implement the `transform()` method to fulfill the `PipeTransform` interface contract. This method has two parameters:

- `value`
- `metadata`

The `value` parameter is the currently processed method argument (before it is received by the route handling method), and `metadata` is the currently processed method argument's metadata. The metadata object has these properties:

content\_copy

```typescript

export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}

```

These properties describe the currently processed argument.

|     |     |
| --- | --- |
| `type` | Indicates whether the argument is a body `@Body()`, query `@Query()`, param `@Param()`, or a custom parameter (read more [here](https://docs.nestjs.com/custom-decorators)). |
| `metatype` | Provides the metatype of the argument, for example, `String`. Note: the value is `undefined` if you either omit a type declaration in the route handler method signature, or use vanilla JavaScript. |
| `data` | The string passed to the decorator, for example `@Body('string')`. It's `undefined` if you leave the decorator parenthesis empty. |

> **Warning** TypeScript interfaces disappear during transpilation. Thus, if a method parameter's type is declared as an interface instead of a class, the `metatype` value will be `Object`.

#### Schema based validation [\#](https://docs.nestjs.com/pipes\#schema-based-validation)

Let's make our validation pipe a little more useful. Take a closer look at the `create()` method of the `CatsController`, where we probably would like to ensure that the post body object is valid before attempting to run our service method.

content\_copy

JS  TS

```typescript

@Post()
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
async create(@Body() createCatDto) {
  this.catsService.create(createCatDto);
}

```

Let's focus in on the `createCatDto` body parameter. Its type is `CreateCatDto`:

content\_copy create-cat.dto.ts

JS  TS

```typescript

export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

```

We want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the `createCatDto` object. We could do this inside the route handler method, but doing so is not ideal as it would break the **single responsibility principle** (SRP).

Another approach could be to create a **validator class** and delegate the task there. This has the disadvantage that we would have to remember to call this validator at the beginning of each method.

How about creating validation middleware? This could work, but unfortunately, it's not possible to create **generic middleware** which can be used across all contexts across the whole application. This is because middleware is unaware of the **execution context**, including the handler that will be called and any of its parameters.

This is, of course, exactly the use case for which pipes are designed. So let's go ahead and refine our validation pipe.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Object schema validation [\#](https://docs.nestjs.com/pipes\#object-schema-validation)

There are several approaches available for doing object validation in a clean, [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) way. One common approach is to use **schema-based** validation. Let's go ahead and try that approach.

The [Zod](https://zod.dev/) library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Zod-based schemas.

Start by installing the required package:

```bash

$ npm install --save zod

```

In the code sample below, we create a simple class that takes a schema as a `constructor` argument. We then apply the `schema.parse()` method, which validates our incoming argument against the provided schema.

As noted earlier, a **validation pipe** either returns the value unchanged or throws an exception.

In the next section, you'll see how we supply the appropriate schema for a given controller method using the `@UsePipes()` decorator. Doing so makes our validation pipe reusable across contexts, just as we set out to do.

content\_copy

JS  TS

```typescript

import { PipeTransform, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { ZodSchema  } from 'zod';

export class ZodValidationPipe implements PipeTransform {
  constructor(private schema: ZodSchema) {}

  transform(value: unknown, metadata: ArgumentMetadata) {
    try {
      const parsedValue = this.schema.parse(value);
      return parsedValue;
    } catch (error) {
      throw new BadRequestException('Validation failed');
    }
  }
}

```

```typescript

import { BadRequestException } from '@nestjs/common';

export class ZodValidationPipe {
  constructor(private schema) {}

  transform(value, metadata) {
    try {
      const parsedValue = this.schema.parse(value);
      return parsedValue;
    } catch (error) {
      throw new BadRequestException('Validation failed');
    }
  }
}

```

#### Binding validation pipes [\#](https://docs.nestjs.com/pipes\#binding-validation-pipes)

Earlier, we saw how to bind transformation pipes (like `ParseIntPipe` and the rest of the `Parse*` pipes).

Binding validation pipes is also very straightforward.

In this case, we want to bind the pipe at the method call level. In our current example, we need to do the following to use the `ZodValidationPipe`:

1. Create an instance of the `ZodValidationPipe`
2. Pass the context-specific Zod schema in the class constructor of the pipe
3. Bind the pipe to the method

Zod schema example:

content\_copy

```typescript

import { z } from 'zod';

export const createCatSchema = z
  .object({
    name: z.string(),
    age: z.number(),
    breed: z.string(),
  })
  .required();

export type CreateCatDto = z.infer<typeof createCatSchema>;

```

We do that using the `@UsePipes()` decorator as shown below:

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@UsePipes(new ZodValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

```typescript

@Post()
@Bind(Body())
@UsePipes(new ZodValidationPipe(createCatSchema))
async create(createCatDto) {
  this.catsService.create(createCatDto);
}

```

> **Hint** The `@UsePipes()` decorator is imported from the `@nestjs/common` package.

> **Warning** `zod` library requires the `strictNullChecks` configuration to be enabled in your `tsconfig.json` file.

#### Class validator [\#](https://docs.nestjs.com/pipes\#class-validator)

> **Warning** The techniques in this section require TypeScript and are not available if your app is written using vanilla JavaScript.

Let's look at an alternate implementation for our validation technique.

Nest works well with the [class-validator](https://github.com/typestack/class-validator) library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's **Pipe** capabilities since we have access to the `metatype` of the processed property. Before we start, we need to install the required packages:

```bash

$ npm i --save class-validator class-transformer

```

Once these are installed, we can add a few decorators to the `CreateCatDto` class. Here we see a significant advantage of this technique: the `CreateCatDto` class remains the single source of truth for our Post body object (rather than having to create a separate validation class).

content\_copy create-cat.dto.ts

JS  TS

```typescript

import { IsString, IsInt } from 'class-validator';

export class CreateCatDto {
  @IsString()
  name: string;

  @IsInt()
  age: number;

  @IsString()
  breed: string;
}

```

> **Hint** Read more about the class-validator decorators [here](https://github.com/typestack/class-validator#usage).

Now we can create a `ValidationPipe` class that uses these annotations.

content\_copy validation.pipe.ts

JS  TS

```typescript

import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToInstance(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}

```

> **Hint** As a reminder, you don't have to build a generic validation pipe on your own since the `ValidationPipe` is provided by Nest out-of-the-box. The built-in `ValidationPipe` offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples [here](https://docs.nestjs.com/techniques/validation).

> **Notice** We used the [class-transformer](https://github.com/typestack/class-transformer) library above which is made by the same author as the **class-validator** library, and as a result, they play very well together.

Let's go through this code. First, note that the `transform()` method is marked as `async`. This is possible because Nest supports both synchronous and **asynchronous** pipes. We make this method `async` because some of the class-validator validations [can be async](https://github.com/typestack/class-validator#custom-validation-classes) (utilize Promises).

Next note that we are using destructuring to extract the metatype field (extracting just this member from an `ArgumentMetadata`) into our `metatype` parameter. This is just shorthand for getting the full `ArgumentMetadata` and then having an additional statement to assign the metatype variable.

Next, note the helper function `toValidate()`. It's responsible for bypassing the validation step when the current argument being processed is a native JavaScript type (these can't have validation decorators attached, so there's no reason to run them through the validation step).

Next, we use the class-transformer function `plainToInstance()` to transform our plain JavaScript argument object into a typed object so that we can apply validation. The reason we must do this is that the incoming post body object, when deserialized from the network request, does **not have any type information** (this is the way the underlying platform, such as Express, works). Class-validator needs to use the validation decorators we defined for our DTO earlier, so we need to perform this transformation to treat the incoming body as an appropriately decorated object, not just a plain vanilla object.

Finally, as noted earlier, since this is a **validation pipe** it either returns the value unchanged, or throws an exception.

The last step is to bind the `ValidationPipe`. Pipes can be parameter-scoped, method-scoped, controller-scoped, or global-scoped. Earlier, with our Zod-based validation pipe, we saw an example of binding the pipe at the method level.
In the example below, we'll bind the pipe instance to the route handler `@Body()` decorator so that our pipe is called to validate the post body.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}

```

Parameter-scoped pipes are useful when the validation logic concerns only one specified parameter.

#### Global scoped pipes [\#](https://docs.nestjs.com/pipes\#global-scoped-pipes)

Since the `ValidationPipe` was created to be as generic as possible, we can realize its full utility by setting it up as a **global-scoped** pipe so that it is applied to every route handler across the entire application.

content\_copy main.ts

JS  TS

```typescript

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

> **Notice** In the case of [hybrid apps](https://docs.nestjs.com/faq/hybrid-application) the `useGlobalPipes()` method doesn't set up pipes for gateways and microservices. For "standard" (non-hybrid) microservice apps, `useGlobalPipes()` does mount pipes globally.

Global pipes are used across the whole application, for every controller and every route handler.

Note that in terms of dependency injection, global pipes registered from outside of any module (with `useGlobalPipes()` as in the example above) cannot inject dependencies since the binding has been done outside the context of any module. In order to solve this issue, you can set up a global pipe **directly from any module** using the following construction:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { APP_PIPE } from '@nestjs/core';

@Module({
  providers: [\
    {\
      provide: APP_PIPE,\
      useClass: ValidationPipe,\
    },\
  ],
})
export class AppModule {}

```

> **Hint** When using this approach to perform dependency injection for the pipe, note that regardless of the module where this construction is employed, the pipe is, in fact, global. Where should this be done? Choose the module where the pipe ( `ValidationPipe` in the example above) is defined. Also, `useClass` is not the only way of dealing with custom provider registration. Learn more [here](https://docs.nestjs.com/fundamentals/custom-providers).

#### The built-in ValidationPipe [\#](https://docs.nestjs.com/pipes\#the-built-in-validationpipe)

As a reminder, you don't have to build a generic validation pipe on your own since the `ValidationPipe` is provided by Nest out-of-the-box. The built-in `ValidationPipe` offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples [here](https://docs.nestjs.com/techniques/validation).

#### Transformation use case [\#](https://docs.nestjs.com/pipes\#transformation-use-case)

Validation isn't the only use case for custom pipes. At the beginning of this chapter, we mentioned that a pipe can also **transform** the input data to the desired format. This is possible because the value returned from the `transform` function completely overrides the previous value of the argument.

When is this useful? Consider that sometimes the data passed from the client needs to undergo some change - for example converting a string to an integer - before it can be properly handled by the route handler method. Furthermore, some required data fields may be missing, and we would like to apply default values. **Transformation pipes** can perform these functions by interposing a processing function between the client request and the request handler.

Here's a simple `ParseIntPipe` which is responsible for parsing a string into an integer value. (As noted above, Nest has a built-in `ParseIntPipe` that is more sophisticated; we include this as a simple example of a custom transformation pipe).

content\_copy parse-int.pipe.ts

JS  TS

```typescript

import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}

```

```typescript

import { Injectable, BadRequestException } from '@nestjs/common';

@Injectable()
export class ParseIntPipe {
  transform(value, metadata) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}

```

We can then bind this pipe to the selected param as shown below:

content\_copy

JS  TS

```typescript

@Get(':id')
async findOne(@Param('id', new ParseIntPipe()) id) {
  return this.catsService.findOne(id);
}

```

```typescript

@Get(':id')
@Bind(Param('id', new ParseIntPipe()))
async findOne(id) {
  return this.catsService.findOne(id);
}

```

Another useful transformation case would be to select an **existing user** entity from the database using an id supplied in the request:

content\_copy

JS  TS

```typescript

@Get(':id')
findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {
  return userEntity;
}

```

```typescript

@Get(':id')
@Bind(Param('id', UserByIdPipe))
findOne(userEntity) {
  return userEntity;
}

```

We leave the implementation of this pipe to the reader, but note that like all other transformation pipes, it receives an input value (an `id`) and returns an output value (a `UserEntity` object). This can make your code more declarative and [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) by abstracting boilerplate code out of your handler and into a common pipe.

#### Providing defaults [\#](https://docs.nestjs.com/pipes\#providing-defaults)

`Parse*` pipes expect a parameter's value to be defined. They throw an exception upon receiving `null` or `undefined` values. To allow an endpoint to handle missing querystring parameter values, we have to provide a default value to be injected before the `Parse*` pipes operate on these values. The `DefaultValuePipe` serves that purpose. Simply instantiate a `DefaultValuePipe` in the `@Query()` decorator before the relevant `Parse*` pipe, as shown below:

content\_copy

JS  TS

```typescript

@Get()
async findAll(
  @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,
  @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,
) {
  return this.catsService.findAll({ activeOnly, page });
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Community Support
- [Support](https://docs.nestjs.com/support#support)
- [How can you help?](https://docs.nestjs.com/support#how-can-you-help)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/support.md "Suggest Edits")

### Support

Nest is an MIT-licensed open source project with its ongoing development made possible thanks to the support by the community. This framework is a result of the long road, full of sleepless nights, working **after hours**, and busy weekends.

#### How can you help? [\#](https://docs.nestjs.com/support\#how-can-you-help)

Nest doesn't have a large company that sits behind and is continuously paying for hours spent on the development. I fully rely on the **goodness** ❤️ of the people. However, I would love to make this framework even more **powerful**, to be fully focused on delivering you great solutions that make coding process enjoyable: In order to help me, I run few supporting platforms:

- become a backer or sponsor on [OpenCollective](https://opencollective.com/nest)
- use [PayPal](https://paypal.me/kamilmysliwiec) to send a one-time donation
- or reach me directly: [mail@kamilmysliwiec.com](mailto:mail@kamilmysliwiec.com)

If you fell in love with Nest, or you run a business which is using Nest, consider sponsoring its development to ensure that the project which your product relies on is **actively maintained** and improved. Also, your support could help me to work more on content that benefits whole Nest community, writing either educational blog posts or recording videos.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Middleware Guide
- [Middleware](https://docs.nestjs.com/middleware#middleware)
- [Dependency injection](https://docs.nestjs.com/middleware#dependency-injection)
- [Applying middleware](https://docs.nestjs.com/middleware#applying-middleware)
- [Route wildcards](https://docs.nestjs.com/middleware#route-wildcards)
- [Middleware consumer](https://docs.nestjs.com/middleware#middleware-consumer)
- [Excluding routes](https://docs.nestjs.com/middleware#excluding-routes)
- [Functional middleware](https://docs.nestjs.com/middleware#functional-middleware)
- [Multiple middleware](https://docs.nestjs.com/middleware#multiple-middleware)
- [Global middleware](https://docs.nestjs.com/middleware#global-middleware)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/middlewares.md "Suggest Edits")

### Middleware

Middleware is a function which is called **before** the route handler. Middleware functions have access to the [request](https://expressjs.com/en/4x/api.html#req) and [response](https://expressjs.com/en/4x/api.html#res) objects, and the `next()` middleware function in the application’s request-response cycle. The **next** middleware function is commonly denoted by a variable named `next`.

![](https://docs.nestjs.com/assets/Middlewares_1.png)

Nest middleware are, by default, equivalent to [express](https://expressjs.com/en/guide/using-middleware.html) middleware. The following description from the official express documentation describes the capabilities of middleware:

> Middleware functions can perform the following tasks:
>
> - execute any code.
> - make changes to the request and the response objects.
> - end the request-response cycle.
> - call the next middleware function in the stack.
> - if the current middleware function does not end the request-response cycle, it must call `next()` to pass control to the next middleware function. Otherwise, the request will be left hanging.

You implement custom Nest middleware in either a function, or in a class with an `@Injectable()` decorator. The class should implement the `NestMiddleware` interface, while the function does not have any special requirements. Let's start by implementing a simple middleware feature using the class method.

> **Warning** `Express` and `fastify` handle middleware differently and provide different method signatures, read more [here](https://docs.nestjs.com/techniques/performance#middleware).

content\_copy logger.middleware.ts

JS  TS

```typescript

import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('Request...');
    next();
  }
}

```

```typescript

import { Injectable } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware {
  use(req, res, next) {
    console.log('Request...');
    next();
  }
}

```

#### Dependency injection [\#](https://docs.nestjs.com/middleware\#dependency-injection)

Nest middleware fully supports Dependency Injection. Just as with providers and controllers, they are able to **inject dependencies** that are available within the same module. As usual, this is done through the `constructor`.

#### Applying middleware [\#](https://docs.nestjs.com/middleware\#applying-middleware)

There is no place for middleware in the `@Module()` decorator. Instead, we set them up using the `configure()` method of the module class. Modules that include middleware have to implement the `NestModule` interface. Let's set up the `LoggerMiddleware` at the `AppModule` level.

content\_copy app.module.ts

JS  TS

```typescript

import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('cats');
  }
}

```

```typescript

import { Module } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {
  configure(consumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('cats');
  }
}

```

In the above example we have set up the `LoggerMiddleware` for the `/cats` route handlers that were previously defined inside the `CatsController`. We may also further restrict a middleware to a particular request method by passing an object containing the route `path` and request `method` to the `forRoutes()` method when configuring the middleware. In the example below, notice that we import the `RequestMethod` enum to reference the desired request method type.

content\_copy app.module.ts

JS  TS

```typescript

import { Module, NestModule, RequestMethod, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes({ path: 'cats', method: RequestMethod.GET });
  }
}

```

```typescript

import { Module, RequestMethod } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {
  configure(consumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes({ path: 'cats', method: RequestMethod.GET });
  }
}

```

> **Hint** The `configure()` method can be made asynchronous using `async/await` (e.g., you can `await` completion of an asynchronous operation inside the `configure()` method body).

> **Warning** When using the `express` adapter, the NestJS app will register `json` and `urlencoded` from the package `body-parser` by default. This means if you want to customize that middleware via the `MiddlewareConsumer`, you need to turn off the global middleware by setting the `bodyParser` flag to `false` when creating the application with `NestFactory.create()`.

#### Route wildcards [\#](https://docs.nestjs.com/middleware\#route-wildcards)

Pattern-based routes are also supported in NestJS middleware. For example, the named wildcard ( `*splat`) can be used as a wildcard to match any combination of characters in a route. In the following example, the middleware will be executed for any route that starts with `abcd/`, regardless of the number of characters that follow.

content\_copy

```typescript

forRoutes({
  path: 'abcd/*splat',
  method: RequestMethod.ALL,
});

```

> **Hint** `splat` is simply the name of the wildcard parameter and has no special meaning. You can name it anything you like, for example, `*wildcard`.

The `'abcd/*'` route path will match `abcd/1`, `abcd/123`, `abcd/abc`, and so on. The hyphen ( `-`) and the dot ( `.`) are interpreted literally by string-based paths. However, `abcd/` with no additional characters will not match the route. For this, you need to wrap the wildcard in braces to make it optional:

content\_copy

```typescript

forRoutes({
  path: 'abcd/{*splat}',
  method: RequestMethod.ALL,
});

```

#### Middleware consumer [\#](https://docs.nestjs.com/middleware\#middleware-consumer)

The `MiddlewareConsumer` is a helper class. It provides several built-in methods to manage middleware. All of them can be simply **chained** in the [fluent style](https://en.wikipedia.org/wiki/Fluent_interface). The `forRoutes()` method can take a single string, multiple strings, a `RouteInfo` object, a controller class and even multiple controller classes. In most cases you'll probably just pass a list of **controllers** separated by commas. Below is an example with a single controller:

content\_copy app.module.ts

JS  TS

```typescript

import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';
import { CatsController } from './cats/cats.controller';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(CatsController);
  }
}

```

```typescript

import { Module } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';
import { CatsController } from './cats/cats.controller';

@Module({
  imports: [CatsModule],
})
export class AppModule {
  configure(consumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(CatsController);
  }
}

```

> **Hint** The `apply()` method may either take a single middleware, or multiple arguments to specify [multiple middlewares](https://docs.nestjs.com/middleware#multiple-middleware).

#### Excluding routes [\#](https://docs.nestjs.com/middleware\#excluding-routes)

At times, we may want to **exclude** certain routes from having middleware applied. This can be easily achieved using the `exclude()` method. The `exclude()` method accepts a single string, multiple strings, or a `RouteInfo` object to identify the routes to be excluded.

Here's an example of how to use it:

content\_copy

```typescript

consumer
  .apply(LoggerMiddleware)
  .exclude(
    { path: 'cats', method: RequestMethod.GET },
    { path: 'cats', method: RequestMethod.POST },
    'cats/{*splat}',
  )
  .forRoutes(CatsController);

```

> **Hint** The `exclude()` method supports wildcard parameters using the [path-to-regexp](https://github.com/pillarjs/path-to-regexp#parameters) package.

With the example above, `LoggerMiddleware` will be bound to all routes defined inside `CatsController` **except** the three passed to the `exclude()` method.

This approach provides flexibility in applying or excluding middleware based on specific routes or route patterns.

#### Functional middleware [\#](https://docs.nestjs.com/middleware\#functional-middleware)

The `LoggerMiddleware` class we've been using is quite simple. It has no members, no additional methods, and no dependencies. Why can't we just define it in a simple function instead of a class? In fact, we can. This type of middleware is called **functional middleware**. Let's transform the logger middleware from class-based into functional middleware to illustrate the difference:

content\_copy logger.middleware.ts

JS  TS

```typescript

import { Request, Response, NextFunction } from 'express';

export function logger(req: Request, res: Response, next: NextFunction) {
  console.log(`Request...`);
  next();
};

```

```typescript

export function logger(req, res, next) {
  console.log(`Request...`);
  next();
};

```

And use it within the `AppModule`:

content\_copy app.module.ts

JS  TS

```typescript

consumer
  .apply(logger)
  .forRoutes(CatsController);

```

> **Hint** Consider using the simpler **functional middleware** alternative any time your middleware doesn't need any dependencies.

#### Multiple middleware [\#](https://docs.nestjs.com/middleware\#multiple-middleware)

As mentioned above, in order to bind multiple middleware that are executed sequentially, simply provide a comma separated list inside the `apply()` method:

content\_copy

```typescript

consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);

```

#### Global middleware [\#](https://docs.nestjs.com/middleware\#global-middleware)

If we want to bind middleware to every registered route at once, we can use the `use()` method that is supplied by the `INestApplication` instance:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
app.use(logger);
await app.listen(process.env.PORT ?? 3000);

```

> **Hint** Accessing the DI container in a global middleware is not possible. You can use a [functional middleware](https://docs.nestjs.com/middleware#functional-middleware) instead when using `app.use()`. Alternatively, you can use a class middleware and consume it with `.forRoutes('*')` within the `AppModule` (or any other module).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Support NestJS
### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Framework
### Introduction

Nest is a framework for building efficient, scalable [Node.js](http://nodejs.org/) server-side applications. It uses modern JavaScript, is built with [TypeScript](http://www.typescriptlang.org/) (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

Under the hood, Nest makes use of [Express](https://expressjs.com/), allowing for easy use of the myriad third-party plugins which are available.

### Philosophy

In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like [Angular](https://angular.io/), [React](https://github.com/facebook/react) and [Vue](https://github.com/vuejs/vue) which improve developer productivity and enable the construction of fast, testable, extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers and tools for Node, none of them effectively solve the main problem - the architecture.

Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, loosely coupled and easily maintainable applications.

### Installation

Install the starter project with **Git**:

JavaScript

TypeScript


```  bash

$ git clone https://github.com/nestjs/typescript-starter.git project
$ cd project
$ npm install
$ npm run start
```

```  bash

$ git clone https://github.com/nestjs/javascript-starter.git project
$ cd project
$ npm install
$ npm run start
```

Start a New Project from Scratch with **NPM**:

```  bash

$ npm i --save @nestjs/core @nestjs/common @nestjs/microservices @nestjs/websockets @nestjs/testing reflect-metadata rxjs
```

### People

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com/ "Kamil Mysliwiec Blog | Full-Stack Software Engineer")
- Website - [https://nestjs.com](https://nestjs.com/ "Nest - A node.js framework built on top of TypeScript")

#### Sponsors

[![](https://docs.nestjs.com/assets/sponsors/valor-software.png)](https://valor-software.com/)

Nest is an MIT-licensed open source project. It can grow thanks to the support by these awesome people. If you'd like to join them, please read more [here](https://opencollective.com/nest). Thanks!

[![](https://opencollective.com/nest/backer/0/avatar.svg)](https://opencollective.com/nest/backer/0/website)[![](https://opencollective.com/nest/backer/1/avatar.svg)](https://opencollective.com/nest/backer/1/website)[![](https://opencollective.com/nest/backer/2/avatar.svg)](https://opencollective.com/nest/backer/2/website)[![](https://opencollective.com/nest/backer/3/avatar.svg)](https://opencollective.com/nest/backer/3/website)[![](https://opencollective.com/nest/backer/4/avatar.svg)](https://opencollective.com/nest/backer/4/website)[![](https://opencollective.com/nest/backer/5/avatar.svg)](https://opencollective.com/nest/backer/5/website)[![](https://opencollective.com/nest/backer/6/avatar.svg)](https://opencollective.com/nest/backer/6/website)[![](https://opencollective.com/nest/backer/7/avatar.svg)](https://opencollective.com/nest/backer/7/website)[![](https://opencollective.com/nest/backer/8/avatar.svg)](https://opencollective.com/nest/backer/8/website)[![](https://opencollective.com/nest/backer/9/avatar.svg)](https://opencollective.com/nest/backer/9/website)[![](https://opencollective.com/nest/backer/10/avatar.svg)](https://opencollective.com/nest/backer/10/website)[![](https://opencollective.com/nest/backer/11/avatar.svg)](https://opencollective.com/nest/backer/11/website)[![](https://opencollective.com/nest/backer/12/avatar.svg)](https://opencollective.com/nest/backer/12/website)[![](https://opencollective.com/nest/backer/13/avatar.svg)](https://opencollective.com/nest/backer/13/website)[![](https://opencollective.com/nest/backer/14/avatar.svg)](https://opencollective.com/nest/backer/14/website)[![](https://opencollective.com/nest/backer/15/avatar.svg)](https://opencollective.com/nest/backer/15/website)[![](https://opencollective.com/nest/backer/16/avatar.svg)](https://opencollective.com/nest/backer/16/website)[![](https://opencollective.com/nest/backer/17/avatar.svg)](https://opencollective.com/nest/backer/17/website)[![](https://opencollective.com/nest/backer/18/avatar.svg)](https://opencollective.com/nest/backer/18/website)[![](https://opencollective.com/nest/backer/19/avatar.svg)](https://opencollective.com/nest/backer/19/website)[![](https://opencollective.com/nest/backer/20/avatar.svg)](https://opencollective.com/nest/backer/20/website)[![](https://opencollective.com/nest/backer/21/avatar.svg)](https://opencollective.com/nest/backer/21/website)[![](https://opencollective.com/nest/backer/22/avatar.svg)](https://opencollective.com/nest/backer/22/website)[![](https://opencollective.com/nest/backer/23/avatar.svg)](https://opencollective.com/nest/backer/23/website)[![](https://opencollective.com/nest/backer/24/avatar.svg)](https://opencollective.com/nest/backer/24/website)[![](https://opencollective.com/nest/backer/25/avatar.svg)](https://opencollective.com/nest/backer/25/website)[![](https://opencollective.com/nest/backer/26/avatar.svg)](https://opencollective.com/nest/backer/26/website)[![](https://opencollective.com/nest/backer/27/avatar.svg)](https://opencollective.com/nest/backer/27/website)[![](https://opencollective.com/nest/backer/28/avatar.svg)](https://opencollective.com/nest/backer/28/website)[![](https://opencollective.com/nest/backer/29/avatar.svg)](https://opencollective.com/nest/backer/29/website)

[Become a sponsor](https://opencollective.com/nest)

## NestJS Helmet Security
- [Helmet](https://docs.nestjs.com/security/helmet#helmet)
- [Use with Express (default)](https://docs.nestjs.com/security/helmet#use-with-express-default)
- [Use with Fastify](https://docs.nestjs.com/security/helmet#use-with-fastify)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/helmet.md "Suggest Edits")

### Helmet

[Helmet](https://github.com/helmetjs/helmet) can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately. Generally, Helmet is just a collection of smaller middleware functions that set security-related HTTP headers (read [more](https://github.com/helmetjs/helmet#how-it-works)).

> **Hint** Note that applying `helmet` as global or registering it must come before other calls to `app.use()` or setup functions that may call `app.use()`. This is due to the way the underlying platform (i.e., Express or Fastify) works, where the order that middleware/routes are defined matters. If you use middleware like `helmet` or `cors` after you define a route, then that middleware will not apply to that route, it will only apply to routes defined after the middleware.

#### Use with Express (default) [\#](https://docs.nestjs.com/security/helmet\#use-with-express-default)

Start by installing the required package.

```bash

$ npm i --save helmet

```

Once the installation is complete, apply it as a global middleware.

content\_copy

```typescript

import helmet from 'helmet';
// somewhere in your initialization file
app.use(helmet());

```

> **Warning** When using `helmet`, `@apollo/server` (4.x), and the [Apollo Sandbox](https://docs.nestjs.com/graphql/quick-start#apollo-sandbox), there may be a problem with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) on the Apollo Sandbox. To solve this issue configure the CSP as shown below:
> content\_copy
>
> ```typescript
>
> app.use(helmet({
>   crossOriginEmbedderPolicy: false,
>   contentSecurityPolicy: {
>     directives: {
>       imgSrc: [`'self'`, 'data:', 'apollo-server-landing-page.cdn.apollographql.com'],
>       scriptSrc: [`'self'`, `https: 'unsafe-inline'`],
>       manifestSrc: [`'self'`, 'apollo-server-landing-page.cdn.apollographql.com'],
>       frameSrc: [`'self'`, 'sandbox.embed.apollographql.com'],
>     },
>   },
> }));
>
> ```

#### Use with Fastify [\#](https://docs.nestjs.com/security/helmet\#use-with-fastify)

If you are using the `FastifyAdapter`, install the [@fastify/helmet](https://github.com/fastify/fastify-helmet) package:

```bash

$ npm i --save @fastify/helmet

```

[fastify-helmet](https://github.com/fastify/fastify-helmet) should not be used as a middleware, but as a [Fastify plugin](https://www.fastify.io/docs/latest/Reference/Plugins/), i.e., by using `app.register()`:

content\_copy

```typescript

import helmet from '@fastify/helmet'
// somewhere in your initialization file
await app.register(helmet)

```

> **Warning** When using `apollo-server-fastify` and `@fastify/helmet`, there may be a problem with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) on the GraphQL playground, to solve this collision, configure the CSP as shown below:
> content\_copy
>
> ```typescript
>
> await app.register(fastifyHelmet, {
>    contentSecurityPolicy: {
>      directives: {
>        defaultSrc: [`'self'`, 'unpkg.com'],
>        styleSrc: [\
>          `'self'`,\
>          `'unsafe-inline'`,\
>          'cdn.jsdelivr.net',\
>          'fonts.googleapis.com',\
>          'unpkg.com',\
>        ],
>        fontSrc: [`'self'`, 'fonts.gstatic.com', 'data:'],
>        imgSrc: [`'self'`, 'data:', 'cdn.jsdelivr.net'],
>        scriptSrc: [\
>          `'self'`,\
>          `https: 'unsafe-inline'`,\
>          `cdn.jsdelivr.net`,\
>          `'unsafe-eval'`,\
>        ],
>      },
>    },
>  });
>
> // If you are not going to use CSP at all, you can use this:
> await app.register(fastifyHelmet, {
>   contentSecurityPolicy: false,
> });
>
> ```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS REPL Guide
- [Read-Eval-Print-Loop (REPL)](https://docs.nestjs.com/recipes/repl#read-eval-print-loop-repl)
- [Usage](https://docs.nestjs.com/recipes/repl#usage)
- [Native functions](https://docs.nestjs.com/recipes/repl#native-functions)
- [Watch mode](https://docs.nestjs.com/recipes/repl#watch-mode)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/repl.md "Suggest Edits")

### Read-Eval-Print-Loop (REPL)

REPL is a simple interactive environment that takes single user inputs, executes them, and returns the result to the user.
The REPL feature lets you inspect your dependency graph and call methods on your providers (and controllers) directly from your terminal.

#### Usage [\#](https://docs.nestjs.com/recipes/repl\#usage)

To run your NestJS application in REPL mode, create a new `repl.ts` file (alongside the existing `main.ts` file) and add the following code inside:

content\_copy repl.ts

JS  TS

```typescript

import { repl } from '@nestjs/core';
import { AppModule } from './src/app.module';

async function bootstrap() {
  await repl(AppModule);
}
bootstrap();

```

```typescript

import { repl } from '@nestjs/core';
import { AppModule } from './src/app.module';

async function bootstrap() {
  await repl(AppModule);
}
bootstrap();

```

Now in your terminal, start the REPL with the following command:

```bash

$ npm run start -- --entryFile repl

```

> **Hint** `repl` returns a [Node.js REPL server](https://nodejs.org/api/repl.html) object.

Once it's up and running, you should see the following message in your console:

```bash

LOG [NestFactory] Starting Nest application...
LOG [InstanceLoader] AppModule dependencies initialized
LOG REPL initialized

```

And now you can start interacting with your dependencies graph. For instance, you can retrieve an `AppService` (we are using the starter project as an example here) and call the `getHello()` method:

content\_copy

```typescript

> get(AppService).getHello()
'Hello World!'

```

You can execute any JavaScript code from within your terminal, for example, assign an instance of the `AppController` to a local variable, and use `await` to call an asynchronous method:

content\_copy

```typescript

> appController = get(AppController)
AppController { appService: AppService {} }
> await appController.getHello()
'Hello World!'

```

To display all public methods available on a given provider or controller, use the `methods()` function, as follows:

content\_copy

```typescript

> methods(AppController)

Methods:
 ◻ getHello

```

To print all registered modules as a list together with their controllers and providers, use `debug()`.

content\_copy

```typescript

> debug()

AppModule:
 - controllers:
  ◻ AppController
 - providers:
  ◻ AppService

```

Quick demo:

![REPL example](https://docs.nestjs.com/assets/repl.gif)

You can find more information about the existing, predefined native methods in the section below.

#### Native functions [\#](https://docs.nestjs.com/recipes/repl\#native-functions)

The built-in NestJS REPL comes with a few native functions that are globally available when you start REPL. You can call `help()` to list them out.

If you don't recall what's the signature (ie: expected parameters and a return type) of a function, you can call `<function_name>.help`.
For instance:

```text

> $.help
Retrieves an instance of either injectable or controller, otherwise, throws exception.
Interface: $(token: InjectionToken) => any

```

> **Hint** Those function interfaces are written in [TypeScript function type expression syntax](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-type-expressions).

| Function | Description | Signature |
| --- | --- | --- |
| `debug` | Print all registered modules as a list together with their controllers and providers. | `debug(moduleCls?: ClassRef | string) => void` |
| `get` or `$` | Retrieves an instance of either injectable or controller, otherwise, throws exception. | `get(token: InjectionToken) => any` |
| `methods` | Display all public methods available on a given provider or controller. | `methods(token: ClassRef | string) => void` |
| `resolve` | Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception. | `resolve(token: InjectionToken, contextId: any) => Promise<any>` |
| `select` | Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module. | `select(token: DynamicModule | ClassRef) => INestApplicationContext` |

#### Watch mode [\#](https://docs.nestjs.com/recipes/repl\#watch-mode)

During development it is useful to run REPL in a watch mode to reflect all the code changes automatically:

```bash

$ npm run start -- --watch --entryFile repl

```

This has one flaw, the REPL's command history is discarded after each reload which might be cumbersome.
Fortunately, there is a very simple solution. Modify your `bootstrap` function like this:

content\_copy

```typescript

async function bootstrap() {
  const replServer = await repl(AppModule);
  replServer.setupHistory(".nestjs_repl_history", (err) => {
    if (err) {
      console.error(err);
    }
  });
}

```

Now the history is preserved between the runs/reloads.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Nest CLI Overview
- [Nest CLI and scripts](https://docs.nestjs.com/cli/scripts#nest-cli-and-scripts)
- [The nest binary](https://docs.nestjs.com/cli/scripts#the-nest-binary)
- [Build](https://docs.nestjs.com/cli/scripts#build)
- [Execution](https://docs.nestjs.com/cli/scripts#execution)
- [Generation](https://docs.nestjs.com/cli/scripts#generation)
- [Package scripts](https://docs.nestjs.com/cli/scripts#package-scripts)
- [Backward compatibility](https://docs.nestjs.com/cli/scripts#backward-compatibility)
- [Migration](https://docs.nestjs.com/cli/scripts#migration)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/cli/scripts.md "Suggest Edits")

### Nest CLI and scripts

This section provides additional background on how the `nest` command interacts with compilers and scripts to help DevOps personnel manage the development environment.

A Nest application is a **standard** TypeScript application that needs to be compiled to JavaScript before it can be executed. There are various ways to accomplish the compilation step, and developers/teams are free to choose a way that works best for them. With that in mind, Nest provides a set of tools out-of-the-box that seek to do the following:

- Provide a standard build/execute process, available at the command line, that "just works" with reasonable defaults.
- Ensure that the build/execute process is **open**, so developers can directly access the underlying tools to customize them using native features and options.
- Remain a completely standard TypeScript/Node.js framework, so that the entire compile/deploy/execute pipeline can be managed by any external tools that the development team chooses to use.

This goal is accomplished through a combination of the `nest` command, a locally installed TypeScript compiler, and `package.json` scripts. We describe how these technologies work together below. This should help you understand what's happening at each step of the build/execute process, and how to customize that behavior if necessary.

#### The nest binary [\#](https://docs.nestjs.com/cli/scripts\#the-nest-binary)

The `nest` command is an OS level binary (i.e., runs from the OS command line). This command actually encompasses 3 distinct areas, described below. We recommend that you run the build ( `nest build`) and execution ( `nest start`) sub-commands via the `package.json` scripts provided automatically when a project is scaffolded (see [typescript starter](https://github.com/nestjs/typescript-starter) if you wish to start by cloning a repo, instead of running `nest new`).

#### Build [\#](https://docs.nestjs.com/cli/scripts\#build)

`nest build` is a wrapper on top of the standard `tsc` compiler or `swc` compiler (for [standard projects](https://docs.nestjs.com/cli/overview#project-structure)) or the webpack bundler using the `ts-loader` (for [monorepos](https://docs.nestjs.com/cli/overview#project-structure)). It does not add any other compilation features or steps except for handling `tsconfig-paths` out of the box. The reason it exists is that most developers, especially when starting out with Nest, do not need to adjust compiler options (e.g., `tsconfig.json` file) which can sometimes be tricky.

See the [nest build](https://docs.nestjs.com/cli/usages#nest-build) documentation for more details.

#### Execution [\#](https://docs.nestjs.com/cli/scripts\#execution)

`nest start` simply ensures the project has been built (same as `nest build`), then invokes the `node` command in a portable, easy way to execute the compiled application. As with builds, you are free to customize this process as needed, either using the `nest start` command and its options, or completely replacing it. The entire process is a standard TypeScript application build and execute pipeline, and you are free to manage the process as such.

See the [nest start](https://docs.nestjs.com/cli/usages#nest-start) documentation for more details.

#### Generation [\#](https://docs.nestjs.com/cli/scripts\#generation)

The `nest generate` commands, as the name implies, generate new Nest projects, or components within them.

#### Package scripts [\#](https://docs.nestjs.com/cli/scripts\#package-scripts)

Running the `nest` commands at the OS command level requires that the `nest` binary be installed globally. This is a standard feature of npm, and outside of Nest's direct control. One consequence of this is that the globally installed `nest` binary is **not** managed as a project dependency in `package.json`. For example, two different developers can be running two different versions of the `nest` binary. The standard solution for this is to use package scripts so that you can treat the tools used in the build and execute steps as development dependencies.

When you run `nest new`, or clone the [typescript starter](https://github.com/nestjs/typescript-starter), Nest populates the new project's `package.json` scripts with commands like `build` and `start`. It also installs the underlying compiler tools (such as `typescript`) as **dev dependencies**.

You run the build and execute scripts with commands like:

```bash

$ npm run build

```

and

```bash

$ npm run start

```

These commands use npm's script running capabilities to execute `nest build` or `nest start` using the **locally installed** `nest` binary. By using these built-in package scripts, you have full dependency management over the Nest CLI commands\*. This means that, by following this **recommended** usage, all members of your organization can be assured of running the same version of the commands.

\*This applies to the `build` and `start` commands. The `nest new` and `nest generate` commands aren't part of the build/execute pipeline, so they operate in a different context, and do not come with built-in `package.json` scripts.

For most developers/teams, it is recommended to utilize the package scripts for building and executing their Nest projects. You can fully customize the behavior of these scripts via their options ( `--path`, `--webpack`, `--webpackPath`) and/or customize the `tsc` or webpack compiler options files (e.g., `tsconfig.json`) as needed. You are also free to run a completely custom build process to compile the TypeScript (or even to execute TypeScript directly with `ts-node`).

#### Backward compatibility [\#](https://docs.nestjs.com/cli/scripts\#backward-compatibility)

Because Nest applications are pure TypeScript applications, previous versions of the Nest build/execute scripts will continue to operate. You are not required to upgrade them. You can choose to take advantage of the new `nest build` and `nest start` commands when you are ready, or continue running previous or customized scripts.

#### Migration [\#](https://docs.nestjs.com/cli/scripts\#migration)

While you are not required to make any changes, you may want to migrate to using the new CLI commands instead of using tools such as `tsc-watch` or `ts-node`. In this case, simply install the latest version of the `@nestjs/cli`, both globally and locally:

```bash

$ npm install -g @nestjs/cli
$ cd  /some/project/root/folder
$ npm install -D @nestjs/cli

```

You can then replace the `scripts` defined in `package.json` with the following ones:

content\_copy

```typescript

"build": "nest build",
"start": "nest start",
"start:dev": "nest start --watch",
"start:debug": "nest start --debug --watch",

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Validation Techniques
- [Validation](https://docs.nestjs.com/techniques/validation#validation)
- [Overview](https://docs.nestjs.com/techniques/validation#overview)
- [Using the built-in ValidationPipe](https://docs.nestjs.com/techniques/validation#using-the-built-in-validationpipe)
- [Auto-validation](https://docs.nestjs.com/techniques/validation#auto-validation)
- [Disable detailed errors](https://docs.nestjs.com/techniques/validation#disable-detailed-errors)
- [Stripping properties](https://docs.nestjs.com/techniques/validation#stripping-properties)
- [Transform payload objects](https://docs.nestjs.com/techniques/validation#transform-payload-objects)
- [Explicit conversion](https://docs.nestjs.com/techniques/validation#explicit-conversion)
- [Mapped types](https://docs.nestjs.com/techniques/validation#mapped-types)
- [Parsing and validating arrays](https://docs.nestjs.com/techniques/validation#parsing-and-validating-arrays)
- [WebSockets and Microservices](https://docs.nestjs.com/techniques/validation#websockets-and-microservices)
- [Learn more](https://docs.nestjs.com/techniques/validation#learn-more)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/validation.md "Suggest Edits")

### Validation

It is best practice to validate the correctness of any data sent into a web application. To automatically validate incoming requests, Nest provides several pipes available right out-of-the-box:

- `ValidationPipe`
- `ParseIntPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`

The `ValidationPipe` makes use of the powerful [class-validator](https://github.com/typestack/class-validator) package and its declarative validation decorators. The `ValidationPipe` provides a convenient approach to enforce validation rules for all incoming client payloads, where the specific rules are declared with simple annotations in local class/DTO declarations in each module.

#### Overview [\#](https://docs.nestjs.com/techniques/validation\#overview)

In the [Pipes](https://docs.nestjs.com/pipes) chapter, we went through the process of building simple pipes and binding them to controllers, methods or to the global app to demonstrate how the process works. Be sure to review that chapter to best understand the topics of this chapter. Here, we'll focus on various **real world** use cases of the `ValidationPipe`, and show how to use some of its advanced customization features.

#### Using the built-in ValidationPipe [\#](https://docs.nestjs.com/techniques/validation\#using-the-built-in-validationpipe)

To begin using it, we first install the required dependency.

```bash

$ npm i --save class-validator class-transformer

```

> **Hint** The `ValidationPipe` is exported from the `@nestjs/common` package.

Because this pipe uses the [`class-validator`](https://github.com/typestack/class-validator) and [`class-transformer`](https://github.com/typestack/class-transformer) libraries, there are many options available. You configure these settings via a configuration object passed to the pipe. Following are the built-in options:

content\_copy

```typescript

export interface ValidationPipeOptions extends ValidatorOptions {
  transform?: boolean;
  disableErrorMessages?: boolean;
  exceptionFactory?: (errors: ValidationError[]) => any;
}

```

In addition to these, all `class-validator` options (inherited from the `ValidatorOptions` interface) are available:

| Option | Type | Description |
| --- | --- | --- |
| `enableDebugMessages` | `boolean` | If set to true, validator will print extra warning messages to the console when something is not right. |
| `skipUndefinedProperties` | `boolean` | If set to true then validator will skip validation of all properties that are undefined in the validating object. |
| `skipNullProperties` | `boolean` | If set to true then validator will skip validation of all properties that are null in the validating object. |
| `skipMissingProperties` | `boolean` | If set to true then validator will skip validation of all properties that are null or undefined in the validating object. |
| `whitelist` | `boolean` | If set to true, validator will strip validated (returned) object of any properties that do not use any validation decorators. |
| `forbidNonWhitelisted` | `boolean` | If set to true, instead of stripping non-whitelisted properties validator will throw an exception. |
| `forbidUnknownValues` | `boolean` | If set to true, attempts to validate unknown objects fail immediately. |
| `disableErrorMessages` | `boolean` | If set to true, validation errors will not be returned to the client. |
| `errorHttpStatusCode` | `number` | This setting allows you to specify which exception type will be used in case of an error. By default it throws `BadRequestException`. |
| `exceptionFactory` | `Function` | Takes an array of the validation errors and returns an exception object to be thrown. |
| `groups` | `string[]` | Groups to be used during validation of the object. |
| `always` | `boolean` | Set default for `always` option of decorators. Default can be overridden in decorator options. |
| `strictGroups` | `boolean` | If `groups` is not given or is empty, ignore decorators with at least one group. |
| `dismissDefaultMessages` | `boolean` | If set to true, the validation will not use default messages. Error message always will be `undefined` if its not explicitly set. |
| `validationError.target` | `boolean` | Indicates if target should be exposed in `ValidationError`. |
| `validationError.value` | `boolean` | Indicates if validated value should be exposed in `ValidationError`. |
| `stopAtFirstError` | `boolean` | When set to true, validation of the given property will stop after encountering the first error. Defaults to false. |

> **Notice** Find more information about the `class-validator` package in its [repository](https://github.com/typestack/class-validator).

#### Auto-validation [\#](https://docs.nestjs.com/techniques/validation\#auto-validation)

We'll start by binding `ValidationPipe` at the application level, thus ensuring all endpoints are protected from receiving incorrect data.

content\_copy

```typescript

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

To test our pipe, let's create a basic endpoint.

content\_copy

```typescript

@Post()
create(@Body() createUserDto: CreateUserDto) {
  return 'This action adds a new user';
}

```

> **Hint** Since TypeScript does not store metadata about **generics or interfaces**, when you use them in your DTOs, `ValidationPipe` may not be able to properly validate incoming data. For this reason, consider using concrete classes in your DTOs.

> **Hint** When importing your DTOs, you can't use a type-only import as that would be erased at runtime, i.e. remember to `import { CreateUserDto }` instead of `import type { CreateUserDto }`.

Now we can add a few validation rules in our `CreateUserDto`. We do this using decorators provided by the `class-validator` package, described in detail [here](https://github.com/typestack/class-validator#validation-decorators). In this fashion, any route that uses the `CreateUserDto` will automatically enforce these validation rules.

content\_copy

```typescript

import { IsEmail, IsNotEmpty } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;
}

```

With these rules in place, if a request hits our endpoint with an invalid `email` property in the request body, the application will automatically respond with a `400 Bad Request` code, along with the following response body:

```json

{
  "statusCode": 400,
  "error": "Bad Request",
  "message": ["email must be an email"]
}

```

In addition to validating request bodies, the `ValidationPipe` can be used with other request object properties as well. Imagine that we would like to accept `:id` in the endpoint path. To ensure that only numbers are accepted for this request parameter, we can use the following construct:

content\_copy

```typescript

@Get(':id')
findOne(@Param() params: FindOneParams) {
  return 'This action returns a user';
}

```

`FindOneParams`, like a DTO, is simply a class that defines validation rules using `class-validator`. It would look like this:

content\_copy

```typescript

import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: string;
}

```

#### Disable detailed errors [\#](https://docs.nestjs.com/techniques/validation\#disable-detailed-errors)

Error messages can be helpful to explain what was incorrect in a request. However, some production environments prefer to disable detailed errors. Do this by passing an options object to the `ValidationPipe`:

content\_copy

```typescript

app.useGlobalPipes(
  new ValidationPipe({
    disableErrorMessages: true,
  }),
);

```

As a result, detailed error messages won't be displayed in the response body.

#### Stripping properties [\#](https://docs.nestjs.com/techniques/validation\#stripping-properties)

Our `ValidationPipe` can also filter out properties that should not be received by the method handler. In this case, we can **whitelist** the acceptable properties, and any property not included in the whitelist is automatically stripped from the resulting object. For example, if our handler expects `email` and `password` properties, but a request also includes an `age` property, this property can be automatically removed from the resulting DTO. To enable such behavior, set `whitelist` to `true`.

content\_copy

```typescript

app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
  }),
);

```

When set to true, this will automatically remove non-whitelisted properties (those without any decorator in the validation class).

Alternatively, you can stop the request from processing when non-whitelisted properties are present, and return an error response to the user. To enable this, set the `forbidNonWhitelisted` option property to `true`, in combination with setting `whitelist` to `true`.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Transform payload objects [\#](https://docs.nestjs.com/techniques/validation\#transform-payload-objects)

Payloads coming in over the network are plain JavaScript objects. The `ValidationPipe` can automatically transform payloads to be objects typed according to their DTO classes. To enable auto-transformation, set `transform` to `true`. This can be done at a method level:

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@UsePipes(new ValidationPipe({ transform: true }))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

To enable this behavior globally, set the option on a global pipe:

content\_copy

```typescript

app.useGlobalPipes(
  new ValidationPipe({
    transform: true,
  }),
);

```

With the auto-transformation option enabled, the `ValidationPipe` will also perform conversion of primitive types. In the following example, the `findOne()` method takes one argument which represents an extracted `id` path parameter:

content\_copy

```typescript

@Get(':id')
findOne(@Param('id') id: number) {
  console.log(typeof id === 'number'); // true
  return 'This action returns a user';
}

```

By default, every path parameter and query parameter comes over the network as a `string`. In the above example, we specified the `id` type as a `number` (in the method signature). Therefore, the `ValidationPipe` will try to automatically convert a string identifier to a number.

#### Explicit conversion [\#](https://docs.nestjs.com/techniques/validation\#explicit-conversion)

In the above section, we showed how the `ValidationPipe` can implicitly transform query and path parameters based on the expected type. However, this feature requires having auto-transformation enabled.

Alternatively (with auto-transformation disabled), you can explicitly cast values using the `ParseIntPipe` or `ParseBoolPipe` (note that `ParseStringPipe` is not needed because, as mentioned earlier, every path parameter and query parameter comes over the network as a `string` by default).

content\_copy

```typescript

@Get(':id')
findOne(
  @Param('id', ParseIntPipe) id: number,
  @Query('sort', ParseBoolPipe) sort: boolean,
) {
  console.log(typeof id === 'number'); // true
  console.log(typeof sort === 'boolean'); // true
  return 'This action returns a user';
}

```

> **Hint** The `ParseIntPipe` and `ParseBoolPipe` are exported from the `@nestjs/common` package.

#### Mapped types [\#](https://docs.nestjs.com/techniques/validation\#mapped-types)

As you build out features like **CRUD** (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.

> **Warning** If your application uses the `@nestjs/swagger` package, see [this chapter](https://docs.nestjs.com/openapi/mapped-types) for more information about Mapped Types. Likewise, if you use the `@nestjs/graphql` package see [this chapter](https://docs.nestjs.com/graphql/mapped-types). Both packages heavily rely on types and so they require a different import to be used. Therefore, if you used `@nestjs/mapped-types` (instead of an appropriate one, either `@nestjs/swagger` or `@nestjs/graphql` depending on the type of your app), you may face various, undocumented side-effects.

When building input validation types (also called DTOs), it's often useful to build **create** and **update** variations on the same type. For example, the **create** variant may require all fields, while the **update** variant may make all fields optional.

Nest provides the `PartialType()` utility function to make this task easier and minimize boilerplate.

The `PartialType()` function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a **create** type as follows:

content\_copy

```typescript

export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

```

By default, all of these fields are required. To create a type with the same fields, but with each one optional, use `PartialType()` passing the class reference ( `CreateCatDto`) as an argument:

content\_copy

```typescript

export class UpdateCatDto extends PartialType(CreateCatDto) {}

```

> **Hint** The `PartialType()` function is imported from the `@nestjs/mapped-types` package.

The `PickType()` function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:

content\_copy

```typescript

export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

```

We can pick a set of properties from this class using the `PickType()` utility function:

content\_copy

```typescript

export class UpdateCatAgeDto extends PickType(CreateCatDto, ['age'] as const) {}

```

> **Hint** The `PickType()` function is imported from the `@nestjs/mapped-types` package.

The `OmitType()` function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:

content\_copy

```typescript

export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

```

We can generate a derived type that has every property **except** `name` as shown below. In this construct, the second argument to `OmitType` is an array of property names.

content\_copy

```typescript

export class UpdateCatDto extends OmitType(CreateCatDto, ['name'] as const) {}

```

> **Hint** The `OmitType()` function is imported from the `@nestjs/mapped-types` package.

The `IntersectionType()` function combines two types into one new type (class). For example, suppose we start with two types like:

content\_copy

```typescript

export class CreateCatDto {
  name: string;
  breed: string;
}

export class AdditionalCatInfo {
  color: string;
}

```

We can generate a new type that combines all properties in both types.

content\_copy

```typescript

export class UpdateCatDto extends IntersectionType(
  CreateCatDto,
  AdditionalCatInfo,
) {}

```

> **Hint** The `IntersectionType()` function is imported from the `@nestjs/mapped-types` package.

The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the `CreateCatDto` type except for `name`, and those properties will be set to optional:

content\_copy

```typescript

export class UpdateCatDto extends PartialType(
  OmitType(CreateCatDto, ['name'] as const),
) {}

```

#### Parsing and validating arrays [\#](https://docs.nestjs.com/techniques/validation\#parsing-and-validating-arrays)

TypeScript does not store metadata about generics or interfaces, so when you use them in your DTOs, `ValidationPipe` may not be able to properly validate incoming data. For instance, in the following code, `createUserDtos` won't be correctly validated:

content\_copy

```typescript

@Post()
createBulk(@Body() createUserDtos: CreateUserDto[]) {
  return 'This action adds new users';
}

```

To validate the array, create a dedicated class which contains a property that wraps the array, or use the `ParseArrayPipe`.

content\_copy

```typescript

@Post()
createBulk(
  @Body(new ParseArrayPipe({ items: CreateUserDto }))
  createUserDtos: CreateUserDto[],
) {
  return 'This action adds new users';
}

```

In addition, the `ParseArrayPipe` may come in handy when parsing query parameters. Let's consider a `findByIds()` method that returns users based on identifiers passed as query parameters.

content\_copy

```typescript

@Get()
findByIds(
  @Query('ids', new ParseArrayPipe({ items: Number, separator: ',' }))
  ids: number[],
) {
  return 'This action returns users by ids';
}

```

This construction validates the incoming query parameters from an HTTP `GET` request like the following:

```bash

GET /?ids=1,2,3

```

#### WebSockets and Microservices [\#](https://docs.nestjs.com/techniques/validation\#websockets-and-microservices)

While this chapter shows examples using HTTP style applications (e.g., Express or Fastify), the `ValidationPipe` works the same for WebSockets and microservices, regardless of the transport method that is used.

#### Learn more [\#](https://docs.nestjs.com/techniques/validation\#learn-more)

Read more about custom validators, error messages, and available decorators as provided by the `class-validator` package [here](https://github.com/typestack/class-validator).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Microservices Guards Overview
- [Guards](https://docs.nestjs.com/microservices/guards#guards)
- [Binding guards](https://docs.nestjs.com/microservices/guards#binding-guards)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/guards.md "Suggest Edits")

### Guards

There is no fundamental difference between microservices guards and [regular HTTP application guards](https://docs.nestjs.com/guards).
The only difference is that instead of throwing `HttpException`, you should use `RpcException`.

> **Hint** The `RpcException` class is exposed from `@nestjs/microservices` package.

#### Binding guards [\#](https://docs.nestjs.com/microservices/guards\#binding-guards)

The following example uses a method-scoped guard. Just as with HTTP based applications, you can also use controller-scoped guards (i.e., prefix the controller class with a `@UseGuards()` decorator).

content\_copy

JS  TS

```typescript

@UseGuards(AuthGuard)
@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): number {
  return (data || []).reduce((a, b) => a + b);
}

```

```typescript

@UseGuards(AuthGuard)
@MessagePattern({ cmd: 'sum' })
accumulate(data) {
  return (data || []).reduce((a, b) => a + b);
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Directives Overview
- [Directives](https://docs.nestjs.com/graphql/directives#directives)
- [Custom directives](https://docs.nestjs.com/graphql/directives#custom-directives)
- [Code first](https://docs.nestjs.com/graphql/directives#code-first)
- [Schema first](https://docs.nestjs.com/graphql/directives#schema-first)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/directives.md "Suggest Edits")

### Directives

A directive can be attached to a field or fragment inclusion, and can affect execution of the query in any way the server desires (read more [here](https://graphql.org/learn/queries/#directives)). The GraphQL specification provides several default directives:

- `@include(if: Boolean)` \- only include this field in the result if the argument is true
- `@skip(if: Boolean)` \- skip this field if the argument is true
- `@deprecated(reason: String)` \- marks field as deprecated with message

A directive is an identifier preceded by a `@` character, optionally followed by a list of named arguments, which can appear after almost any element in the GraphQL query and schema languages.

#### Custom directives [\#](https://docs.nestjs.com/graphql/directives\#custom-directives)

To instruct what should happen when Apollo/Mercurius encounters your directive, you can create a transformer function. This function uses the `mapSchema` function to iterate through locations in your schema (field definitions, type definitions, etc.) and perform corresponding transformations.

content\_copy

```typescript

import { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';
import { defaultFieldResolver, GraphQLSchema } from 'graphql';

export function upperDirectiveTransformer(
  schema: GraphQLSchema,
  directiveName: string,
) {
  return mapSchema(schema, {
    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {
      const upperDirective = getDirective(
        schema,
        fieldConfig,
        directiveName,
      )?.[0];

      if (upperDirective) {
        const { resolve = defaultFieldResolver } = fieldConfig;

        // Replace the original resolver with a function that *first* calls
        // the original resolver, then converts its result to upper case
        fieldConfig.resolve = async function (source, args, context, info) {
          const result = await resolve(source, args, context, info);
          if (typeof result === 'string') {
            return result.toUpperCase();
          }
          return result;
        };
        return fieldConfig;
      }
    },
  });
}

```

Now, apply the `upperDirectiveTransformer` transformation function in the `GraphQLModule#forRoot` method using the `transformSchema` function:

content\_copy

```typescript

GraphQLModule.forRoot({
  // ...
  transformSchema: (schema) => upperDirectiveTransformer(schema, 'upper'),
});

```

Once registered, the `@upper` directive can be used in our schema. However, the way you apply the directive will vary depending on the approach you use (code first or schema first).

#### Code first [\#](https://docs.nestjs.com/graphql/directives\#code-first)

In the code first approach, use the `@Directive()` decorator to apply the directive.

content\_copy

```typescript

@Directive('@upper')
@Field()
title: string;

```

> **Hint** The `@Directive()` decorator is exported from the `@nestjs/graphql` package.

Directives can be applied on fields, field resolvers, input and object types, as well as queries, mutations, and subscriptions. Here's an example of the directive applied on the query handler level:

content\_copy

```typescript

@Directive('@deprecated(reason: "This query will be removed in the next version")')
@Query(() => Author, { name: 'author' })
async getAuthor(@Args({ name: 'id', type: () => Int }) id: number) {
  return this.authorsService.findOneById(id);
}

```

> **Warning** Directives applied through the `@Directive()` decorator will not be reflected in the generated schema definition file.

Lastly, make sure to declare directives in the `GraphQLModule`, as follows:

content\_copy

```typescript

GraphQLModule.forRoot({
  // ...,
  transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),
  buildSchemaOptions: {
    directives: [\
      new GraphQLDirective({\
        name: 'upper',\
        locations: [DirectiveLocation.FIELD_DEFINITION],\
      }),\
    ],
  },
}),

```

> **Hint** Both `GraphQLDirective` and `DirectiveLocation` are exported from the `graphql` package.

#### Schema first [\#](https://docs.nestjs.com/graphql/directives\#schema-first)

In the schema first approach, apply directives directly in SDL.

```graphql

directive @upper on FIELD_DEFINITION

type Post {
  id: Int!
  title: String! @upper
  votes: Int
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Microservices Guide
- [Overview](https://docs.nestjs.com/microservices/basics#overview)
- [Installation](https://docs.nestjs.com/microservices/basics#installation)
- [Getting started](https://docs.nestjs.com/microservices/basics#getting-started)
- [Message and Event Patterns](https://docs.nestjs.com/microservices/basics#message-and-event-patterns)
- [Request-response](https://docs.nestjs.com/microservices/basics#request-response)
- [Asynchronous responses](https://docs.nestjs.com/microservices/basics#asynchronous-responses)
- [Event-based](https://docs.nestjs.com/microservices/basics#event-based)
- [Additional request details](https://docs.nestjs.com/microservices/basics#additional-request-details)
- [Client (producer class)](https://docs.nestjs.com/microservices/basics#client-producer-class)
- [Sending messages](https://docs.nestjs.com/microservices/basics#sending-messages)
- [Publishing events](https://docs.nestjs.com/microservices/basics#publishing-events)
- [Request-scoping](https://docs.nestjs.com/microservices/basics#request-scoping)
- [Instance status updates](https://docs.nestjs.com/microservices/basics#instance-status-updates)
- [Listening to internal events](https://docs.nestjs.com/microservices/basics#listening-to-internal-events)
- [Underlying driver access](https://docs.nestjs.com/microservices/basics#underlying-driver-access)
- [Handling timeouts](https://docs.nestjs.com/microservices/basics#handling-timeouts)
- [TLS support](https://docs.nestjs.com/microservices/basics#tls-support)
- [Dynamic configuration](https://docs.nestjs.com/microservices/basics#dynamic-configuration)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/basics.md "Suggest Edits")

### Overview

In addition to traditional (sometimes called monolithic) application architectures, Nest natively supports the microservice architectural style of development. Most of the concepts discussed elsewhere in this documentation, such as dependency injection, decorators, exception filters, pipes, guards and interceptors, apply equally to microservices. Wherever possible, Nest abstracts implementation details so that the same components can run across HTTP-based platforms, WebSockets, and Microservices. This section covers the aspects of Nest that are specific to microservices.

In Nest, a microservice is fundamentally an application that uses a different **transport** layer than HTTP.

![](https://docs.nestjs.com/assets/Microservices_1.png)

Nest supports several built-in transport layer implementations, called **transporters**, which are responsible for transmitting messages between different microservice instances. Most transporters natively support both **request-response** and **event-based** message styles. Nest abstracts the implementation details of each transporter behind a canonical interface for both request-response and event-based messaging. This makes it easy to switch from one transport layer to another -- for example to leverage the specific reliability or performance features of a particular transport layer -- without impacting your application code.

#### Installation [\#](https://docs.nestjs.com/microservices/basics\#installation)

To start building microservices, first install the required package:

```bash

$ npm i --save @nestjs/microservices

```

#### Getting started [\#](https://docs.nestjs.com/microservices/basics\#getting-started)

To instantiate a microservice, use the `createMicroservice()` method of the `NestFactory` class:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { Transport, MicroserviceOptions } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
    },
  );
  await app.listen();
}
bootstrap();

```

```typescript

import { NestFactory } from '@nestjs/core';
import { Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice(AppModule, {
    transport: Transport.TCP,
  });
  await app.listen();
}
bootstrap();

```

> **Hint** Microservices use the **TCP** transport layer by default.

The second argument of the `createMicroservice()` method is an `options` object. This object may consist of two members:

|     |     |
| --- | --- |
| `transport` | Specifies the transporter (for example, `Transport.NATS`) |
| `options` | A transporter-specific options object that determines transporter behavior |

The `options` object is specific to the chosen transporter. The **TCP** transporter exposes the properties described below. For other transporters (e.g, Redis, MQTT, etc.), see the relevant chapter for a description of the available options.

|     |     |
| --- | --- |
| `host` | Connection hostname |
| `port` | Connection port |
| `retryAttempts` | Number of times to retry message (default: `0`) |
| `retryDelay` | Delay between message retry attempts (ms) (default: `0`) |
| `serializer` | Custom [serializer](https://github.com/nestjs/nest/blob/master/packages/microservices/interfaces/serializer.interface.ts) for outgoing messages |
| `deserializer` | Custom [deserializer](https://github.com/nestjs/nest/blob/master/packages/microservices/interfaces/deserializer.interface.ts) for incoming messages |
| `socketClass` | A custom Socket that extends `TcpSocket` (default: `JsonSocket`) |
| `tlsOptions` | Options to configure the tls protocol |

> **Hint** The above properties are specific to the TCP transporter. For information on available options for other transporters, refer to the relevant chapter.

#### Message and Event Patterns [\#](https://docs.nestjs.com/microservices/basics\#message-and-event-patterns)

Microservices recognize both messages and events by **patterns**. A pattern is a plain value, for example, a literal object or a string. Patterns are automatically serialized and sent over the network along with the data portion of a message. In this way, message senders and consumers can coordinate which requests are consumed by which handlers.

#### Request-response [\#](https://docs.nestjs.com/microservices/basics\#request-response)

The request-response message style is useful when you need to **exchange** messages between various external services. This paradigm ensures that the service has actually received the message (without requiring you to manually implement an acknowledgment protocol). However, the request-response approach may not always be the best fit. For example, streaming transporters, such as [Kafka](https://docs.confluent.io/3.0.0/streams/) or [NATS streaming](https://github.com/nats-io/node-nats-streaming), which use log-based persistence, are optimized for addressing a different set of challenges, more aligned with the event messaging paradigm (see [event-based messaging](https://docs.nestjs.com/microservices/basics#event-based) for more details).

To enable the request-response message type, Nest creates two logical channels: one for transferring data and another for waiting for incoming responses. For some underlying transports, like [NATS](https://nats.io/), this dual-channel support is provided out-of-the-box. For others, Nest compensates by manually creating separate channels. While this is effective, it can introduce some overhead. Therefore, if you don’t require a request-response message style, you may want to consider using the event-based method.

To create a message handler based on the request-response paradigm, use the `@MessagePattern()` decorator, which is imported from the `@nestjs/microservices` package. This decorator should only be used within [controller](https://docs.nestjs.com/controllers) classes, as they serve as the entry points for your application. Using it in providers will have no effect, as they will be ignored by the Nest runtime.

content\_copy math.controller.ts

JS  TS

```typescript

import { Controller } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';

@Controller()
export class MathController {
  @MessagePattern({ cmd: 'sum' })
  accumulate(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }
}

```

```typescript

import { Controller } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';

@Controller()
export class MathController {
  @MessagePattern({ cmd: 'sum' })
  accumulate(data) {
    return (data || []).reduce((a, b) => a + b);
  }
}

```

In the above code, the `accumulate()` **message handler** listens for messages that match the `{ cmd: 'sum' }` message pattern. The message handler takes a single argument, the `data` passed from the client. In this case, the data is an array of numbers that need to be accumulated.

#### Asynchronous responses [\#](https://docs.nestjs.com/microservices/basics\#asynchronous-responses)

Message handlers can respond either synchronously or **asynchronously**, meaning that `async` methods are supported.

content\_copy

JS  TS

```typescript

@MessagePattern({ cmd: 'sum' })
async accumulate(data: number[]): Promise<number> {
  return (data || []).reduce((a, b) => a + b);
}

```

```typescript

@MessagePattern({ cmd: 'sum' })
async accumulate(data) {
  return (data || []).reduce((a, b) => a + b);
}

```

A message handler can also return an `Observable`, in which case the result values will be emitted until the stream completes.

content\_copy

JS  TS

```typescript

@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): Observable<number> {
  return from([1, 2, 3]);
}

```

```typescript

@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): Observable<number> {
  return from([1, 2, 3]);
}

```

In the example above, the message handler will respond **three times**, once for each item in the array.

#### Event-based [\#](https://docs.nestjs.com/microservices/basics\#event-based)

While the request-response method is perfect for exchanging messages between services, it is less suited for event-based messaging—when you simply want to publish **events** without waiting for a response. In such cases, the overhead of maintaining two channels for request-response is unnecessary.

For example, if you want to notify another service that a specific condition has occurred in this part of the system, the event-based message style is ideal.

To create an event handler, you can use the `@EventPattern()` decorator, which is imported from the `@nestjs/microservices` package.

content\_copy

JS  TS

```typescript

@EventPattern('user_created')
async handleUserCreated(data: Record<string, unknown>) {
  // business logic
}

```

```typescript

@EventPattern('user_created')
async handleUserCreated(data) {
  // business logic
}

```

> **Hint** You can register multiple event handlers for a **single** event pattern, and all of them will be automatically triggered in parallel.

The `handleUserCreated()` **event handler** listens for the `'user_created'` event. The event handler takes a single argument, the `data` passed from the client (in this case, an event payload which has been sent over the network).

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Additional request details [\#](https://docs.nestjs.com/microservices/basics\#additional-request-details)

In more advanced scenarios, you might need to access additional details about the incoming request. For instance, when using NATS with wildcard subscriptions, you may want to retrieve the original subject that the producer sent the message to. Similarly, with Kafka, you may need to access the message headers. To achieve this, you can leverage built-in decorators as shown below:

content\_copy

JS  TS

```typescript

@MessagePattern('time.us.*')
getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('time.us.*')
getDate(data, context) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `NatsContext` are imported from `@nestjs/microservices`.

> **Hint** You can also pass in a property key to the `@Payload()` decorator to extract a specific property from the incoming payload object, for example, `@Payload('id')`.

#### Client (producer class) [\#](https://docs.nestjs.com/microservices/basics\#client-producer-class)

A client Nest application can exchange messages or publish events to a Nest microservice using the `ClientProxy` class. This class provides several methods, such as `send()` (for request-response messaging) and `emit()` (for event-driven messaging), enabling communication with a remote microservice. You can obtain an instance of this class in the following ways:

One approach is to import the `ClientsModule`, which exposes the static `register()` method. This method takes an array of objects representing microservice transporters. Each object must include a `name` property, and optionally a `transport` property (defaulting to `Transport.TCP`), as well as an optional `options` property.

The `name` property acts as an **injection token**, which you can use to inject an instance of `ClientProxy` wherever needed. The value of this `name` property can be any arbitrary string or JavaScript symbol, as described [here](https://docs.nestjs.com/fundamentals/custom-providers#non-class-based-provider-tokens).

The `options` property is an object that includes the same properties we saw in the `createMicroservice()` method earlier.

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      { name: 'MATH_SERVICE', transport: Transport.TCP },\
    ]),\
  ],
})

```

Alternatively, you can use the `registerAsync()` method if you need to provide configuration or perform any other asynchronous processes during the setup.

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.registerAsync([\
      {\
        imports: [ConfigModule],\
        name: 'MATH_SERVICE',\
        useFactory: async (configService: ConfigService) => ({\
          transport: Transport.TCP,\
          options: {\
            url: configService.get('URL'),\
          },\
        }),\
        inject: [ConfigService],\
      },\
    ]),\
  ],
})

```

Once the module has been imported, you can inject an instance of the `ClientProxy` configured with the specified options for the `'MATH_SERVICE'` transporter using the `@Inject()` decorator.

content\_copy

```typescript

constructor(
  @Inject('MATH_SERVICE') private client: ClientProxy,
) {}

```

> **Hint** The `ClientsModule` and `ClientProxy` classes are imported from the `@nestjs/microservices` package.

At times, you may need to fetch the transporter configuration from another service (such as a `ConfigService`), rather than hard-coding it in your client application. To achieve this, you can register a [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) using the `ClientProxyFactory` class. This class provides a static `create()` method that accepts a transporter options object and returns a customized `ClientProxy` instance.

content\_copy

```typescript

@Module({
  providers: [\
    {\
      provide: 'MATH_SERVICE',\
      useFactory: (configService: ConfigService) => {\
        const mathSvcOptions = configService.getMathSvcOptions();\
        return ClientProxyFactory.create(mathSvcOptions);\
      },\
      inject: [ConfigService],\
    }\
  ]
  ...
})

```

> **Hint** The `ClientProxyFactory` is imported from the `@nestjs/microservices` package.

Another option is to use the `@Client()` property decorator.

content\_copy

```typescript

@Client({ transport: Transport.TCP })
client: ClientProxy;

```

> **Hint** The `@Client()` decorator is imported from the `@nestjs/microservices` package.

Using the `@Client()` decorator is not the preferred technique, as it is harder to test and harder to share a client instance.

The `ClientProxy` is **lazy**. It doesn't initiate a connection immediately. Instead, it will be established before the first microservice call, and then reused across each subsequent call. However, if you want to delay the application bootstrapping process until a connection is established, you can manually initiate a connection using the `ClientProxy` object's `connect()` method inside the `OnApplicationBootstrap` lifecycle hook.

content\_copy

JS  TS

```typescript

async onApplicationBootstrap() {
  await this.client.connect();
}

```

If the connection cannot be created, the `connect()` method will reject with the corresponding error object.

#### Sending messages [\#](https://docs.nestjs.com/microservices/basics\#sending-messages)

The `ClientProxy` exposes a `send()` method. This method is intended to call the microservice and returns an `Observable` with its response. Thus, we can subscribe to the emitted values easily.

content\_copy

JS  TS

```typescript

accumulate(): Observable<number> {
  const pattern = { cmd: 'sum' };
  const payload = [1, 2, 3];
  return this.client.send<number>(pattern, payload);
}

```

```typescript

accumulate() {
  const pattern = { cmd: 'sum' };
  const payload = [1, 2, 3];
  return this.client.send(pattern, payload);
}

```

The `send()` method takes two arguments, `pattern` and `payload`. The `pattern` should match one defined in a `@MessagePattern()` decorator. The `payload` is a message that we want to transmit to the remote microservice. This method returns a **cold `Observable`**, which means that you have to explicitly subscribe to it before the message will be sent.

#### Publishing events [\#](https://docs.nestjs.com/microservices/basics\#publishing-events)

To send an event, use the `ClientProxy` object's `emit()` method. This method publishes an event to the message broker.

content\_copy

JS  TS

```typescript

async publish() {
  this.client.emit<number>('user_created', new UserCreatedEvent());
}

```

```typescript

async publish() {
  this.client.emit('user_created', new UserCreatedEvent());
}

```

The `emit()` method takes two arguments: `pattern` and `payload`. The `pattern` should match one defined in an `@EventPattern()` decorator, while the `payload` represents the event data that you want to transmit to the remote microservice. This method returns a **hot `Observable`** (in contrast to the cold `Observable` returned by `send()`), meaning that regardless of whether you explicitly subscribe to the observable, the proxy will immediately attempt to deliver the event.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Request-scoping [\#](https://docs.nestjs.com/microservices/basics\#request-scoping)

For those coming from different programming language backgrounds, it may be surprising to learn that in Nest, most things are shared across incoming requests. This includes a connection pool to the database, singleton services with global state, and more. Keep in mind that Node.js does not follow the request/response multi-threaded stateless model, where each request is processed by a separate thread. As a result, using singleton instances is **safe** for our applications.

However, there are edge cases where a request-based lifetime for the handler might be desirable. This could include scenarios like per-request caching in GraphQL applications, request tracking, or multi-tenancy. You can learn more about how to control scopes [here](https://docs.nestjs.com/fundamentals/injection-scopes).

Request-scoped handlers and providers can inject `RequestContext` using the `@Inject()` decorator in combination with the `CONTEXT` token:

content\_copy

```typescript

import { Injectable, Scope, Inject } from '@nestjs/common';
import { CONTEXT, RequestContext } from '@nestjs/microservices';

@Injectable({ scope: Scope.REQUEST })
export class CatsService {
  constructor(@Inject(CONTEXT) private ctx: RequestContext) {}
}

```

This provides access to the `RequestContext` object, which has two properties:

content\_copy

```typescript

export interface RequestContext<T = any> {
  pattern: string | Record<string, any>;
  data: T;
}

```

The `data` property is the message payload sent by the message producer. The `pattern` property is the pattern used to identify an appropriate handler to handle the incoming message.

#### Instance status updates [\#](https://docs.nestjs.com/microservices/basics\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For instance, if you’re using the TCP transporter (the default), the `status` stream emits `connected` and `disconnected` events.

content\_copy

```typescript

this.client.status.subscribe((status: TcpStatus) => {
  console.log(status);
});

```

> **Hint** The `TcpStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: TcpStatus) => {
  console.log(status);
});

```

#### Listening to internal events [\#](https://docs.nestjs.com/microservices/basics\#listening-to-internal-events)

In some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the `error` event to trigger additional operations when an error occurs. To do this, use the `on()` method, as shown below:

content\_copy

```typescript

this.client.on('error', (err) => {
  console.error(err);
});

```

Similarly, you can listen to the server's internal events:

content\_copy

```typescript

server.on<TcpEvents>('error', (err) => {
  console.error(err);
});

```

> **Hint** The `TcpEvents` type is imported from the `@nestjs/microservices` package.

#### Underlying driver access [\#](https://docs.nestjs.com/microservices/basics\#underlying-driver-access)

For more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use the `unwrap()` method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.

content\_copy

```typescript

const netServer = this.client.unwrap<Server>();

```

Here, `Server` is a type imported from the `net` module.

Similarly, you can access the server's underlying driver instance:

content\_copy

```typescript

const netServer = server.unwrap<Server>();

```

#### Handling timeouts [\#](https://docs.nestjs.com/microservices/basics\#handling-timeouts)

In distributed systems, microservices might sometimes be down or unavailable. To prevent indefinitely long waiting, you can use timeouts. A timeout is a highly useful pattern when communicating with other services. To apply timeouts to your microservice calls, you can use the [RxJS](https://rxjs.dev/) `timeout` operator. If the microservice does not respond within the specified time, an exception is thrown, which you can catch and handle appropriately.

To implement this, you'll need to use the [`rxjs`](https://github.com/ReactiveX/rxjs) package. Simply use the `timeout` operator within the pipe:

content\_copy

JS  TS

```typescript

this.client
  .send<TResult, TInput>(pattern, data)
  .pipe(timeout(5000));

```

```typescript

this.client
  .send(pattern, data)
  .pipe(timeout(5000));

```

> **Hint** The `timeout` operator is imported from the `rxjs/operators` package.

After 5 seconds, if the microservice isn't responding, it will throw an error.

#### TLS support [\#](https://docs.nestjs.com/microservices/basics\#tls-support)

When communicating outside of a private network, it’s important to encrypt traffic to ensure security. In NestJS, this can be achieved with TLS over TCP using Node's built-in [TLS](https://nodejs.org/api/tls.html) module. Nest provides built-in support for TLS in its TCP transport, allowing us to encrypt communication between microservices or clients.

To enable TLS for a TCP server, you'll need both a private key and a certificate in PEM format. These are added to the server's options by setting the `tlsOptions` and specifying the key and cert files, as shown below:

content\_copy

```typescript

import * as fs from 'fs';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';

async function bootstrap() {
  const key = fs.readFileSync('<pathToKeyFile>', 'utf8').toString();
  const cert = fs.readFileSync('<pathToCertFile>', 'utf8').toString();

  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      options: {
        tlsOptions: {
          key,
          cert,
        },
      },
    },
  );

  await app.listen();
}
bootstrap();

```

For a client to communicate securely over TLS, we also define the `tlsOptions` object but this time with the CA certificate. This is the certificate of the authority that signed the server's certificate. This ensures that the client trusts the server's certificate and can establish a secure connection.

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'MATH_SERVICE',\
        transport: Transport.TCP,\
        options: {\
          tlsOptions: {\
            ca: [fs.readFileSync('<pathToCaFile>', 'utf-8').toString()],\
          },\
        },\
      },\
    ]),\
  ],
})
export class AppModule {}

```

You can also pass an array of CAs if your setup involves multiple trusted authorities.

Once everything is set up, you can inject the `ClientProxy` as usual using the `@Inject()` decorator to use the client in your services. This ensures encrypted communication across your NestJS microservices, with Node's `TLS` module handling the encryption details.

For more information, refer to Node’s [TLS documentation](https://nodejs.org/api/tls.html).

#### Dynamic configuration [\#](https://docs.nestjs.com/microservices/basics\#dynamic-configuration)

When a microservice needs to be configured using the `ConfigService` (from the `@nestjs/config` package), but the injection context is only available after the microservice instance is created, `AsyncMicroserviceOptions` offers a solution. This approach allows for dynamic configuration, ensuring smooth integration with the `ConfigService`.

content\_copy

```typescript

import { ConfigService } from '@nestjs/config';
import { AsyncMicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<AsyncMicroserviceOptions>(
    AppModule,
    {
      useFactory: (configService: ConfigService) => ({
        transport: Transport.TCP,
        options: {
          host: configService.get<string>('HOST'),
          port: configService.get<number>('PORT'),
        },
      }),
      inject: [ConfigService],
    },
  );

  await app.listen();
}
bootstrap();

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Scalars Overview
- [Scalars](https://docs.nestjs.com/graphql/scalars#scalars)
- [Code first](https://docs.nestjs.com/graphql/scalars#code-first)
- [Override a default scalar](https://docs.nestjs.com/graphql/scalars#override-a-default-scalar)
- [Import a custom scalar](https://docs.nestjs.com/graphql/scalars#import-a-custom-scalar)
- [Create a custom scalar](https://docs.nestjs.com/graphql/scalars#create-a-custom-scalar)
- [Schema first](https://docs.nestjs.com/graphql/scalars#schema-first)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/scalars.md "Suggest Edits")

### Scalars

A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That's where the scalar types come in: they represent the leaves of the query (read more [here](https://graphql.org/learn/schema/#scalar-types)). GraphQL includes the following default types: `Int`, `Float`, `String`, `Boolean` and `ID`. In addition to these built-in types, you may need to support custom atomic data types (e.g., `Date`).

#### Code first [\#](https://docs.nestjs.com/graphql/scalars\#code-first)

The code-first approach ships with five scalars in which three of them are simple aliases for the existing GraphQL types.

- `ID` (alias for `GraphQLID`) \- represents a unique identifier, often used to refetch an object or as the key for a cache
- `Int` (alias for `GraphQLInt`) \- a signed 32‐bit integer
- `Float` (alias for `GraphQLFloat`) \- a signed double-precision floating-point value
- `GraphQLISODateTime` \- a date-time string at UTC (used by default to represent `Date` type)
- `GraphQLTimestamp` \- a signed integer which represents date and time as number of milliseconds from start of UNIX epoch

The `GraphQLISODateTime` (e.g. `2019-12-03T09:54:33Z`) is used by default to represent the `Date` type. To use the `GraphQLTimestamp` instead, set the `dateScalarMode` of the `buildSchemaOptions` object to `'timestamp'` as follows:

content\_copy

```typescript

GraphQLModule.forRoot({
  buildSchemaOptions: {
    dateScalarMode: 'timestamp',
  }
}),

```

Likewise, the `GraphQLFloat` is used by default to represent the `number` type. To use the `GraphQLInt` instead, set the `numberScalarMode` of the `buildSchemaOptions` object to `'integer'` as follows:

content\_copy

```typescript

GraphQLModule.forRoot({
  buildSchemaOptions: {
    numberScalarMode: 'integer',
  }
}),

```

In addition, you can create custom scalars.

#### Override a default scalar [\#](https://docs.nestjs.com/graphql/scalars\#override-a-default-scalar)

To create a custom implementation for the `Date` scalar, simply create a new class.

content\_copy

```typescript

import { Scalar, CustomScalar } from '@nestjs/graphql';
import { Kind, ValueNode } from 'graphql';

@Scalar('Date', () => Date)
export class DateScalar implements CustomScalar<number, Date> {
  description = 'Date custom scalar type';

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}

```

With this in place, register `DateScalar` as a provider.

content\_copy

```typescript

@Module({
  providers: [DateScalar],
})
export class CommonModule {}

```

Now we can use the `Date` type in our classes.

content\_copy

```typescript

@Field()
creationDate: Date;

```

#### Import a custom scalar [\#](https://docs.nestjs.com/graphql/scalars\#import-a-custom-scalar)

To use a custom scalar, import and register it as a resolver. We’ll use the `graphql-type-json` package for demonstration purposes. This npm package defines a `JSON` GraphQL scalar type.

Start by installing the package:

```bash

$ npm i --save graphql-type-json

```

Once the package is installed, we pass a custom resolver to the `forRoot()` method:

content\_copy

```typescript

import GraphQLJSON from 'graphql-type-json';

@Module({
  imports: [\
    GraphQLModule.forRoot({\
      resolvers: { JSON: GraphQLJSON },\
    }),\
  ],
})
export class AppModule {}

```

Now we can use the `JSON` type in our classes.

content\_copy

```typescript

@Field(() => GraphQLJSON)
info: JSON;

```

For a suite of useful scalars, take a look at the [graphql-scalars](https://www.npmjs.com/package/graphql-scalars) package.

#### Create a custom scalar [\#](https://docs.nestjs.com/graphql/scalars\#create-a-custom-scalar)

To define a custom scalar, create a new `GraphQLScalarType` instance. We'll create a custom `UUID` scalar.

content\_copy

```typescript

const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

function validate(uuid: unknown): string | never {
  if (typeof uuid !== 'string' || !regex.test(uuid)) {
    throw new Error('invalid uuid');
  }
  return uuid;
}

export const CustomUuidScalar = new GraphQLScalarType({
  name: 'UUID',
  description: 'A simple UUID parser',
  serialize: (value) => validate(value),
  parseValue: (value) => validate(value),
  parseLiteral: (ast) => validate(ast.value),
});

```

We pass a custom resolver to the `forRoot()` method:

content\_copy

```typescript

@Module({
  imports: [\
    GraphQLModule.forRoot({\
      resolvers: { UUID: CustomUuidScalar },\
    }),\
  ],
})
export class AppModule {}

```

Now we can use the `UUID` type in our classes.

content\_copy

```typescript

@Field(() => CustomUuidScalar)
uuid: string;

```

#### Schema first [\#](https://docs.nestjs.com/graphql/scalars\#schema-first)

To define a custom scalar (read more about scalars [here](https://www.apollographql.com/docs/graphql-tools/scalars.html)), create a type definition and a dedicated resolver. Here (as in the official documentation), we’ll use the `graphql-type-json` package for demonstration purposes. This npm package defines a `JSON` GraphQL scalar type.

Start by installing the package:

```bash

$ npm i --save graphql-type-json

```

Once the package is installed, we pass a custom resolver to the `forRoot()` method:

content\_copy

```typescript

import GraphQLJSON from 'graphql-type-json';

@Module({
  imports: [\
    GraphQLModule.forRoot({\
      typePaths: ['./**/*.graphql'],\
      resolvers: { JSON: GraphQLJSON },\
    }),\
  ],
})
export class AppModule {}

```

Now we can use the `JSON` scalar in our type definitions:

```graphql

scalar JSON

type Foo {
  field: JSON
}

```

Another method to define a scalar type is to create a simple class. Assume we want to enhance our schema with the `Date` type.

content\_copy

```typescript

import { Scalar, CustomScalar } from '@nestjs/graphql';
import { Kind, ValueNode } from 'graphql';

@Scalar('Date')
export class DateScalar implements CustomScalar<number, Date> {
  description = 'Date custom scalar type';

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}

```

With this in place, register `DateScalar` as a provider.

content\_copy

```typescript

@Module({
  providers: [DateScalar],
})
export class CommonModule {}

```

Now we can use the `Date` scalar in type definitions.

```graphql

scalar Date

```

By default, the generated TypeScript definition for all scalars is `any` \- which isn't particularly typesafe.
But, you can configure how Nest generates typings for your custom scalars when you specify how to generate types:

content\_copy

```typescript

import { GraphQLDefinitionsFactory } from '@nestjs/graphql';
import { join } from 'path';

const definitionsFactory = new GraphQLDefinitionsFactory();

definitionsFactory.generate({
  typePaths: ['./src/**/*.graphql'],
  path: join(process.cwd(), 'src/graphql.ts'),
  outputAs: 'class',
  defaultScalarType: 'unknown',
  customScalarTypeMapping: {
    DateTime: 'Date',
    BigNumber: '_BigNumber',
  },
  additionalHeader: "import _BigNumber from 'bignumber.js'",
});

```

> **Hint** Alternatively, you can use a type reference instead, for example: `DateTime: Date`. In this case, `GraphQLDefinitionsFactory` will extract the name property of the specified type ( `Date.name`) to generate TS definitions. Note: adding an import statement for non-built-in types (custom types) is required.

Now, given the following GraphQL custom scalar types:

```graphql

scalar DateTime
scalar BigNumber
scalar Payload

```

We will now see the following generated TypeScript definitions in `src/graphql.ts`:

content\_copy

```typescript

import _BigNumber from 'bignumber.js';

export type DateTime = Date;
export type BigNumber = _BigNumber;
export type Payload = unknown;

```

Here, we've used the `customScalarTypeMapping` property to supply a map of the types we wish to declare for our custom scalars. We've
also provided an `additionalHeader` property so that we can add any imports required for these type definitions. Lastly, we've added
a `defaultScalarType` of `'unknown'`, so that any custom scalars not specified in `customScalarTypeMapping` will be aliased to
`unknown` instead of `any` (which [TypeScript recommends](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type) using since 3.0 for added type safety).

> **Hint** Note that we've imported `_BigNumber` from `bignumber.js`; this is to avoid [circular type references](https://github.com/Microsoft/TypeScript/issues/12525#issuecomment-263166239).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS MQTT Microservices
- [MQTT](https://docs.nestjs.com/microservices/mqtt#mqtt)
- [Installation](https://docs.nestjs.com/microservices/mqtt#installation)
- [Overview](https://docs.nestjs.com/microservices/mqtt#overview)
- [Options](https://docs.nestjs.com/microservices/mqtt#options)
- [Client](https://docs.nestjs.com/microservices/mqtt#client)
- [Context](https://docs.nestjs.com/microservices/mqtt#context)
- [Wildcards](https://docs.nestjs.com/microservices/mqtt#wildcards)
- [Quality of Service (QoS)](https://docs.nestjs.com/microservices/mqtt#quality-of-service-qos)
- [Record builders](https://docs.nestjs.com/microservices/mqtt#record-builders)
- [Instance status updates](https://docs.nestjs.com/microservices/mqtt#instance-status-updates)
- [Listening to MQTT events](https://docs.nestjs.com/microservices/mqtt#listening-to-mqtt-events)
- [Underlying driver access](https://docs.nestjs.com/microservices/mqtt#underlying-driver-access)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/mqtt.md "Suggest Edits")

### MQTT

[MQTT](https://mqtt.org/) (Message Queuing Telemetry Transport) is an open source, lightweight messaging protocol, optimized for low latency. This protocol provides a scalable and cost-efficient way to connect devices using a **publish/subscribe** model. A communication system built on MQTT consists of the publishing server, a broker and one or more clients. It is designed for constrained devices and low-bandwidth, high-latency or unreliable networks.

#### Installation [\#](https://docs.nestjs.com/microservices/mqtt\#installation)

To start building MQTT-based microservices, first install the required package:

```bash

$ npm i --save mqtt

```

#### Overview [\#](https://docs.nestjs.com/microservices/mqtt\#overview)

To use the MQTT transporter, pass the following options object to the `createMicroservice()` method:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.MQTT,
  options: {
    url: 'mqtt://localhost:1883',
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.MQTT,
  options: {
    url: 'mqtt://localhost:1883',
  },
});

```

> **Hint** The `Transport` enum is imported from the `@nestjs/microservices` package.

#### Options [\#](https://docs.nestjs.com/microservices/mqtt\#options)

The `options` object is specific to the chosen transporter. The **MQTT** transporter exposes the properties described [here](https://github.com/mqttjs/MQTT.js/#mqttclientstreambuilder-options).

#### Client [\#](https://docs.nestjs.com/microservices/mqtt\#client)

Like other microservice transporters, you have [several options](https://docs.nestjs.com/microservices/basics#client) for creating a MQTT `ClientProxy` instance.

One method for creating an instance is to use use the `ClientsModule`. To create a client instance with the `ClientsModule`, import it and use the `register()` method to pass an options object with the same properties shown above in the `createMicroservice()` method, as well as a `name` property to be used as the injection token. Read more about `ClientsModule` [here](https://docs.nestjs.com/microservices/basics#client).

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'MATH_SERVICE',\
        transport: Transport.MQTT,\
        options: {\
          url: 'mqtt://localhost:1883',\
        }\
      },\
    ]),\
  ]
  ...
})

```

Other options to create a client (either `ClientProxyFactory` or `@Client()`) can be used as well. You can read about them [here](https://docs.nestjs.com/microservices/basics#client).

#### Context [\#](https://docs.nestjs.com/microservices/mqtt\#context)

In more complex scenarios, you may need to access additional information about the incoming request. When using the MQTT transporter, you can access the `MqttContext` object.

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: MqttContext) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `MqttContext` are imported from the `@nestjs/microservices` package.

To access the original mqtt [packet](https://github.com/mqttjs/mqtt-packet), use the `getPacket()` method of the `MqttContext` object, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: MqttContext) {
  console.log(context.getPacket());
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(context.getPacket());
}

```

#### Wildcards [\#](https://docs.nestjs.com/microservices/mqtt\#wildcards)

A subscription may be to an explicit topic, or it may include wildcards. Two wildcards are available, `+` and `#`. `+` is a single-level wildcard, while `#` is a multi-level wildcard which covers many topic levels.

content\_copy

JS  TS

```typescript

@MessagePattern('sensors/+/temperature/+')
getTemperature(@Ctx() context: MqttContext) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

```typescript

@Bind(Ctx())
@MessagePattern('sensors/+/temperature/+')
getTemperature(context) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

#### Quality of Service (QoS) [\#](https://docs.nestjs.com/microservices/mqtt\#quality-of-service-qos)

Any subscription created with `@MessagePattern` or `@EventPattern` decorators will subscribe with QoS 0. If a higher QoS is required, it can be set globally using the `subscribeOptions` block when establishing the connection as follows:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.MQTT,
  options: {
    url: 'mqtt://localhost:1883',
    subscribeOptions: {
      qos: 2
    },
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.MQTT,
  options: {
    url: 'mqtt://localhost:1883',
    subscribeOptions: {
      qos: 2
    },
  },
});

```

If a topic specific QoS is required, consider creating a [Custom transporter](https://docs.nestjs.com/microservices/custom-transport).

#### Record builders [\#](https://docs.nestjs.com/microservices/mqtt\#record-builders)

To configure message options (adjust the QoS level, set the Retain or DUP flags, or add additional properties to the payload), you can use the `MqttRecordBuilder` class. For example, to set `QoS` to `2` use the `setQoS` method, as follows:

content\_copy

```typescript

const userProperties = { 'x-version': '1.0.0' };
const record = new MqttRecordBuilder(':cat:')
  .setProperties({ userProperties })
  .setQoS(1)
  .build();
client.send('replace-emoji', record).subscribe(...);

```

> **Hint** `MqttRecordBuilder` class is exported from the `@nestjs/microservices` package.

And you can read these options on the server-side as well, by accessing the `MqttContext`.

content\_copy

JS  TS

```typescript

@MessagePattern('replace-emoji')
replaceEmoji(@Payload() data: string, @Ctx() context: MqttContext): string {
  const { properties: { userProperties } } = context.getPacket();
  return userProperties['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('replace-emoji')
replaceEmoji(data, context) {
  const { properties: { userProperties } } = context.getPacket();
  return userProperties['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

In some cases you might want to configure user properties for multiple requests, you can pass these options to the `ClientProxyFactory`.

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { ClientProxyFactory, Transport } from '@nestjs/microservices';

@Module({
  providers: [\
    {\
      provide: 'API_v1',\
      useFactory: () =>\
        ClientProxyFactory.create({\
          transport: Transport.MQTT,\
          options: {\
            url: 'mqtt://localhost:1833',\
            userProperties: { 'x-version': '1.0.0' },\
          },\
        }),\
    },\
  ],
})
export class ApiModule {}

```

#### Instance status updates [\#](https://docs.nestjs.com/microservices/mqtt\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For the MQTT driver, the `status` stream emits `connected`, `disconnected`, `reconnecting`, and `closed` events.

content\_copy

```typescript

this.client.status.subscribe((status: MqttStatus) => {
  console.log(status);
});

```

> **Hint** The `MqttStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: MqttStatus) => {
  console.log(status);
});

```

#### Listening to MQTT events [\#](https://docs.nestjs.com/microservices/mqtt\#listening-to-mqtt-events)

In some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the `error` event to trigger additional operations when an error occurs. To do this, use the `on()` method, as shown below:

content\_copy

```typescript

this.client.on('error', (err) => {
  console.error(err);
});

```

Similarly, you can listen to the server's internal events:

content\_copy

```typescript

server.on<MqttEvents>('error', (err) => {
  console.error(err);
});

```

> **Hint** The `MqttEvents` type is imported from the `@nestjs/microservices` package.

#### Underlying driver access [\#](https://docs.nestjs.com/microservices/mqtt\#underlying-driver-access)

For more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use the `unwrap()` method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.

content\_copy

```typescript

const mqttClient = this.client.unwrap<import('mqtt').MqttClient>();

```

Similarly, you can access the server's underlying driver instance:

content\_copy

```typescript

const mqttClient = server.unwrap<import('mqtt').MqttClient>();

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## CORS in NestJS
- [CORS](https://docs.nestjs.com/security/cors#cors)
- [Getting started](https://docs.nestjs.com/security/cors#getting-started)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/cors.md "Suggest Edits")

### CORS

Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from another domain. Under the hood, Nest makes use of the Express [cors](https://github.com/expressjs/cors) or Fastify [@fastify/cors](https://github.com/fastify/fastify-cors) packages depending on the underlying platform. These packages provide various options that you can customize based on your requirements.

#### Getting started [\#](https://docs.nestjs.com/security/cors\#getting-started)

To enable CORS, call the `enableCors()` method on the Nest application object.

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
app.enableCors();
await app.listen(process.env.PORT ?? 3000);

```

The `enableCors()` method takes an optional configuration object argument. The available properties of this object are described in the official [CORS](https://github.com/expressjs/cors#configuration-options) documentation. Another way is to pass a [callback function](https://github.com/expressjs/cors#configuring-cors-asynchronously) that lets you define the configuration object asynchronously based on the request (on the fly).

Alternatively, enable CORS via the `create()` method's options object. Set the `cors` property to `true` to enable CORS with default settings.
Or, pass a [CORS configuration object](https://github.com/expressjs/cors#configuration-options) or [callback function](https://github.com/expressjs/cors#configuring-cors-asynchronously) as the `cors` property value to customize its behavior.

content\_copy

```typescript

const app = await NestFactory.create(AppModule, { cors: true });
await app.listen(process.env.PORT ?? 3000);

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Subscriptions in NestJS
- [Subscriptions](https://docs.nestjs.com/graphql/subscriptions#subscriptions)
- [Enable subscriptions with Apollo driver](https://docs.nestjs.com/graphql/subscriptions#enable-subscriptions-with-apollo-driver)
- [Code first](https://docs.nestjs.com/graphql/subscriptions#code-first)
- [Publishing](https://docs.nestjs.com/graphql/subscriptions#publishing)
- [Filtering subscriptions](https://docs.nestjs.com/graphql/subscriptions#filtering-subscriptions)
- [Mutating subscription payloads](https://docs.nestjs.com/graphql/subscriptions#mutating-subscription-payloads)
- [Schema first](https://docs.nestjs.com/graphql/subscriptions#schema-first)
- [PubSub](https://docs.nestjs.com/graphql/subscriptions#pubsub)
- [Customize subscriptions server](https://docs.nestjs.com/graphql/subscriptions#customize-subscriptions-server)
- [Authentication over WebSockets](https://docs.nestjs.com/graphql/subscriptions#authentication-over-websockets)
- [Enable subscriptions with Mercurius driver](https://docs.nestjs.com/graphql/subscriptions#enable-subscriptions-with-mercurius-driver)
- [Code first](https://docs.nestjs.com/graphql/subscriptions#code-first-1)
- [Publishing](https://docs.nestjs.com/graphql/subscriptions#publishing-1)
- [Filtering subscriptions](https://docs.nestjs.com/graphql/subscriptions#filtering-subscriptions-1)
- [Schema first](https://docs.nestjs.com/graphql/subscriptions#schema-first-1)
- [PubSub](https://docs.nestjs.com/graphql/subscriptions#pubsub-1)
- [Authentication over WebSockets](https://docs.nestjs.com/graphql/subscriptions#authentication-over-websockets-1)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/subscriptions.md "Suggest Edits")

### Subscriptions

In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called `subscription`. GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a channel is opened and a result is sent to the client every time a particular event happens on the server.

A common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on (read more [here](https://www.apollographql.com/docs/react/data/subscriptions)).

#### Enable subscriptions with Apollo driver [\#](https://docs.nestjs.com/graphql/subscriptions\#enable-subscriptions-with-apollo-driver)

To enable subscriptions, set the `installSubscriptionHandlers` property to `true`.

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  installSubscriptionHandlers: true,
}),

```

> **Warning** The `installSubscriptionHandlers` configuration option has been removed from the latest version of Apollo server and will be soon deprecated in this package as well. By default, `installSubscriptionHandlers` will fallback to use the `subscriptions-transport-ws` ( [read more](https://github.com/apollographql/subscriptions-transport-ws)) but we strongly recommend using the `graphql-ws`( [read more](https://github.com/enisdenjo/graphql-ws)) library instead.

To switch to use the `graphql-ws` package instead, use the following configuration:

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  subscriptions: {
    'graphql-ws': true
  },
}),

```

> **Hint** You can also use both packages ( `subscriptions-transport-ws` and `graphql-ws`) at the same time, for example, for backward compatibility.

#### Code first [\#](https://docs.nestjs.com/graphql/subscriptions\#code-first)

To create a subscription using the code first approach, we use the `@Subscription()` decorator (exported from the `@nestjs/graphql` package) and the `PubSub` class from the `graphql-subscriptions` package, which provides a simple **publish/subscribe API**.

The following subscription handler takes care of **subscribing** to an event by calling `PubSub#asyncIterableIterator`. This method takes a single argument, the `triggerName`, which corresponds to an event topic name.

content\_copy

```typescript

const pubSub = new PubSub();

@Resolver(() => Author)
export class AuthorResolver {
  // ...
  @Subscription(() => Comment)
  commentAdded() {
    return pubSub.asyncIterableIterator('commentAdded');
  }
}

```

> **Hint** All decorators are exported from the `@nestjs/graphql` package, while the `PubSub` class is exported from the `graphql-subscriptions` package.

> **Note** `PubSub` is a class that exposes a simple `publish` and `subscribe API`. Read more about it [here](https://www.apollographql.com/docs/graphql-subscriptions/setup.html). Note that the Apollo docs warn that the default implementation is not suitable for production (read more [here](https://github.com/apollographql/graphql-subscriptions#getting-started-with-your-first-subscription)). Production apps should use a `PubSub` implementation backed by an external store (read more [here](https://github.com/apollographql/graphql-subscriptions#pubsub-implementations)).

This will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Subscription {
  commentAdded(): Comment!
}

```

Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., `commentAdded` above), or is provided explicitly by passing an option with the key `name` as the second argument to the `@Subscription()` decorator, as shown below.

content\_copy

```typescript

@Subscription(() => Comment, {
  name: 'commentAdded',
})
subscribeToCommentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription.

#### Publishing [\#](https://docs.nestjs.com/graphql/subscriptions\#publishing)

Now, to publish the event, we use the `PubSub#publish` method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:

content\_copy posts/posts.resolver.ts

JS  TS

```typescript

@Mutation(() => Comment)
async addComment(
  @Args('postId', { type: () => Int }) postId: number,
  @Args('comment', { type: () => Comment }) comment: CommentInput,
) {
  const newComment = this.commentsService.addComment({ id: postId, comment });
  pubSub.publish('commentAdded', { commentAdded: newComment });
  return newComment;
}

```

The `PubSub#publish` method takes a `triggerName` (again, think of this as an event topic name) as the first parameter, and an event payload as the second parameter. As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our `commentAdded` subscription:

```graphql

type Subscription {
  commentAdded(): Comment!
}

```

This tells us that the subscription must return an object with a top-level property name of `commentAdded` that has a value which is a `Comment` object. The important point to note is that the shape of the event payload emitted by the `PubSub#publish` method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the `pubSub.publish('commentAdded', { commentAdded: newComment })` statement publishes a `commentAdded` event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase.

#### Filtering subscriptions [\#](https://docs.nestjs.com/graphql/subscriptions\#filtering-subscriptions)

To filter out specific events, set the `filter` property to a filter function. This function acts similar to the function passed to an array `filter`. It takes two arguments: `payload` containing the event payload (as sent by the event publisher), and `variables` taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners.

content\_copy

```typescript

@Subscription(() => Comment, {
  filter: (payload, variables) =>
    payload.commentAdded.title === variables.title,
})
commentAdded(@Args('title') title: string) {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

#### Mutating subscription payloads [\#](https://docs.nestjs.com/graphql/subscriptions\#mutating-subscription-payloads)

To mutate the published event payload, set the `resolve` property to a function. The function receives the event payload (as sent by the event publisher) and returns the appropriate value.

content\_copy

```typescript

@Subscription(() => Comment, {
  resolve: value => value,
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

> **Note** If you use the `resolve` option, you should return the unwrapped payload (e.g., with our example, return a `newComment` object directly, not a `{ commentAdded: newComment }` object).

If you need to access injected providers (e.g., use an external service to validate the data), use the following construction.

content\_copy

```typescript

@Subscription(() => Comment, {
  resolve(this: AuthorResolver, value) {
    // "this" refers to an instance of "AuthorResolver"
    return value;
  }
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

The same construction works with filters:

content\_copy

```typescript

@Subscription(() => Comment, {
  filter(this: AuthorResolver, payload, variables) {
    // "this" refers to an instance of "AuthorResolver"
    return payload.commentAdded.title === variables.title;
  }
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

#### Schema first [\#](https://docs.nestjs.com/graphql/subscriptions\#schema-first)

To create an equivalent subscription in Nest, we'll make use of the `@Subscription()` decorator.

content\_copy

```typescript

const pubSub = new PubSub();

@Resolver('Author')
export class AuthorResolver {
  // ...
  @Subscription()
  commentAdded() {
    return pubSub.asyncIterableIterator('commentAdded');
  }
}

```

To filter out specific events based on context and arguments, set the `filter` property.

content\_copy

```typescript

@Subscription('commentAdded', {
  filter: (payload, variables) =>
    payload.commentAdded.title === variables.title,
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

To mutate the published payload, we can use a `resolve` function.

content\_copy

```typescript

@Subscription('commentAdded', {
  resolve: value => value,
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:

content\_copy

```typescript

@Subscription('commentAdded', {
  resolve(this: AuthorResolver, value) {
    // "this" refers to an instance of "AuthorResolver"
    return value;
  }
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

The same construction works with filters:

content\_copy

```typescript

@Subscription('commentAdded', {
  filter(this: AuthorResolver, payload, variables) {
    // "this" refers to an instance of "AuthorResolver"
    return payload.commentAdded.title === variables.title;
  }
})
commentAdded() {
  return pubSub.asyncIterableIterator('commentAdded');
}

```

The last step is to update the type definitions file.

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String
  votes: Int
}

type Query {
  author(id: Int!): Author
}

type Comment {
  id: String
  content: String
}

type Subscription {
  commentAdded(title: String!): Comment
}

```

With this, we've created a single `commentAdded(title: String!): Comment` subscription. You can find a full sample implementation [here](https://github.com/nestjs/nest/blob/master/sample/12-graphql-schema-first).

#### PubSub [\#](https://docs.nestjs.com/graphql/subscriptions\#pubsub)

We instantiated a local `PubSub` instance above. The preferred approach is to define `PubSub` as a [provider](https://docs.nestjs.com/fundamentals/custom-providers) and inject it through the constructor (using the `@Inject()` decorator). This allows us to re-use the instance across the whole application. For example, define a provider as follows, then inject `'PUB_SUB'` where needed.

content\_copy

```typescript

{
  provide: 'PUB_SUB',
  useValue: new PubSub(),
}

```

#### Customize subscriptions server [\#](https://docs.nestjs.com/graphql/subscriptions\#customize-subscriptions-server)

To customize the subscriptions server (e.g., change the path), use the `subscriptions` options property.

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  subscriptions: {
    'subscriptions-transport-ws': {
      path: '/graphql'
    },
  }
}),

```

If you're using the `graphql-ws` package for subscriptions, replace the `subscriptions-transport-ws` key with `graphql-ws`, as follows:

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  subscriptions: {
    'graphql-ws': {
      path: '/graphql'
    },
  }
}),

```

#### Authentication over WebSockets [\#](https://docs.nestjs.com/graphql/subscriptions\#authentication-over-websockets)

Checking whether the user is authenticated can be done inside the `onConnect` callback function that you can specify in the `subscriptions` options.

The `onConnect` will receive as a first argument the `connectionParams` passed to the `SubscriptionClient` (read [more](https://www.apollographql.com/docs/react/data/subscriptions/#5-authenticate-over-websocket-optional)).

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  subscriptions: {
    'subscriptions-transport-ws': {
      onConnect: (connectionParams) => {
        const authToken = connectionParams.authToken;
        if (!isValid(authToken)) {
          throw new Error('Token is not valid');
        }
        // extract user information from token
        const user = parseToken(authToken);
        // return user info to add them to the context later
        return { user };
      },
    }
  },
  context: ({ connection }) => {
    // connection.context will be equal to what was returned by the "onConnect" callback
  },
}),

```

The `authToken` in this example is only sent once by the client, when the connection is first established.
All subscriptions made with this connection will have the same `authToken`, and thus the same user info.

> **Note** There is a bug in `subscriptions-transport-ws` that allows connections to skip the `onConnect` phase (read [more](https://github.com/apollographql/subscriptions-transport-ws/issues/349)). You should not assume that `onConnect` was called when the user starts a subscription, and always check that the `context` is populated.

If you're using the `graphql-ws` package, the signature of the `onConnect` callback will be slightly different:

content\_copy

```typescript

GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
  subscriptions: {
    'graphql-ws': {
      onConnect: (context: Context<any>) => {
        const { connectionParams, extra } = context;
        // user validation will remain the same as in the example above
        // when using with graphql-ws, additional context value should be stored in the extra field
        extra.user = { user: {} };
      },
    },
  },
  context: ({ extra }) => {
    // you can now access your additional context value through the extra field
  },
});

```

#### Enable subscriptions with Mercurius driver [\#](https://docs.nestjs.com/graphql/subscriptions\#enable-subscriptions-with-mercurius-driver)

To enable subscriptions, set the `subscription` property to `true`.

content\_copy

```typescript

GraphQLModule.forRoot<MercuriusDriverConfig>({
  driver: MercuriusDriver,
  subscription: true,
}),

```

> **Hint** You can also pass the options object to set up a custom emitter, validate incoming connections, etc. Read more [here](https://github.com/mercurius-js/mercurius/blob/master/docs/api/options.md#plugin-options) (see `subscription`).

#### Code first [\#](https://docs.nestjs.com/graphql/subscriptions\#code-first-1)

To create a subscription using the code first approach, we use the `@Subscription()` decorator (exported from the `@nestjs/graphql` package) and the `PubSub` class from the `mercurius` package, which provides a simple **publish/subscribe API**.

The following subscription handler takes care of **subscribing** to an event by calling `PubSub#asyncIterableIterator`. This method takes a single argument, the `triggerName`, which corresponds to an event topic name.

content\_copy

```typescript

@Resolver(() => Author)
export class AuthorResolver {
  // ...
  @Subscription(() => Comment)
  commentAdded(@Context('pubsub') pubSub: PubSub) {
    return pubSub.subscribe('commentAdded');
  }
}

```

> **Hint** All decorators used in the example above are exported from the `@nestjs/graphql` package, while the `PubSub` class is exported from the `mercurius` package.

> **Note** `PubSub` is a class that exposes a simple `publish` and `subscribe` API. Check out [this section](https://github.com/mercurius-js/mercurius/blob/master/docs/subscriptions.md#subscriptions-with-custom-pubsub) on how to register a custom `PubSub` class.

This will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Subscription {
  commentAdded(): Comment!
}

```

Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., `commentAdded` above), or is provided explicitly by passing an option with the key `name` as the second argument to the `@Subscription()` decorator, as shown below.

content\_copy

```typescript

@Subscription(() => Comment, {
  name: 'commentAdded',
})
subscribeToCommentAdded(@Context('pubsub') pubSub: PubSub) {
  return pubSub.subscribe('commentAdded');
}

```

This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription.

#### Publishing [\#](https://docs.nestjs.com/graphql/subscriptions\#publishing-1)

Now, to publish the event, we use the `PubSub#publish` method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:

content\_copy posts/posts.resolver.ts

JS  TS

```typescript

@Mutation(() => Comment)
async addComment(
  @Args('postId', { type: () => Int }) postId: number,
  @Args('comment', { type: () => Comment }) comment: CommentInput,
  @Context('pubsub') pubSub: PubSub,
) {
  const newComment = this.commentsService.addComment({ id: postId, comment });
  await pubSub.publish({
    topic: 'commentAdded',
    payload: {
      commentAdded: newComment
    }
  });
  return newComment;
}

```

As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our `commentAdded` subscription:

```graphql

type Subscription {
  commentAdded(): Comment!
}

```

This tells us that the subscription must return an object with a top-level property name of `commentAdded` that has a value which is a `Comment` object. The important point to note is that the shape of the event payload emitted by the `PubSub#publish` method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the `pubSub.publish({ topic: 'commentAdded', payload: { commentAdded: newComment } })` statement publishes a `commentAdded` event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase.

#### Filtering subscriptions [\#](https://docs.nestjs.com/graphql/subscriptions\#filtering-subscriptions-1)

To filter out specific events, set the `filter` property to a filter function. This function acts similar to the function passed to an array `filter`. It takes two arguments: `payload` containing the event payload (as sent by the event publisher), and `variables` taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners.

content\_copy

```typescript

@Subscription(() => Comment, {
  filter: (payload, variables) =>
    payload.commentAdded.title === variables.title,
})
commentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {
  return pubSub.subscribe('commentAdded');
}

```

If you need to access injected providers (e.g., use an external service to validate the data), use the following construction.

content\_copy

```typescript

@Subscription(() => Comment, {
  filter(this: AuthorResolver, payload, variables) {
    // "this" refers to an instance of "AuthorResolver"
    return payload.commentAdded.title === variables.title;
  }
})
commentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {
  return pubSub.subscribe('commentAdded');
}

```

#### Schema first [\#](https://docs.nestjs.com/graphql/subscriptions\#schema-first-1)

To create an equivalent subscription in Nest, we'll make use of the `@Subscription()` decorator.

content\_copy

```typescript

const pubSub = new PubSub();

@Resolver('Author')
export class AuthorResolver {
  // ...
  @Subscription()
  commentAdded(@Context('pubsub') pubSub: PubSub) {
    return pubSub.subscribe('commentAdded');
  }
}

```

To filter out specific events based on context and arguments, set the `filter` property.

content\_copy

```typescript

@Subscription('commentAdded', {
  filter: (payload, variables) =>
    payload.commentAdded.title === variables.title,
})
commentAdded(@Context('pubsub') pubSub: PubSub) {
  return pubSub.subscribe('commentAdded');
}

```

If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:

content\_copy

```typescript

@Subscription('commentAdded', {
  filter(this: AuthorResolver, payload, variables) {
    // "this" refers to an instance of "AuthorResolver"
    return payload.commentAdded.title === variables.title;
  }
})
commentAdded(@Context('pubsub') pubSub: PubSub) {
  return pubSub.subscribe('commentAdded');
}

```

The last step is to update the type definitions file.

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String
  votes: Int
}

type Query {
  author(id: Int!): Author
}

type Comment {
  id: String
  content: String
}

type Subscription {
  commentAdded(title: String!): Comment
}

```

With this, we've created a single `commentAdded(title: String!): Comment` subscription.

#### PubSub [\#](https://docs.nestjs.com/graphql/subscriptions\#pubsub-1)

In the examples above, we used the default `PubSub` emitter ( [mqemitter](https://github.com/mcollina/mqemitter))
The preferred approach (for production) is to use `mqemitter-redis`. Alternatively, a custom `PubSub` implementation can be provided (read more [here](https://github.com/mercurius-js/mercurius/blob/master/docs/subscriptions.md))

content\_copy

```typescript

GraphQLModule.forRoot<MercuriusDriverConfig>({
  driver: MercuriusDriver,
  subscription: {
    emitter: require('mqemitter-redis')({
      port: 6579,
      host: '127.0.0.1',
    }),
  },
});

```

#### Authentication over WebSockets [\#](https://docs.nestjs.com/graphql/subscriptions\#authentication-over-websockets-1)

Checking whether the user is authenticated can be done inside the `verifyClient` callback function that you can specify in the `subscription` options.

The `verifyClient` will receive the `info` object as a first argument which you can use to retrieve the request's headers.

content\_copy

```typescript

GraphQLModule.forRoot<MercuriusDriverConfig>({
  driver: MercuriusDriver,
  subscription: {
    verifyClient: (info, next) => {
      const authorization = info.req.headers?.authorization as string;
      if (!authorization?.startsWith('Bearer ')) {
        return next(false);
      }
      next(true);
    },
  }
}),

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Versioning Techniques
- [Versioning](https://docs.nestjs.com/techniques/versioning#versioning)
- [URI Versioning Type](https://docs.nestjs.com/techniques/versioning#uri-versioning-type)
- [Header Versioning Type](https://docs.nestjs.com/techniques/versioning#header-versioning-type)
- [Media Type Versioning Type](https://docs.nestjs.com/techniques/versioning#media-type-versioning-type)
- [Custom Versioning Type](https://docs.nestjs.com/techniques/versioning#custom-versioning-type)
- [Usage](https://docs.nestjs.com/techniques/versioning#usage)
- [Controller versions](https://docs.nestjs.com/techniques/versioning#controller-versions)
- [Route versions](https://docs.nestjs.com/techniques/versioning#route-versions)
- [Multiple versions](https://docs.nestjs.com/techniques/versioning#multiple-versions)
- [Version "Neutral"](https://docs.nestjs.com/techniques/versioning#version-neutral)
- [Global default version](https://docs.nestjs.com/techniques/versioning#global-default-version)
- [Middleware versioning](https://docs.nestjs.com/techniques/versioning#middleware-versioning)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/versioning.md "Suggest Edits")

### Versioning

> **Hint** This chapter is only relevant to HTTP-based applications.

Versioning allows you to have **different versions** of your controllers or individual routes running within the same application. Applications change very often and it is not unusual that there are breaking changes that you need to make while still needing to support the previous version of the application.

There are 4 types of versioning that are supported:

|     |     |
| --- | --- |
| [`URI Versioning`](https://docs.nestjs.com/techniques/versioning#uri-versioning-type) | The version will be passed within the URI of the request (default) |
| [`Header Versioning`](https://docs.nestjs.com/techniques/versioning#header-versioning-type) | A custom request header will specify the version |
| [`Media Type Versioning`](https://docs.nestjs.com/techniques/versioning#media-type-versioning-type) | The `Accept` header of the request will specify the version |
| [`Custom Versioning`](https://docs.nestjs.com/techniques/versioning#custom-versioning-type) | Any aspect of the request may be used to specify the version(s). A custom function is provided to extract said version(s). |

#### URI Versioning Type [\#](https://docs.nestjs.com/techniques/versioning\#uri-versioning-type)

URI Versioning uses the version passed within the URI of the request, such as `https://example.com/v1/route` and `https://example.com/v2/route`.

> **Notice** With URI Versioning the version will be automatically added to the URI after the [global path prefix](https://docs.nestjs.com/faq/global-prefix) (if one exists), and before any controller or route paths.

To enable URI Versioning for your application, do the following:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
// or "app.enableVersioning()"
app.enableVersioning({
  type: VersioningType.URI,
});
await app.listen(process.env.PORT ?? 3000);

```

> **Notice** The version in the URI will be automatically prefixed with `v` by default, however the prefix value can be configured by setting the `prefix` key to your desired prefix or `false` if you wish to disable it.

> **Hint** The `VersioningType` enum is available to use for the `type` property and is imported from the `@nestjs/common` package.

#### Header Versioning Type [\#](https://docs.nestjs.com/techniques/versioning\#header-versioning-type)

Header Versioning uses a custom, user specified, request header to specify the version where the value of the header will be the version to use for the request.

Example HTTP Requests for Header Versioning:

To enable **Header Versioning** for your application, do the following:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
app.enableVersioning({
  type: VersioningType.HEADER,
  header: 'Custom-Header',
});
await app.listen(process.env.PORT ?? 3000);

```

The `header` property should be the name of the header that will contain the version of the request.

> **Hint** The `VersioningType` enum is available to use for the `type` property and is imported from the `@nestjs/common` package.

#### Media Type Versioning Type [\#](https://docs.nestjs.com/techniques/versioning\#media-type-versioning-type)

Media Type Versioning uses the `Accept` header of the request to specify the version.

Within the `Accept` header, the version will be separated from the media type with a semi-colon, `;`. It should then contain a key-value pair that represents the version to use for the request, such as `Accept: application/json;v=2`. They key is treated more as a prefix when determining the version will to be configured to include the key and separator.

To enable **Media Type Versioning** for your application, do the following:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
app.enableVersioning({
  type: VersioningType.MEDIA_TYPE,
  key: 'v=',
});
await app.listen(process.env.PORT ?? 3000);

```

The `key` property should be the key and separator of the key-value pair that contains the version. For the example `Accept: application/json;v=2`, the `key` property would be set to `v=`.

> **Hint** The `VersioningType` enum is available to use for the `type` property and is imported from the `@nestjs/common` package.

#### Custom Versioning Type [\#](https://docs.nestjs.com/techniques/versioning\#custom-versioning-type)

Custom Versioning uses any aspect of the request to specify the version (or versions). The incoming request is analyzed
using an `extractor` function that returns a string or array of strings.

If multiple versions are provided by the requester, the extractor function can return an array of strings, sorted in
order of greatest/highest version to smallest/lowest version. Versions are matched to routes in order from highest to
lowest.

If an empty string or array is returned from the `extractor`, no routes are matched and a 404 is returned.

For example, if an incoming request specifies it supports versions `1`, `2`, and `3`, the `extractor` **MUST** return `[3, 2, 1]`. This ensures that the highest possible route version is selected first.

If versions `[3, 2, 1]` are extracted, but routes only exist for version `2` and `1`, the route that matches version `2`
is selected (version `3` is automatically ignored).

> **Notice** Selecting the highest matching version based on the array returned from `extractor` \> **does not reliably work** with the Express adapter due to design limitations. A single version (either a string or
> array of 1 element) works just fine in Express. Fastify correctly supports both highest matching version
> selection and single version selection.

To enable **Custom Versioning** for your application, create an `extractor` function and pass it into your application
like so:

content\_copy main.ts

JS  TS

```typescript

// Example extractor that pulls out a list of versions from a custom header and turns it into a sorted array.
// This example uses Fastify, but Express requests can be processed in a similar way.
const extractor = (request: FastifyRequest): string | string[] =>
  [request.headers['custom-versioning-field'] ?? '']
     .flatMap(v => v.split(','))
     .filter(v => !!v)
     .sort()
     .reverse()

const app = await NestFactory.create(AppModule);
app.enableVersioning({
  type: VersioningType.CUSTOM,
  extractor,
});
await app.listen(process.env.PORT ?? 3000);

```

#### Usage [\#](https://docs.nestjs.com/techniques/versioning\#usage)

Versioning allows you to version controllers, individual routes, and also provides a way for certain resources to opt-out of versioning. The usage of versioning is the same regardless of the Versioning Type your application uses.

> **Notice** If versioning is enabled for the application but the controller or route does not specify the version, any requests to that controller/route will be returned a `404` response status. Similarly, if a request is received containing a version that does not have a corresponding controller or route, it will also be returned a `404` response status.

#### Controller versions [\#](https://docs.nestjs.com/techniques/versioning\#controller-versions)

A version can be applied to a controller, setting the version for all routes within the controller.

To add a version to a controller do the following:

content\_copy cats.controller.ts

JS  TS

```typescript

@Controller({
  version: '1',
})
export class CatsControllerV1 {
  @Get('cats')
  findAll(): string {
    return 'This action returns all cats for version 1';
  }
}

```

```typescript

@Controller({
  version: '1',
})
export class CatsControllerV1 {
  @Get('cats')
  findAll() {
    return 'This action returns all cats for version 1';
  }
}

```

#### Route versions [\#](https://docs.nestjs.com/techniques/versioning\#route-versions)

A version can be applied to an individual route. This version will override any other version that would effect the route, such as the Controller Version.

To add a version to an individual route do the following:

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, Version } from '@nestjs/common';

@Controller()
export class CatsController {
  @Version('1')
  @Get('cats')
  findAllV1(): string {
    return 'This action returns all cats for version 1';
  }

  @Version('2')
  @Get('cats')
  findAllV2(): string {
    return 'This action returns all cats for version 2';
  }
}

```

```typescript

import { Controller, Get, Version } from '@nestjs/common';

@Controller()
export class CatsController {
  @Version('1')
  @Get('cats')
  findAllV1() {
    return 'This action returns all cats for version 1';
  }

  @Version('2')
  @Get('cats')
  findAllV2() {
    return 'This action returns all cats for version 2';
  }
}

```

#### Multiple versions [\#](https://docs.nestjs.com/techniques/versioning\#multiple-versions)

Multiple versions can be applied to a controller or route. To use multiple versions, you would set the version to be an Array.

To add multiple versions do the following:

content\_copy cats.controller.ts

JS  TS

```typescript

@Controller({
  version: ['1', '2'],
})
export class CatsController {
  @Get('cats')
  findAll(): string {
    return 'This action returns all cats for version 1 or 2';
  }
}

```

```typescript

@Controller({
  version: ['1', '2'],
})
export class CatsController {
  @Get('cats')
  findAll() {
    return 'This action returns all cats for version 1 or 2';
  }
}

```

#### Version "Neutral" [\#](https://docs.nestjs.com/techniques/versioning\#version-neutral)

Some controllers or routes may not care about the version and would have the same functionality regardless of the version. To accommodate this, the version can be set to `VERSION_NEUTRAL` symbol.

An incoming request will be mapped to a `VERSION_NEUTRAL` controller or route regardless of the version sent in the request in addition to if the request does not contain a version at all.

> **Notice** For URI Versioning, a `VERSION_NEUTRAL` resource would not have the version present in the URI.

To add a version neutral controller or route do the following:

content\_copy cats.controller.ts

JS  TS

```typescript

import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';

@Controller({
  version: VERSION_NEUTRAL,
})
export class CatsController {
  @Get('cats')
  findAll(): string {
    return 'This action returns all cats regardless of version';
  }
}

```

```typescript

import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';

@Controller({
  version: VERSION_NEUTRAL,
})
export class CatsController {
  @Get('cats')
  findAll() {
    return 'This action returns all cats regardless of version';
  }
}

```

#### Global default version [\#](https://docs.nestjs.com/techniques/versioning\#global-default-version)

If you do not want to provide a version for each controller/or individual routes, or if you want to have a specific version set as the default version for every controller/route that don't have the version specified, you could set the `defaultVersion` as follows:

content\_copy main.ts

JS  TS

```typescript

app.enableVersioning({
  // ...
  defaultVersion: '1'
  // or
  defaultVersion: ['1', '2']
  // or
  defaultVersion: VERSION_NEUTRAL
});

```

#### Middleware versioning [\#](https://docs.nestjs.com/techniques/versioning\#middleware-versioning)

[Middlewares](https://docs.nestjs.com/middleware) can also use versioning metadata to configure the middleware for a specific route's version. To do so, provide the version number as one of the parameters for the `MiddlewareConsumer.forRoutes()` method:

content\_copy app.module.ts

JS  TS

```typescript

import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';
import { CatsController } from './cats/cats.controller';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes({ path: 'cats', method: RequestMethod.GET, version: '2' });
  }
}

```

With the code above, the `LoggerMiddleware` will only be applied to the version '2' of `/cats` endpoint.

> **Notice** Middlewares work with any versioning type described in the this section: `URI`, `Header`, `Media Type` or `Custom`.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Security Overview
- [Security](https://docs.nestjs.com/openapi/security#security)
- [Basic authentication](https://docs.nestjs.com/openapi/security#basic-authentication)
- [Bearer authentication](https://docs.nestjs.com/openapi/security#bearer-authentication)
- [OAuth2 authentication](https://docs.nestjs.com/openapi/security#oauth2-authentication)
- [Cookie authentication](https://docs.nestjs.com/openapi/security#cookie-authentication)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/security.md "Suggest Edits")

### Security

To define which security mechanisms should be used for a specific operation, use the `@ApiSecurity()` decorator.

content\_copy

```typescript

@ApiSecurity('basic')
@Controller('cats')
export class CatsController {}

```

Before you run your application, remember to add the security definition to your base document using `DocumentBuilder`:

content\_copy

```typescript

const options = new DocumentBuilder().addSecurity('basic', {
  type: 'http',
  scheme: 'basic',
});

```

Some of the most popular authentication techniques are built-in (e.g., `basic` and `bearer`) and therefore you don't have to define security mechanisms manually as shown above.

#### Basic authentication [\#](https://docs.nestjs.com/openapi/security\#basic-authentication)

To enable basic authentication, use `@ApiBasicAuth()`.

content\_copy

```typescript

@ApiBasicAuth()
@Controller('cats')
export class CatsController {}

```

Before you run your application, remember to add the security definition to your base document using `DocumentBuilder`:

content\_copy

```typescript

const options = new DocumentBuilder().addBasicAuth();

```

#### Bearer authentication [\#](https://docs.nestjs.com/openapi/security\#bearer-authentication)

To enable bearer authentication, use `@ApiBearerAuth()`.

content\_copy

```typescript

@ApiBearerAuth()
@Controller('cats')
export class CatsController {}

```

Before you run your application, remember to add the security definition to your base document using `DocumentBuilder`:

content\_copy

```typescript

const options = new DocumentBuilder().addBearerAuth();

```

#### OAuth2 authentication [\#](https://docs.nestjs.com/openapi/security\#oauth2-authentication)

To enable OAuth2, use `@ApiOAuth2()`.

content\_copy

```typescript

@ApiOAuth2(['pets:write'])
@Controller('cats')
export class CatsController {}

```

Before you run your application, remember to add the security definition to your base document using `DocumentBuilder`:

content\_copy

```typescript

const options = new DocumentBuilder().addOAuth2();

```

#### Cookie authentication [\#](https://docs.nestjs.com/openapi/security\#cookie-authentication)

To enable cookie authentication, use `@ApiCookieAuth()`.

content\_copy

```typescript

@ApiCookieAuth()
@Controller('cats')
export class CatsController {}

```

Before you run your application, remember to add the security definition to your base document using `DocumentBuilder`:

content\_copy

```typescript

const options = new DocumentBuilder().addCookieAuth('optional-session-id');

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS MongoDB Integration
- [Mongo](https://docs.nestjs.com/techniques/mongodb#mongo)
- [Model injection](https://docs.nestjs.com/techniques/mongodb#model-injection)
- [Connection](https://docs.nestjs.com/techniques/mongodb#connection)
- [Sessions](https://docs.nestjs.com/techniques/mongodb#sessions)
- [Multiple databases](https://docs.nestjs.com/techniques/mongodb#multiple-databases)
- [Hooks (middleware)](https://docs.nestjs.com/techniques/mongodb#hooks-middleware)
- [Plugins](https://docs.nestjs.com/techniques/mongodb#plugins)
- [Discriminators](https://docs.nestjs.com/techniques/mongodb#discriminators)
- [Testing](https://docs.nestjs.com/techniques/mongodb#testing)
- [Async configuration](https://docs.nestjs.com/techniques/mongodb#async-configuration)
- [Connection events](https://docs.nestjs.com/techniques/mongodb#connection-events)
- [Subdocuments](https://docs.nestjs.com/techniques/mongodb#subdocuments)
- [Virtuals](https://docs.nestjs.com/techniques/mongodb#virtuals)
- [Example](https://docs.nestjs.com/techniques/mongodb#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/mongo.md "Suggest Edits")

### Mongo

Nest supports two methods for integrating with the [MongoDB](https://www.mongodb.com/) database. You can either use the built-in [TypeORM](https://github.com/typeorm/typeorm) module described [here](https://docs.nestjs.com/techniques/database), which has a connector for MongoDB, or use [Mongoose](https://mongoosejs.com/), the most popular MongoDB object modeling tool. In this chapter we'll describe the latter, using the dedicated `@nestjs/mongoose` package.

Start by installing the [required dependencies](https://github.com/Automattic/mongoose):

```bash

$ npm i @nestjs/mongoose mongoose

```

Once the installation process is complete, we can import the `MongooseModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [MongooseModule.forRoot('mongodb://localhost/nest')],
})
export class AppModule {}

```

The `forRoot()` method accepts the same configuration object as `mongoose.connect()` from the Mongoose package, as described [here](https://mongoosejs.com/docs/connections.html).

#### Model injection [\#](https://docs.nestjs.com/techniques/mongodb\#model-injection)

With Mongoose, everything is derived from a [Schema](http://mongoosejs.com/docs/guide.html). Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. Schemas are used to define [Models](https://mongoosejs.com/docs/models.html). Models are responsible for creating and reading documents from the underlying MongoDB database.

Schemas can be created with NestJS decorators, or with Mongoose itself manually. Using decorators to create schemas greatly reduces boilerplate and improves overall code readability.

Let's define the `CatSchema`:

content\_copy schemas/cat.schema.ts

JS  TS

```typescript

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';

export type CatDocument = HydratedDocument<Cat>;

@Schema()
export class Cat {
  @Prop()
  name: string;

  @Prop()
  age: number;

  @Prop()
  breed: string;
}

export const CatSchema = SchemaFactory.createForClass(Cat);

```

> **Hint** Note you can also generate a raw schema definition using the `DefinitionsFactory` class (from the `nestjs/mongoose`). This allows you to manually modify the schema definition generated based on the metadata you provided. This is useful for certain edge-cases where it may be hard to represent everything with decorators.

The `@Schema()` decorator marks a class as a schema definition. It maps our `Cat` class to a MongoDB collection of the same name, but with an additional “s” at the end - so the final mongo collection name will be `cats`. This decorator accepts a single optional argument which is a schema options object. Think of it as the object you would normally pass as a second argument of the `mongoose.Schema` class' constructor (e.g., `new mongoose.Schema(_, options)`)). To learn more about available schema options, see [this](https://mongoosejs.com/docs/guide.html#options) chapter.

The `@Prop()` decorator defines a property in the document. For example, in the schema definition above, we defined three properties: `name`, `age`, and `breed`. The [schema types](https://mongoosejs.com/docs/schematypes.html) for these properties are automatically inferred thanks to TypeScript metadata (and reflection) capabilities. However, in more complex scenarios in which types cannot be implicitly reflected (for example, arrays or nested object structures), types must be indicated explicitly, as follows:

content\_copy

```typescript

@Prop([String])
tags: string[];

```

Alternatively, the `@Prop()` decorator accepts an options object argument ( [read more](https://mongoosejs.com/docs/schematypes.html#schematype-options) about the available options). With this, you can indicate whether a property is required or not, specify a default value, or mark it as immutable. For example:

content\_copy

```typescript

@Prop({ required: true })
name: string;

```

In case you want to specify relation to another model, later for populating, you can use `@Prop()` decorator as well. For example, if `Cat` has `Owner` which is stored in a different collection called `owners`, the property should have type and ref. For example:

content\_copy

```typescript

import * as mongoose from 'mongoose';
import { Owner } from '../owners/schemas/owner.schema';

// inside the class definition
@Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' })
owner: Owner;

```

In case there are multiple owners, your property configuration should look as follows:

content\_copy

```typescript

@Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' }] })
owners: Owner[];

```

If you don’t intend to always populate a reference to another collection, consider using `mongoose.Types.ObjectId` as the type instead:

content\_copy

```typescript

@Prop({ type: { type: mongoose.Schema.Types.ObjectId, ref: 'Owner' } })
// This ensures the field is not confused with a populated reference
owner: mongoose.Types.ObjectId;

```

Then, when you need to selectively populate it later, you can use a repository function that specifies the correct type:

content\_copy

```typescript

import { Owner } from './schemas/owner.schema';

// e.g. inside a service or repository
async findAllPopulated() {
  return this.catModel.find().populate<{ owner: Owner }>("owner");
}

```

> **Hint** If there is no foreign document to populate, the type could be `Owner | null`, depending on your [Mongoose configuration](https://mongoosejs.com/docs/populate.html#doc-not-found). Alternatively, it might throw an error, in which case the type will be `Owner`.

Finally, the **raw** schema definition can also be passed to the decorator. This is useful when, for example, a property represents a nested object which is not defined as a class. For this, use the `raw()` function from the `@nestjs/mongoose` package, as follows:

content\_copy

```typescript

@Prop(raw({
  firstName: { type: String },
  lastName: { type: String }
}))
details: Record<string, any>;

```

Alternatively, if you prefer **not using decorators**, you can define a schema manually. For example:

content\_copy

```typescript

export const CatSchema = new mongoose.Schema({
  name: String,
  age: Number,
  breed: String,
});

```

The `cat.schema` file resides in a folder in the `cats` directory, where we also define the `CatsModule`. While you can store schema files wherever you prefer, we recommend storing them near their related **domain** objects, in the appropriate module directory.

Let's look at the `CatsModule`:

content\_copy cats.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { Cat, CatSchema } from './schemas/cat.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }])],
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}

```

The `MongooseModule` provides the `forFeature()` method to configure the module, including defining which models should be registered in the current scope. If you also want to use the models in another module, add MongooseModule to the `exports` section of `CatsModule` and import `CatsModule` in the other module.

Once you've registered the schema, you can inject a `Cat` model into the `CatsService` using the `@InjectModel()` decorator:

content\_copy cats.service.ts

JS  TS

```typescript

import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Cat } from './schemas/cat.schema';
import { CreateCatDto } from './dto/create-cat.dto';

@Injectable()
export class CatsService {
  constructor(@InjectModel(Cat.name) private catModel: Model<Cat>) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const createdCat = new this.catModel(createCatDto);
    return createdCat.save();
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }
}

```

```typescript

import { Model } from 'mongoose';
import { Injectable, Dependencies } from '@nestjs/common';
import { getModelToken } from '@nestjs/mongoose';
import { Cat } from './schemas/cat.schema';

@Injectable()
@Dependencies(getModelToken(Cat.name))
export class CatsService {
  constructor(catModel) {
    this.catModel = catModel;
  }

  async create(createCatDto) {
    const createdCat = new this.catModel(createCatDto);
    return createdCat.save();
  }

  async findAll() {
    return this.catModel.find().exec();
  }
}

```

#### Connection [\#](https://docs.nestjs.com/techniques/mongodb\#connection)

At times you may need to access the native [Mongoose Connection](https://mongoosejs.com/docs/api.html#Connection) object. For example, you may want to make native API calls on the connection object. You can inject the Mongoose Connection by using the `@InjectConnection()` decorator as follows:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';

@Injectable()
export class CatsService {
  constructor(@InjectConnection() private connection: Connection) {}
}

```

#### Sessions [\#](https://docs.nestjs.com/techniques/mongodb\#sessions)

To start a session with Mongoose, it's recommended to inject the database connection using `@InjectConnection` rather than calling `mongoose.startSession()` directly. This approach allows better integration with the NestJS dependency injection system, ensuring proper connection management.

Here's an example of how to start a session:

content\_copy

```typescript

import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';

@Injectable()
export class CatsService {
  constructor(@InjectConnection() private readonly connection: Connection) {}

  async startTransaction() {
    const session = await this.connection.startSession();
    session.startTransaction();
    // Your transaction logic here
  }
}

```

In this example, `@InjectConnection()` is used to inject the Mongoose connection into the service. Once the connection is injected, you can use `connection.startSession()` to begin a new session. This session can be used to manage database transactions, ensuring atomic operations across multiple queries. After starting the session, remember to commit or abort the transaction based on your logic.

#### Multiple databases [\#](https://docs.nestjs.com/techniques/mongodb\#multiple-databases)

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes **mandatory**.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [\
    MongooseModule.forRoot('mongodb://localhost/test', {\
      connectionName: 'cats',\
    }),\
    MongooseModule.forRoot('mongodb://localhost/users', {\
      connectionName: 'users',\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.

With this setup, you have to tell the `MongooseModule.forFeature()` function which connection should be used.

content\_copy

```typescript

@Module({
  imports: [\
    MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }], 'cats'),\
  ],
})
export class CatsModule {}

```

You can also inject the `Connection` for a given connection:

content\_copy

```typescript

import { Injectable } from '@nestjs/common';
import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';

@Injectable()
export class CatsService {
  constructor(@InjectConnection('cats') private connection: Connection) {}
}

```

To inject a given `Connection` to a custom provider (for example, factory provider), use the `getConnectionToken()` function passing the name of the connection as an argument.

content\_copy

```typescript

{
  provide: CatsService,
  useFactory: (catsConnection: Connection) => {
    return new CatsService(catsConnection);
  },
  inject: [getConnectionToken('cats')],
}

```

If you are just looking to inject the model from a named database, you can use the connection name as a second parameter to the `@InjectModel()` decorator.

content\_copy cats.service.ts

JS  TS

```typescript

@Injectable()
export class CatsService {
  constructor(@InjectModel(Cat.name, 'cats') private catModel: Model<Cat>) {}
}

```

```typescript

@Injectable()
@Dependencies(getModelToken(Cat.name, 'cats'))
export class CatsService {
  constructor(catModel) {
    this.catModel = catModel;
  }
}

```

#### Hooks (middleware) [\#](https://docs.nestjs.com/techniques/mongodb\#hooks-middleware)

Middleware (also called pre and post hooks) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing plugins ( [source](https://mongoosejs.com/docs/middleware.html)). Calling `pre()` or `post()` after compiling a model does not work in Mongoose. To register a hook **before** model registration, use the `forFeatureAsync()` method of the `MongooseModule` along with a factory provider (i.e., `useFactory`). With this technique, you can access a schema object, then use the `pre()` or `post()` method to register a hook on that schema. See example below:

content\_copy

```typescript

@Module({
  imports: [\
    MongooseModule.forFeatureAsync([\
      {\
        name: Cat.name,\
        useFactory: () => {\
          const schema = CatsSchema;\
          schema.pre('save', function () {\
            console.log('Hello from pre save');\
          });\
          return schema;\
        },\
      },\
    ]),\
  ],
})
export class AppModule {}

```

Like other [factory providers](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory), our factory function can be `async` and can inject dependencies through `inject`.

content\_copy

```typescript

@Module({
  imports: [\
    MongooseModule.forFeatureAsync([\
      {\
        name: Cat.name,\
        imports: [ConfigModule],\
        useFactory: (configService: ConfigService) => {\
          const schema = CatsSchema;\
          schema.pre('save', function() {\
            console.log(\
              `${configService.get('APP_NAME')}: Hello from pre save`,\
            ),\
          });\
          return schema;\
        },\
        inject: [ConfigService],\
      },\
    ]),\
  ],
})
export class AppModule {}

```

#### Plugins [\#](https://docs.nestjs.com/techniques/mongodb\#plugins)

To register a [plugin](https://mongoosejs.com/docs/plugins.html) for a given schema, use the `forFeatureAsync()` method.

content\_copy

```typescript

@Module({
  imports: [\
    MongooseModule.forFeatureAsync([\
      {\
        name: Cat.name,\
        useFactory: () => {\
          const schema = CatsSchema;\
          schema.plugin(require('mongoose-autopopulate'));\
          return schema;\
        },\
      },\
    ]),\
  ],
})
export class AppModule {}

```

To register a plugin for all schemas at once, call the `.plugin()` method of the `Connection` object. You should access the connection before models are created; to do this, use the `connectionFactory`:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [\
    MongooseModule.forRoot('mongodb://localhost/test', {\
      connectionFactory: (connection) => {\
        connection.plugin(require('mongoose-autopopulate'));\
        return connection;\
      }\
    }),\
  ],
})
export class AppModule {}

```

#### Discriminators [\#](https://docs.nestjs.com/techniques/mongodb\#discriminators)

[Discriminators](https://mongoosejs.com/docs/discriminators.html) are a schema inheritance mechanism. They enable you to have multiple models with overlapping schemas on top of the same underlying MongoDB collection.

Suppose you wanted to track different types of events in a single collection. Every event will have a timestamp.

content\_copy event.schema.ts

JS  TS

```typescript

@Schema({ discriminatorKey: 'kind' })
export class Event {
  @Prop({
    type: String,
    required: true,
    enum: [ClickedLinkEvent.name, SignUpEvent.name],
  })
  kind: string;

  @Prop({ type: Date, required: true })
  time: Date;
}

export const EventSchema = SchemaFactory.createForClass(Event);

```

> **Hint** The way mongoose tells the difference between the different discriminator models is by the "discriminator key", which is `__t` by default. Mongoose adds a String path called `__t` to your schemas that it uses to track which discriminator this document is an instance of.
> You may also use the `discriminatorKey` option to define the path for discrimination.

`SignedUpEvent` and `ClickedLinkEvent` instances will be stored in the same collection as generic events.

Now, let's define the `ClickedLinkEvent` class, as follows:

content\_copy click-link-event.schema.ts

JS  TS

```typescript

@Schema()
export class ClickedLinkEvent {
  kind: string;
  time: Date;

  @Prop({ type: String, required: true })
  url: string;
}

export const ClickedLinkEventSchema = SchemaFactory.createForClass(ClickedLinkEvent);

```

And `SignUpEvent` class:

content\_copy sign-up-event.schema.ts

JS  TS

```typescript

@Schema()
export class SignUpEvent {
  kind: string;
  time: Date;

  @Prop({ type: String, required: true })
  user: string;
}

export const SignUpEventSchema = SchemaFactory.createForClass(SignUpEvent);

```

With this in place, use the `discriminators` option to register a discriminator for a given schema. It works on both `MongooseModule.forFeature` and `MongooseModule.forFeatureAsync`:

content\_copy event.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [\
    MongooseModule.forFeature([\
      {\
        name: Event.name,\
        schema: EventSchema,\
        discriminators: [\
          { name: ClickedLinkEvent.name, schema: ClickedLinkEventSchema },\
          { name: SignUpEvent.name, schema: SignUpEventSchema },\
        ],\
      },\
    ]),\
  ]
})
export class EventsModule {}

```

#### Testing [\#](https://docs.nestjs.com/techniques/mongodb\#testing)

When unit testing an application, we usually want to avoid any database connection, making our test suites simpler to set up and faster to execute. But our classes might depend on models that are pulled from the connection instance. How do we resolve these classes? The solution is to create mock models.

To make this easier, the `@nestjs/mongoose` package exposes a `getModelToken()` function that returns a prepared [injection token](https://docs.nestjs.com/fundamentals/custom-providers#di-fundamentals) based on a token name. Using this token, you can easily provide a mock implementation using any of the standard [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) techniques, including `useClass`, `useValue`, and `useFactory`. For example:

content\_copy

```typescript

@Module({
  providers: [\
    CatsService,\
    {\
      provide: getModelToken(Cat.name),\
      useValue: catModel,\
    },\
  ],
})
export class CatsModule {}

```

In this example, a hardcoded `catModel` (object instance) will be provided whenever any consumer injects a `Model<Cat>` using an `@InjectModel()` decorator.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Async configuration [\#](https://docs.nestjs.com/techniques/mongodb\#async-configuration)

When you need to pass module options asynchronously instead of statically, use the `forRootAsync()` method. As with most dynamic modules, Nest provides several techniques to deal with async configuration.

One technique is to use a factory function:

content\_copy

```typescript

MongooseModule.forRootAsync({
  useFactory: () => ({
    uri: 'mongodb://localhost/nest',
  }),
});

```

Like other [factory providers](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory), our factory function can be `async` and can inject dependencies through `inject`.

content\_copy

```typescript

MongooseModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) => ({
    uri: configService.get<string>('MONGODB_URI'),
  }),
  inject: [ConfigService],
});

```

Alternatively, you can configure the `MongooseModule` using a class instead of a factory, as shown below:

content\_copy

```typescript

MongooseModule.forRootAsync({
  useClass: MongooseConfigService,
});

```

The construction above instantiates `MongooseConfigService` inside `MongooseModule`, using it to create the required options object. Note that in this example, the `MongooseConfigService` has to implement the `MongooseOptionsFactory` interface, as shown below. The `MongooseModule` will call the `createMongooseOptions()` method on the instantiated object of the supplied class.

content\_copy

```typescript

@Injectable()
export class MongooseConfigService implements MongooseOptionsFactory {
  createMongooseOptions(): MongooseModuleOptions {
    return {
      uri: 'mongodb://localhost/nest',
    };
  }
}

```

If you want to reuse an existing options provider instead of creating a private copy inside the `MongooseModule`, use the `useExisting` syntax.

content\_copy

```typescript

MongooseModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

#### Connection events [\#](https://docs.nestjs.com/techniques/mongodb\#connection-events)

You can listen to Mongoose [connection events](https://mongoosejs.com/docs/connections.html#connection-events) by using the `onConnectionCreate` configuration option. This allows you to implement custom logic whenever a connection is established. For instance, you can register event listeners for the `connected`, `open`, `disconnected`, `reconnected`, and `disconnecting` events, as demonstrated below:

content\_copy

```typescript

MongooseModule.forRoot('mongodb://localhost/test', {
  onConnectionCreate: (connection: Connection) => {
    connection.on('connected', () => console.log('connected'));
    connection.on('open', () => console.log('open'));
    connection.on('disconnected', () => console.log('disconnected'));
    connection.on('reconnected', () => console.log('reconnected'));
    connection.on('disconnecting', () => console.log('disconnecting'));

    return connection;
  },
}),

```

In this code snippet, we are establishing a connection to a MongoDB database at `mongodb://localhost/test`. The `onConnectionCreate` option enables you to set up specific event listeners for monitoring the connection's status:

- `connected`: Triggered when the connection is successfully established.
- `open`: Fires when the connection is fully opened and ready for operations.
- `disconnected`: Called when the connection is lost.
- `reconnected`: Invoked when the connection is re-established after being disconnected.
- `disconnecting`: Occurs when the connection is in the process of closing.

You can also incorporate the `onConnectionCreate` property into async configurations created with `MongooseModule.forRootAsync()`:

content\_copy

```typescript

MongooseModule.forRootAsync({
  useFactory: () => ({
    uri: 'mongodb://localhost/test',
    onConnectionCreate: (connection: Connection) => {
      // Register event listeners here
      return connection;
    },
  }),
}),

```

This provides a flexible way to manage connection events, enabling you to handle changes in connection status effectively.

#### Subdocuments [\#](https://docs.nestjs.com/techniques/mongodb\#subdocuments)

To nest subdocuments within a parent document, you can define your schemas as follows:

content\_copy name.schema.ts

JS  TS

```typescript

@Schema()
export class Name {
  @Prop()
  firstName: string;

  @Prop()
  lastName: string;
}

export const NameSchema = SchemaFactory.createForClass(Name);

```

And then reference the subdocument in the parent schema:

content\_copy person.schema.ts

JS  TS

```typescript

@Schema()
export class Person {
  @Prop(NameSchema)
  name: Name;
}

export const PersonSchema = SchemaFactory.createForClass(Person);

export type PersonDocumentOverride = {
  name: Types.Subdocument<Types.ObjectId> & Name;
};

export type PersonDocument = HydratedDocument<Person, PersonDocumentOverride>;

```

If you want to include multiple subdocuments, you can use an array of subdocuments. It's important to override the type of the property accordingly:

content\_copy name.schema.ts

JS  TS

```typescript

@Schema()
export class Person {
  @Prop([NameSchema])
  name: Name[];
}

export const PersonSchema = SchemaFactory.createForClass(Person);

export type PersonDocumentOverride = {
  name: Types.DocumentArray<Name>;
};

export type PersonDocument = HydratedDocument<Person, PersonDocumentOverride>;

```

#### Virtuals [\#](https://docs.nestjs.com/techniques/mongodb\#virtuals)

In Mongoose, a **virtual** is a property that exists on a document but is not persisted to MongoDB. It is not stored in the database but is computed dynamically whenever it's accessed. Virtuals are typically used for derived or computed values, like combining fields (e.g., creating a `fullName` property by concatenating `firstName` and `lastName`), or for creating properties that rely on existing data in the document.

content\_copy

```ts

class Person {
  @Prop()
  firstName: string;

  @Prop()
  lastName: string;

  @Virtual({
    get: function (this: Person) {
      return `${this.firstName} ${this.lastName}`;
    },
  })
  fullName: string;
}

```

> **Hint** The `@Virtual()` decorator is imported from the `@nestjs/mongoose` package.

In this example, the `fullName` virtual is derived from `firstName` and `lastName`. Even though it behaves like a normal property when accessed, it’s never saved to the MongoDB document.:

#### Example [\#](https://docs.nestjs.com/techniques/mongodb\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/06-mongoose).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Serialization Guide
- [Serialization](https://docs.nestjs.com/techniques/serialization#serialization)
- [Overview](https://docs.nestjs.com/techniques/serialization#overview)
- [Exclude properties](https://docs.nestjs.com/techniques/serialization#exclude-properties)
- [Expose properties](https://docs.nestjs.com/techniques/serialization#expose-properties)
- [Transform](https://docs.nestjs.com/techniques/serialization#transform)
- [Pass options](https://docs.nestjs.com/techniques/serialization#pass-options)
- [Transform plain objects](https://docs.nestjs.com/techniques/serialization#transform-plain-objects)
- [Example](https://docs.nestjs.com/techniques/serialization#example)
- [WebSockets and Microservices](https://docs.nestjs.com/techniques/serialization#websockets-and-microservices)
- [Learn more](https://docs.nestjs.com/techniques/serialization#learn-more)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/serialization.md "Suggest Edits")

### Serialization

Serialization is a process that happens before objects are returned in a network response. This is an appropriate place to provide rules for transforming and sanitizing the data to be returned to the client. For example, sensitive data like passwords should always be excluded from the response. Or, certain properties might require additional transformation, such as sending only a subset of properties of an entity. Performing these transformations manually can be tedious and error prone, and can leave you uncertain that all cases have been covered.

#### Overview [\#](https://docs.nestjs.com/techniques/serialization\#overview)

Nest provides a built-in capability to help ensure that these operations can be performed in a straightforward way. The `ClassSerializerInterceptor` interceptor uses the powerful [class-transformer](https://github.com/typestack/class-transformer) package to provide a declarative and extensible way of transforming objects. The basic operation it performs is to take the value returned by a method handler and apply the `instanceToPlain()` function from [class-transformer](https://github.com/typestack/class-transformer). In doing so, it can apply rules expressed by `class-transformer` decorators on an entity/DTO class, as described below.

> **Hint** The serialization does not apply to [StreamableFile](https://docs.nestjs.com/techniques/streaming-files#streamable-file-class) responses.

#### Exclude properties [\#](https://docs.nestjs.com/techniques/serialization\#exclude-properties)

Let's assume that we want to automatically exclude a `password` property from a user entity. We annotate the entity as follows:

content\_copy

```typescript

import { Exclude } from 'class-transformer';

export class UserEntity {
  id: number;
  firstName: string;
  lastName: string;

  @Exclude()
  password: string;

  constructor(partial: Partial<UserEntity>) {
    Object.assign(this, partial);
  }
}

```

Now consider a controller with a method handler that returns an instance of this class.

content\_copy

```typescript

@UseInterceptors(ClassSerializerInterceptor)
@Get()
findOne(): UserEntity {
  return new UserEntity({
    id: 1,
    firstName: 'John',
    lastName: 'Doe',
    password: 'password',
  });
}

```

> **Warning** Note that we must return an instance of the class. If you return a plain JavaScript object, for example, `{ user: new UserEntity() }`, the object won't be properly serialized.

> **Hint** The `ClassSerializerInterceptor` is imported from `@nestjs/common`.

When this endpoint is requested, the client receives the following response:

```json

{
  "id": 1,
  "firstName": "John",
  "lastName": "Doe"
}

```

Note that the interceptor can be applied application-wide (as covered [here](https://docs.nestjs.com/interceptors#binding-interceptors)). The combination of the interceptor and the entity class declaration ensures that **any** method that returns a `UserEntity` will be sure to remove the `password` property. This gives you a measure of centralized enforcement of this business rule.

#### Expose properties [\#](https://docs.nestjs.com/techniques/serialization\#expose-properties)

You can use the `@Expose()` decorator to provide alias names for properties, or to execute a function to calculate a property value (analogous to **getter** functions), as shown below.

content\_copy

```typescript

@Expose()
get fullName(): string {
  return `${this.firstName} ${this.lastName}`;
}

```

#### Transform [\#](https://docs.nestjs.com/techniques/serialization\#transform)

You can perform additional data transformation using the `@Transform()` decorator. For example, the following construct returns the name property of the `RoleEntity` instead of returning the whole object.

content\_copy

```typescript

@Transform(({ value }) => value.name)
role: RoleEntity;

```

#### Pass options [\#](https://docs.nestjs.com/techniques/serialization\#pass-options)

You may want to modify the default behavior of the transformation functions. To override default settings, pass them in an `options` object with the `@SerializeOptions()` decorator.

content\_copy

```typescript

@SerializeOptions({
  excludePrefixes: ['_'],
})
@Get()
findOne(): UserEntity {
  return new UserEntity();
}

```

> **Hint** The `@SerializeOptions()` decorator is imported from `@nestjs/common`.

Options passed via `@SerializeOptions()` are passed as the second argument of the underlying `instanceToPlain()` function. In this example, we are automatically excluding all properties that begin with the `_` prefix.

#### Transform plain objects [\#](https://docs.nestjs.com/techniques/serialization\#transform-plain-objects)

You can enforce transformations at the controller level by using the `@SerializeOptions` decorator. This ensures that all responses are transformed into instances of the specified class, applying any decorators from class-validator or class-transformer, even when plain objects are returned. This approach leads to cleaner code without the need to repeatedly instantiate the class or call `plainToInstance`.

In the example below, despite returning plain JavaScript objects in both conditional branches, they will be automatically converted into `UserEntity` instances, with the relevant decorators applied:

content\_copy

```typescript

@UseInterceptors(ClassSerializerInterceptor)
@SerializeOptions({ type: UserEntity })
@Get()
findOne(@Query() { id }: { id: number }): UserEntity {
  if (id === 1) {
    return {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      password: 'password',
    };
  }

  return {
    id: 2,
    firstName: 'Kamil',
    lastName: 'Mysliwiec',
    password: 'password2',
  };
}

```

> **Hint** By specifying the expected return type for the controller, you can leverage TypeScript's type-checking capabilities to ensure that the returned plain object adheres to the shape of the DTO or entity. The `plainToInstance` function doesn't provide this level of type hinting, which can lead to potential bugs if the plain object doesn't match the expected DTO or entity structure.

#### Example [\#](https://docs.nestjs.com/techniques/serialization\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/21-serializer).

#### WebSockets and Microservices [\#](https://docs.nestjs.com/techniques/serialization\#websockets-and-microservices)

While this chapter shows examples using HTTP style applications (e.g., Express or Fastify), the `ClassSerializerInterceptor` works the same for WebSockets and Microservices, regardless of the transport method that is used.

#### Learn more [\#](https://docs.nestjs.com/techniques/serialization\#learn-more)

Read more about available decorators and options as provided by the `class-transformer` package [here](https://github.com/typestack/class-transformer).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Cookies Guide
- [Cookies](https://docs.nestjs.com/techniques/cookies#cookies)
- [Use with Express (default)](https://docs.nestjs.com/techniques/cookies#use-with-express-default)
- [Use with Fastify](https://docs.nestjs.com/techniques/cookies#use-with-fastify)
- [Creating a custom decorator (cross-platform)](https://docs.nestjs.com/techniques/cookies#creating-a-custom-decorator-cross-platform)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/cookies.md "Suggest Edits")

### Cookies

An **HTTP cookie** is a small piece of data stored by the user's browser. Cookies were designed to be a reliable mechanism for websites to remember stateful information. When the user visits the website again, the cookie is automatically sent with the request.

#### Use with Express (default) [\#](https://docs.nestjs.com/techniques/cookies\#use-with-express-default)

First install the [required package](https://github.com/expressjs/cookie-parser) (and its types for TypeScript users):

```shell

$ npm i cookie-parser
$ npm i -D @types/cookie-parser

```

Once the installation is complete, apply the `cookie-parser` middleware as global middleware (for example, in your `main.ts` file).

content\_copy

```typescript

import * as cookieParser from 'cookie-parser';
// somewhere in your initialization file
app.use(cookieParser());

```

You can pass several options to the `cookieParser` middleware:

- `secret` a string or array used for signing cookies. This is optional and if not specified, will not parse signed cookies. If a string is provided, this is used as the secret. If an array is provided, an attempt will be made to unsign the cookie with each secret in order.
- `options` an object that is passed to `cookie.parse` as the second option. See [cookie](https://www.npmjs.org/package/cookie) for more information.

The middleware will parse the `Cookie` header on the request and expose the cookie data as the property `req.cookies` and, if a secret was provided, as the property `req.signedCookies`. These properties are name value pairs of the cookie name to cookie value.

When a secret is provided, this module will unsign and validate any signed cookie values and move those name value pairs from `req.cookies` into `req.signedCookies`. A signed cookie is a cookie that has a value prefixed with `s:`. Signed cookies that fail signature validation will have the value `false` instead of the tampered value.

With this in place, you can now read cookies from within the route handlers, as follows:

content\_copy

```typescript

@Get()
findAll(@Req() request: Request) {
  console.log(request.cookies); // or "request.cookies['cookieKey']"
  // or console.log(request.signedCookies);
}

```

> **Hint** The `@Req()` decorator is imported from the `@nestjs/common`, while `Request` from the `express` package.

To attach a cookie to an outgoing response, use the `Response#cookie()` method:

content\_copy

```typescript

@Get()
findAll(@Res({ passthrough: true }) response: Response) {
  response.cookie('key', 'value')
}

```

> **Warning** If you want to leave the response handling logic to the framework, remember to set the `passthrough` option to `true`, as shown above. Read more [here](https://docs.nestjs.com/controllers#library-specific-approach).

> **Hint** The `@Res()` decorator is imported from the `@nestjs/common`, while `Response` from the `express` package.

#### Use with Fastify [\#](https://docs.nestjs.com/techniques/cookies\#use-with-fastify)

First install the required package:

```shell

$ npm i @fastify/cookie

```

Once the installation is complete, register the `@fastify/cookie` plugin:

content\_copy

```typescript

import fastifyCookie from '@fastify/cookie';

// somewhere in your initialization file
const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter());
await app.register(fastifyCookie, {
  secret: 'my-secret', // for cookies signature
});

```

With this in place, you can now read cookies from within the route handlers, as follows:

content\_copy

```typescript

@Get()
findAll(@Req() request: FastifyRequest) {
  console.log(request.cookies); // or "request.cookies['cookieKey']"
}

```

> **Hint** The `@Req()` decorator is imported from the `@nestjs/common`, while `FastifyRequest` from the `fastify` package.

To attach a cookie to an outgoing response, use the `FastifyReply#setCookie()` method:

content\_copy

```typescript

@Get()
findAll(@Res({ passthrough: true }) response: FastifyReply) {
  response.setCookie('key', 'value')
}

```

To read more about `FastifyReply#setCookie()` method, check out this [page](https://github.com/fastify/fastify-cookie#sending).

> **Warning** If you want to leave the response handling logic to the framework, remember to set the `passthrough` option to `true`, as shown above. Read more [here](https://docs.nestjs.com/controllers#library-specific-approach).

> **Hint** The `@Res()` decorator is imported from the `@nestjs/common`, while `FastifyReply` from the `fastify` package.

#### Creating a custom decorator (cross-platform) [\#](https://docs.nestjs.com/techniques/cookies\#creating-a-custom-decorator-cross-platform)

To provide a convenient, declarative way of accessing incoming cookies, we can create a [custom decorator](https://docs.nestjs.com/custom-decorators).

content\_copy

```typescript

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const Cookies = createParamDecorator((data: string, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest();
  return data ? request.cookies?.[data] : request.cookies;
});

```

The `@Cookies()` decorator will extract all cookies, or a named cookie from the `req.cookies` object and populate the decorated parameter with that value.

With this in place, we can now use the decorator in a route handler signature, as follows:

content\_copy

```typescript

@Get()
findAll(@Cookies('name') name: string) {}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## CSRF Protection Guide
- [CSRF Protection](https://docs.nestjs.com/security/csrf#csrf-protection)
- [Use with Express (default)](https://docs.nestjs.com/security/csrf#use-with-express-default)
- [Use with Fastify](https://docs.nestjs.com/security/csrf#use-with-fastify)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/csrf.md "Suggest Edits")

### CSRF Protection

Cross-site request forgery (CSRF or XSRF) is a type of attack where **unauthorized** commands are sent from a trusted user to a web application. To help prevent this, you can use the [csrf-csrf](https://github.com/Psifi-Solutions/csrf-csrf) package.

#### Use with Express (default) [\#](https://docs.nestjs.com/security/csrf\#use-with-express-default)

Start by installing the required package:

```bash

$ npm i csrf-csrf

```

> **Warning** As noted in the [csrf-csrf documentation](https://github.com/Psifi-Solutions/csrf-csrf?tab=readme-ov-file#getting-started), this middleware requires session middleware or `cookie-parser` to be initialized beforehand. Please refer to the documentation for further details.

Once the installation is complete, register the `csrf-csrf` middleware as global middleware.

content\_copy

```typescript

import { doubleCsrf } from 'csrf-csrf';
// ...
// somewhere in your initialization file
const {
  invalidCsrfTokenError, // This is provided purely for convenience if you plan on creating your own middleware.
  generateToken, // Use this in your routes to generate and provide a CSRF hash, along with a token cookie and token.
  validateRequest, // Also a convenience if you plan on making your own middleware.
  doubleCsrfProtection, // This is the default CSRF protection middleware.
} = doubleCsrf(doubleCsrfOptions);
app.use(doubleCsrfProtection);

```

#### Use with Fastify [\#](https://docs.nestjs.com/security/csrf\#use-with-fastify)

Start by installing the required package:

```bash

$ npm i --save @fastify/csrf-protection

```

Once the installation is complete, register the `@fastify/csrf-protection` plugin, as follows:

content\_copy

```typescript

import fastifyCsrf from '@fastify/csrf-protection';
// ...
// somewhere in your initialization file after registering some storage plugin
await app.register(fastifyCsrf);

```

> **Warning** As explained in the `@fastify/csrf-protection` docs [here](https://github.com/fastify/csrf-protection#usage), this plugin requires a storage plugin to be initialized first. Please, see that documentation for further instructions.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Serverless Guide
- [Serverless](https://docs.nestjs.com/faq/serverless#serverless)
- [Cold start](https://docs.nestjs.com/faq/serverless#cold-start)
- [Benchmarks](https://docs.nestjs.com/faq/serverless#benchmarks)
- [Runtime optimizations](https://docs.nestjs.com/faq/serverless#runtime-optimizations)
- [Example integration](https://docs.nestjs.com/faq/serverless#example-integration)
- [Using standalone application feature](https://docs.nestjs.com/faq/serverless#using-standalone-application-feature)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/serverless.md "Suggest Edits")

### Serverless

Serverless computing is a cloud computing execution model in which the cloud provider allocates machine resources on-demand, taking care of the servers on behalf of their customers. When an app is not in use, there are no computing resources allocated to the app. Pricing is based on the actual amount of resources consumed by an application ( [source](https://en.wikipedia.org/wiki/Serverless_computing)).

With a **serverless architecture**, you focus purely on the individual functions in your application code. Services such as AWS Lambda, Google Cloud Functions, and Microsoft Azure Functions take care of all the physical hardware, virtual machine operating system, and web server software management.

> **Hint** This chapter does not cover the pros and cons of serverless functions nor dives into the specifics of any cloud providers.

#### Cold start [\#](https://docs.nestjs.com/faq/serverless\#cold-start)

A cold start is the first time your code has been executed in a while. Depending on a cloud provider you use, it may span several different operations, from downloading the code and bootstrapping the runtime to eventually running your code.
This process adds **significant latency** depending on several factors, the language, the number of packages your application require, etc.

The cold start is important and although there are things which are beyond our control, there's still a lot of things we can do on our side to make it as short as possible.

While you can think of Nest as a fully-fledged framework designed to be used in complex, enterprise applications,
it is also **suitable for much "simpler" applications** (or scripts). For example, with the use of [Standalone applications](https://docs.nestjs.com/standalone-applications) feature, you can take advantage of Nest's DI system in simple workers, CRON jobs, CLIs, or serverless functions.

#### Benchmarks [\#](https://docs.nestjs.com/faq/serverless\#benchmarks)

To better understand what's the cost of using Nest or other, well-known libraries (like `express`) in the context of serverless functions, let's compare how much time Node runtime needs to run the following scripts:

content\_copy

```typescript

// #1 Express
import * as express from 'express';

async function bootstrap() {
  const app = express();
  app.get('/', (req, res) => res.send('Hello world!'));
  await new Promise<void>((resolve) => app.listen(3000, resolve));
}
bootstrap();

// #2 Nest (with @nestjs/platform-express)
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { logger: ['error'] });
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

// #3 Nest as a Standalone application (no HTTP server)
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AppService } from './app.service';

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: ['error'],
  });
  console.log(app.get(AppService).getHello());
}
bootstrap();

// #4 Raw Node.js script
async function bootstrap() {
  console.log('Hello world!');
}
bootstrap();

```

For all these scripts, we used the `tsc` (TypeScript) compiler and so the code remains unbundled ( `webpack` isn't used).

| Express | 0.0079s (7.9ms) |
| Nest with `@nestjs/platform-express` | 0.1974s (197.4ms) |
| Nest (standalone application) | 0.1117s (111.7ms) |
| Raw Node.js script | 0.0071s (7.1ms) |

> **Note** Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD.

Now, let's repeat all benchmarks but this time, using `webpack` (if you have [Nest CLI](https://docs.nestjs.com/cli/overview) installed, you can run `nest build --webpack`) to bundle our application into a single executable JavaScript file.
However, instead of using the default `webpack` configuration that Nest CLI ships with, we'll make sure to bundle all dependencies ( `node_modules`) together, as follows:

```javascript

module.exports = (options, webpack) => {
  const lazyImports = [\
    '@nestjs/microservices/microservices-module',\
    '@nestjs/websockets/socket-module',\
  ];

  return {
    ...options,
    externals: [],
    plugins: [\
      ...options.plugins,\
      new webpack.IgnorePlugin({\
        checkResource(resource) {\
          if (lazyImports.includes(resource)) {\
            try {\
              require.resolve(resource);\
            } catch (err) {\
              return true;\
            }\
          }\
          return false;\
        },\
      }),\
    ],
  };
};

```

> **Hint** To instruct Nest CLI to use this configuration, create a new `webpack.config.js` file in the root directory of your project.

With this configuration, we received the following results:

| Express | 0.0068s (6.8ms) |
| Nest with `@nestjs/platform-express` | 0.0815s (81.5ms) |
| Nest (standalone application) | 0.0319s (31.9ms) |
| Raw Node.js script | 0.0066s (6.6ms) |

> **Note** Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD.

> **Hint** You could optimize it even further by applying additional code minification & optimization techniques (using `webpack` plugins, etc.).

As you can see, the way you compile (and whether you bundle your code) is crucial and has a significant impact on the overall startup time. With `webpack`, you can get the bootstrap time of a standalone Nest application (starter project with one module, controller, and service) down to ~32ms on average, and down to ~81.5ms for a regular HTTP, express-based NestJS app.

For more complicated Nest applications, for example, with 10 resources (generated through `$ nest g resource` schematic = 10 modules, 10 controllers, 10 services, 20 DTO classes, 50 HTTP endpoints + `AppModule`), the overall startup on MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD is approximately 0.1298s (129.8ms). Running a monolithic application as a serverless function typically doesn't make too much sense anyway, so think of this benchmark more as an example of how the bootstrap time may potentially increase as your application grows.

#### Runtime optimizations [\#](https://docs.nestjs.com/faq/serverless\#runtime-optimizations)

Thus far we covered compile-time optimizations. These are unrelated to the way you define providers and load Nest modules in your application, and that plays an essential role as your application gets bigger.

For example, imagine having a database connection defined as an [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers). Async providers are designed to delay the application start until one or more asynchronous tasks are completed.
That means, if your serverless function on average requires 2s to connect to the database (on bootstrap), your endpoint will need at least two extra seconds (because it must wait till the connection is established) to send a response back (when it's a cold start and your application wasn't running already).

As you can see, the way you structure your providers is somewhat different in a **serverless environment** where bootstrap time is important.
Another good example is if you use Redis for caching, but only in certain scenarios. Perhaps, in this case, you should not define a Redis connection as an async provider, as it would slow down the bootstrap time, even if it's not required for this specific function invocation.

Also, sometimes you could lazy load entire modules, using the `LazyModuleLoader` class, as described in [this chapter](https://docs.nestjs.com/fundamentals/lazy-loading-modules). Caching is a great example here too.
Imagine that your application has, let's say, `CacheModule` which internally connects to Redis and also, exports the `CacheService` to interact with the Redis storage. If you don't need it for all potential function invocations,
you can just load it on-demand, lazily. This way you'll get a faster startup time (when a cold start occurs) for all invocations that don't require caching.

content\_copy

```typescript

if (request.method === RequestMethod[RequestMethod.GET]) {
  const { CacheModule } = await import('./cache.module');
  const moduleRef = await this.lazyModuleLoader.load(() => CacheModule);

  const { CacheService } = await import('./cache.service');
  const cacheService = moduleRef.get(CacheService);

  return cacheService.get(ENDPOINT_KEY);
}

```

Another great example is a webhook or worker, which depending on some specific conditions (e.g., input arguments), may perform different operations.
In such a case, you could specify a condition inside your route handler that lazily loads an appropriate module for the specific function invocation, and just load every other module lazily.

content\_copy

```typescript

if (workerType === WorkerType.A) {
  const { WorkerAModule } = await import('./worker-a.module');
  const moduleRef = await this.lazyModuleLoader.load(() => WorkerAModule);
  // ...
} else if (workerType === WorkerType.B) {
  const { WorkerBModule } = await import('./worker-b.module');
  const moduleRef = await this.lazyModuleLoader.load(() => WorkerBModule);
  // ...
}

```

#### Example integration [\#](https://docs.nestjs.com/faq/serverless\#example-integration)

The way your application's entry file (typically `main.ts` file) is supposed to look like **depends on several factors** and so **there's no single template** that just works for every scenario.
For example, the initialization file required to spin up your serverless function varies by cloud providers (AWS, Azure, GCP, etc.).
Also, depending on whether you want to run a typical HTTP application with multiple routes/endpoints or just provide a single route (or execute a specific portion of code),
your application's code will look different (for example, for the endpoint-per-function approach you could use the `NestFactory.createApplicationContext` instead of booting the HTTP server, setting up middleware, etc.).

Just for illustration purposes, we'll integrate Nest (using `@nestjs/platform-express` and so spinning up the whole, fully functional HTTP router)
with the [Serverless](https://www.serverless.com/) framework (in this case, targeting AWS Lambda). As we've mentioned earlier, your code will differ depending on the cloud provider you choose, and many other factors.

First, let's install the required packages:

```bash

$ npm i @codegenie/serverless-express aws-lambda
$ npm i -D @types/aws-lambda serverless-offline

```

> **Hint** To speed up development cycles, we install the `serverless-offline` plugin which emulates AWS λ and API Gateway.

Once the installation process is complete, let's create the `serverless.yml` file to configure the Serverless framework:

```yaml

service: serverless-example

plugins:
  - serverless-offline

provider:
  name: aws
  runtime: nodejs14.x

functions:
  main:
    handler: dist/main.handler
    events:
      - http:
          method: ANY
          path: /
      - http:
          method: ANY
          path: '{proxy+}'

```

> **Hint** To learn more about the Serverless framework, visit the [official documentation](https://www.serverless.com/framework/docs/).

With this in place, we can now navigate to the `main.ts` file and update our bootstrap code with the required boilerplate:

content\_copy

```typescript

import { NestFactory } from '@nestjs/core';
import serverlessExpress from '@codegenie/serverless-express';
import { Callback, Context, Handler } from 'aws-lambda';
import { AppModule } from './app.module';

let server: Handler;

async function bootstrap(): Promise<Handler> {
  const app = await NestFactory.create(AppModule);
  await app.init();

  const expressApp = app.getHttpAdapter().getInstance();
  return serverlessExpress({ app: expressApp });
}

export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback,
) => {
  server = server ?? (await bootstrap());
  return server(event, context, callback);
};

```

> **Hint** For creating multiple serverless functions and sharing common modules between them, we recommend using the [CLI Monorepo mode](https://docs.nestjs.com/cli/monorepo#monorepo-mode).

> **Warning** If you use `@nestjs/swagger` package, there are a few additional steps required to make it work properly in the context of serverless function. Check out this [thread](https://github.com/nestjs/swagger/issues/199) for more information.

Next, open up the `tsconfig.json` file and make sure to enable the `esModuleInterop` option to make the `@codegenie/serverless-express` package load properly.

```json

{
  "compilerOptions": {
    ...
    "esModuleInterop": true
  }
}

```

Now we can build our application (with `nest build` or `tsc`) and use the `serverless` CLI to start our lambda function locally:

```bash

$ npm run build
$ npx serverless offline

```

Once the application is running, open your browser and navigate to `http://localhost:3000/dev/[ANY_ROUTE]` (where `[ANY_ROUTE]` is any endpoint registered in your application).

In the sections above, we've shown that using `webpack` and bundling your app can have significant impact on the overall bootstrap time.
However, to make it work with our example, there are a few additional configurations you must add in your `webpack.config.js` file. Generally,
to make sure our `handler` function will be picked up, we must change the `output.libraryTarget` property to `commonjs2`.

```javascript

return {
  ...options,
  externals: [],
  output: {
    ...options.output,
    libraryTarget: 'commonjs2',
  },
  // ... the rest of the configuration
};

```

With this in place, you can now use `$ nest build --webpack` to compile your function's code (and then `$ npx serverless offline` to test it).

It's also recommended (but **not required** as it will slow down your build process) to install the `terser-webpack-plugin` package and override its configuration to keep classnames intact when minifying your production build. Not doing so can result in incorrect behavior when using `class-validator` within your application.

```javascript

const TerserPlugin = require('terser-webpack-plugin');

return {
  ...options,
  externals: [],
  optimization: {
    minimizer: [\
      new TerserPlugin({\
        terserOptions: {\
          keep_classnames: true,\
        },\
      }),\
    ],
  },
  output: {
    ...options.output,
    libraryTarget: 'commonjs2',
  },
  // ... the rest of the configuration
};

```

#### Using standalone application feature [\#](https://docs.nestjs.com/faq/serverless\#using-standalone-application-feature)

Alternatively, if you want to keep your function very lightweight and you don't need any HTTP-related features (routing, but also guards, interceptors, pipes, etc.),
you can just use `NestFactory.createApplicationContext` (as mentioned earlier) instead of running the entire HTTP server (and `express` under the hood), as follows:

content\_copy main.ts

JS  TS

```typescript

import { HttpStatus } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { Callback, Context, Handler } from 'aws-lambda';
import { AppModule } from './app.module';
import { AppService } from './app.service';

export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback,
) => {
  const appContext = await NestFactory.createApplicationContext(AppModule);
  const appService = appContext.get(AppService);

  return {
    body: appService.getHello(),
    statusCode: HttpStatus.OK,
  };
};

```

> **Hint** Be aware that `NestFactory.createApplicationContext` does not wrap controller methods with enhancers (guard, interceptors, etc.). For this, you must use the `NestFactory.create` method.

You could also pass the `event` object down to, let's say, `EventsService` provider that could process it and return a corresponding value (depending on the input value and your business logic).

content\_copy

```typescript

export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback,
) => {
  const appContext = await NestFactory.createApplicationContext(AppModule);
  const eventsService = appContext.get(EventsService);
  return eventsService.process(event);
};

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS MVC Techniques
- [Model-View-Controller](https://docs.nestjs.com/techniques/mvc#model-view-controller)
- [Template rendering](https://docs.nestjs.com/techniques/mvc#template-rendering)
- [Dynamic template rendering](https://docs.nestjs.com/techniques/mvc#dynamic-template-rendering)
- [Example](https://docs.nestjs.com/techniques/mvc#example)
- [Fastify](https://docs.nestjs.com/techniques/mvc#fastify)
- [Example](https://docs.nestjs.com/techniques/mvc#example-1)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/mvc.md "Suggest Edits")

### Model-View-Controller

Nest, by default, makes use of the [Express](https://github.com/expressjs/express) library under the hood. Hence, every technique for using the MVC (Model-View-Controller) pattern in Express applies to Nest as well.

First, let's scaffold a simple Nest application using the [CLI](https://github.com/nestjs/nest-cli) tool:

```bash

$ npm i -g @nestjs/cli
$ nest new project

```

In order to create an MVC app, we also need a [template engine](https://expressjs.com/en/guide/using-template-engines.html) to render our HTML views:

```bash

$ npm install --save hbs

```

We've used the `hbs` ( [Handlebars](https://github.com/pillarjs/hbs#readme)) engine, though you can use whatever fits your requirements. Once the installation process is complete, we need to configure the express instance using the following code:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(
    AppModule,
  );

  app.useStaticAssets(join(__dirname, '..', 'public'));
  app.setBaseViewsDir(join(__dirname, '..', 'views'));
  app.setViewEngine('hbs');

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

```typescript

import { NestFactory } from '@nestjs/core';
import { join } from 'path';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(
    AppModule,
  );

  app.useStaticAssets(join(__dirname, '..', 'public'));
  app.setBaseViewsDir(join(__dirname, '..', 'views'));
  app.setViewEngine('hbs');

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

We told [Express](https://github.com/expressjs/express) that the `public` directory will be used for storing static assets, `views` will contain templates, and the `hbs` template engine should be used to render HTML output.

#### Template rendering [\#](https://docs.nestjs.com/techniques/mvc\#template-rendering)

Now, let's create a `views` directory and `index.hbs` template inside it. In the template, we'll print a `message` passed from the controller:

```html

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>App</title>
  </head>
  <body>
    {{ message }}
  </body>
</html>

```

Next, open the `app.controller` file and replace the `root()` method with the following code:

content\_copy app.controller.ts

JS  TS

```typescript

import { Get, Controller, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index')
  root() {
    return { message: 'Hello world!' };
  }
}

```

In this code, we are specifying the template to use in the `@Render()` decorator, and the return value of the route handler method is passed to the template for rendering. Notice that the return value is an object with a property `message`, matching the `message` placeholder we created in the template.

While the application is running, open your browser and navigate to `http://localhost:3000`. You should see the `Hello world!` message.

#### Dynamic template rendering [\#](https://docs.nestjs.com/techniques/mvc\#dynamic-template-rendering)

If the application logic must dynamically decide which template to render, then we should use the `@Res()` decorator, and supply the view name in our route handler, rather than in the `@Render()` decorator:

> **Hint** When Nest detects the `@Res()` decorator, it injects the library-specific `response` object. We can use this object to dynamically render the template. Learn more about the `response` object API [here](https://expressjs.com/en/api.html).

content\_copy app.controller.ts

JS  TS

```typescript

import { Get, Controller, Res, Render } from '@nestjs/common';
import { Response } from 'express';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private appService: AppService) {}

  @Get()
  root(@Res() res: Response) {
    return res.render(
      this.appService.getViewName(),
      { message: 'Hello world!' },
    );
  }
}

```

#### Example [\#](https://docs.nestjs.com/techniques/mvc\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/15-mvc).

#### Fastify [\#](https://docs.nestjs.com/techniques/mvc\#fastify)

As mentioned in this [chapter](https://docs.nestjs.com/techniques/performance), we are able to use any compatible HTTP provider together with Nest. One such library is [Fastify](https://github.com/fastify/fastify). In order to create an MVC application with Fastify, we have to install the following packages:

```bash

$ npm i --save @fastify/static @fastify/view handlebars

```

The next steps cover almost the same process used with Express, with minor differences specific to the platform. Once the installation process is complete, open the `main.ts` file and update its contents:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { NestFastifyApplication, FastifyAdapter } from '@nestjs/platform-fastify';
import { AppModule } from './app.module';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter(),
  );
  app.useStaticAssets({
    root: join(__dirname, '..', 'public'),
    prefix: '/public/',
  });
  app.setViewEngine({
    engine: {
      handlebars: require('handlebars'),
    },
    templates: join(__dirname, '..', 'views'),
  });
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

```typescript

import { NestFactory } from '@nestjs/core';
import { FastifyAdapter } from '@nestjs/platform-fastify';
import { AppModule } from './app.module';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, new FastifyAdapter());
  app.useStaticAssets({
    root: join(__dirname, '..', 'public'),
    prefix: '/public/',
  });
  app.setViewEngine({
    engine: {
      handlebars: require('handlebars'),
    },
    templates: join(__dirname, '..', 'views'),
  });
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

The Fastify API has a few differences, but the end result of these method calls is the same. One notable difference is that when using Fastify, the template name you pass into the `@Render()` decorator must include the file extension.

Here’s how you can set it up:

content\_copy app.controller.ts

JS  TS

```typescript

import { Get, Controller, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index.hbs')
  root() {
    return { message: 'Hello world!' };
  }
}

```

Alternatively, you can use the `@Res()` decorator to directly inject the response and specify the view you want to render, as shown below:

content\_copy

```typescript

import { Res } from '@nestjs/common';
import { FastifyReply } from 'fastify';

@Get()
root(@Res() res: FastifyReply) {
  return res.view('index.hbs', { title: 'Hello world!' });
}

```

While the application is running, open your browser and navigate to `http://localhost:3000`. You should see the `Hello world!` message.

#### Example [\#](https://docs.nestjs.com/techniques/mvc\#example-1)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/17-mvc-fastify).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Monorepo CLI
- [Workspaces](https://docs.nestjs.com/cli/monorepo#workspaces)
- [Standard mode](https://docs.nestjs.com/cli/monorepo#standard-mode)
- [Monorepo mode](https://docs.nestjs.com/cli/monorepo#monorepo-mode)
- [Workspace projects](https://docs.nestjs.com/cli/monorepo#workspace-projects)
- [Applications](https://docs.nestjs.com/cli/monorepo#applications)
- [Libraries](https://docs.nestjs.com/cli/monorepo#libraries)
- [CLI properties](https://docs.nestjs.com/cli/monorepo#cli-properties)
- [Global compiler options](https://docs.nestjs.com/cli/monorepo#global-compiler-options)
- [Global generate options](https://docs.nestjs.com/cli/monorepo#global-generate-options)
- [Project-specific generate options](https://docs.nestjs.com/cli/monorepo#project-specific-generate-options)
- [Specified compiler](https://docs.nestjs.com/cli/monorepo#specified-compiler)
- [Webpack options](https://docs.nestjs.com/cli/monorepo#webpack-options)
- [Assets](https://docs.nestjs.com/cli/monorepo#assets)
- [Project properties](https://docs.nestjs.com/cli/monorepo#project-properties)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/cli/workspaces.md "Suggest Edits")

### Workspaces

Nest has two modes for organizing code:

- **standard mode**: useful for building individual project-focused applications that have their own dependencies and settings, and don't need to optimize for sharing modules, or optimizing complex builds. This is the default mode.
- **monorepo mode**: this mode treats code artifacts as part of a lightweight **monorepo**, and may be more appropriate for teams of developers and/or multi-project environments. It automates parts of the build process to make it easy to create and compose modular components, promotes code re-use, makes integration testing easier, makes it easy to share project-wide artifacts like `eslint` rules and other configuration policies, and is easier to use than alternatives like Git submodules. Monorepo mode employs the concept of a **workspace**, represented in the `nest-cli.json` file, to coordinate the relationship between the components of the monorepo.

It's important to note that virtually all of Nest's features are independent of your code organization mode. The **only** effect of this choice is how your projects are composed and how build artifacts are generated. All other functionality, from the CLI to core modules to add-on modules work the same in either mode.

Also, you can easily switch from **standard mode** to **monorepo mode** at any time, so you can delay this decision until the benefits of one or the other approach become more clear.

#### Standard mode [\#](https://docs.nestjs.com/cli/monorepo\#standard-mode)

When you run `nest new`, a new **project** is created for you using a built-in schematic. Nest does the following:

1. Create a new folder, corresponding to the `name` argument you provide to `nest new`
2. Populate that folder with default files corresponding to a minimal base-level Nest application. You can examine these files at the [typescript-starter](https://github.com/nestjs/typescript-starter) repository.
3. Provide additional files such as `nest-cli.json`, `package.json` and `tsconfig.json` that configure and enable various tools for compiling, testing and serving your application.

From there, you can modify the starter files, add new components, add dependencies (e.g., `npm install`), and otherwise develop your application as covered in the rest of this documentation.

#### Monorepo mode [\#](https://docs.nestjs.com/cli/monorepo\#monorepo-mode)

To enable monorepo mode, you start with a _standard mode_ structure, and add **projects**. A project can be a full **application** (which you add to the workspace with the command `nest generate app`) or a **library** (which you add to the workspace with the command `nest generate library`). We'll discuss the details of these specific types of project components below. The key point to note now is that it is the **act of adding a project** to an existing standard mode structure that **converts it** to monorepo mode. Let's look at an example.

If we run:

```bash

$ nest new my-project

```

We've constructed a _standard mode_ structure, with a folder structure that looks like this:

node\_modules

src

app.controller.ts

app.module.ts

app.service.ts

main.ts

nest-cli.json

package.json

tsconfig.json

eslint.config.mjs

We can convert this to a monorepo mode structure as follows:

```bash

$ cd my-project
$ nest generate app my-app

```

At this point, `nest` converts the existing structure to a **monorepo mode** structure. This results in a few important changes. The folder structure now looks like this:

apps

my-app

src

app.controller.ts

app.module.ts

app.service.ts

main.ts

tsconfig.app.json

my-project

src

app.controller.ts

app.module.ts

app.service.ts

main.ts

tsconfig.app.json

nest-cli.json

package.json

tsconfig.json

eslint.config.mjs

The `generate app` schematic has reorganized the code - moving each **application** project under the `apps` folder, and adding a project-specific `tsconfig.app.json` file in each project's root folder. Our original `my-project` app has become the **default project** for the monorepo, and is now a peer with the just-added `my-app`, located under the `apps` folder. We'll cover default projects below.

> **Warning** The conversion of a standard mode structure to monorepo only works for projects that have followed the canonical Nest project structure. Specifically, during conversion, the schematic attempts to relocate the `src` and `test` folders in a project folder beneath the `apps` folder in the root. If a project does not use this structure, the conversion will fail or produce unreliable results.

#### Workspace projects [\#](https://docs.nestjs.com/cli/monorepo\#workspace-projects)

A monorepo uses the concept of a workspace to manage its member entities. Workspaces are composed of **projects**. A project may be either:

- an **application**: a full Nest application including a `main.ts` file to bootstrap the application. Aside from compile and build considerations, an application-type project within a workspace is functionally identical to an application within a _standard mode_ structure.
- a **library**: a library is a way of packaging a general purpose set of features (modules, providers, controllers, etc.) that can be used within other projects. A library cannot run on its own, and has no `main.ts` file. Read more about libraries [here](https://docs.nestjs.com/cli/libraries).

All workspaces have a **default project** (which should be an application-type project). This is defined by the top-level `"root"` property in the `nest-cli.json` file, which points at the root of the default project (see [CLI properties](https://docs.nestjs.com/cli/monorepo#cli-properties) below for more details). Usually, this is the **standard mode** application you started with, and later converted to a monorepo using `nest generate app`. When you follow these steps, this property is populated automatically.

Default projects are used by `nest` commands like `nest build` and `nest start` when a project name is not supplied.

For example, in the above monorepo structure, running

```bash

$ nest start

```

will start up the `my-project` app. To start `my-app`, we'd use:

```bash

$ nest start my-app

```

#### Applications [\#](https://docs.nestjs.com/cli/monorepo\#applications)

Application-type projects, or what we might informally refer to as just "applications", are complete Nest applications that you can run and deploy. You generate an application-type project with `nest generate app`.

This command automatically generates a project skeleton, including the standard `src` and `test` folders from the [typescript starter](https://github.com/nestjs/typescript-starter). Unlike standard mode, an application project in a monorepo does not have any of the package dependency ( `package.json`) or other project configuration artifacts like `.prettierrc` and `eslint.config.mjs`. Instead, the monorepo-wide dependencies and config files are used.

However, the schematic does generate a project-specific `tsconfig.app.json` file in the root folder of the project. This config file automatically sets appropriate build options, including setting the compilation output folder properly. The file extends the top-level (monorepo) `tsconfig.json` file, so you can manage global settings monorepo-wide, but override them if needed at the project level.

#### Libraries [\#](https://docs.nestjs.com/cli/monorepo\#libraries)

As mentioned, library-type projects, or simply "libraries", are packages of Nest components that need to be composed into applications in order to run. You generate a library-type project with `nest generate library`. Deciding what belongs in a library is an architectural design decision. We discuss libraries in depth in the [libraries](https://docs.nestjs.com/cli/libraries) chapter.

#### CLI properties [\#](https://docs.nestjs.com/cli/monorepo\#cli-properties)

Nest keeps the metadata needed to organize, build and deploy both standard and monorepo structured projects in the `nest-cli.json` file. Nest automatically adds to and updates this file as you add projects, so you usually do not have to think about it or edit its contents. However, there are some settings you may want to change manually, so it's helpful to have an overview understanding of the file.

After running the steps above to create a monorepo, our `nest-cli.json` file looks like this:

```javascript

{
  "collection": "@nestjs/schematics",
  "sourceRoot": "apps/my-project/src",
  "monorepo": true,
  "root": "apps/my-project",
  "compilerOptions": {
    "webpack": true,
    "tsConfigPath": "apps/my-project/tsconfig.app.json"
  },
  "projects": {
    "my-project": {
      "type": "application",
      "root": "apps/my-project",
      "entryFile": "main",
      "sourceRoot": "apps/my-project/src",
      "compilerOptions": {
        "tsConfigPath": "apps/my-project/tsconfig.app.json"
      }
    },
    "my-app": {
      "type": "application",
      "root": "apps/my-app",
      "entryFile": "main",
      "sourceRoot": "apps/my-app/src",
      "compilerOptions": {
        "tsConfigPath": "apps/my-app/tsconfig.app.json"
      }
    }
  }
}

```

The file is divided into sections:

- a global section with top-level properties controlling standard and monorepo-wide settings
- a top level property ( `"projects"`) with metadata about each project. This section is present only for monorepo-mode structures.

The top-level properties are as follows:

- `"collection"`: points at the collection of schematics used to generate components; you generally should not change this value
- `"sourceRoot"`: points at the root of the source code for the single project in standard mode structures, or the _default project_ in monorepo mode structures
- `"compilerOptions"`: a map with keys specifying compiler options and values specifying the option setting; see details below
- `"generateOptions"`: a map with keys specifying global generate options and values specifying the option setting; see details below
- `"monorepo"`: (monorepo only) for a monorepo mode structure, this value is always `true`
- `"root"`: (monorepo only) points at the project root of the _default project_

#### Global compiler options [\#](https://docs.nestjs.com/cli/monorepo\#global-compiler-options)

These properties specify the compiler to use as well as various options that affect **any** compilation step, whether as part of `nest build` or `nest start`, and regardless of the compiler, whether `tsc` or webpack.

| Property Name | Property Value Type | Description |
| --- | --- | --- |
| `webpack` | boolean | If `true`, use [webpack compiler](https://webpack.js.org/). If `false` or not present, use `tsc`. In monorepo mode, the default is `true` (use webpack), in standard mode, the default is `false` (use `tsc`). See below for details. (deprecated: use `builder` instead) |
| `tsConfigPath` | string | ( **monorepo only**) Points at the file containing the `tsconfig.json` settings that will be used when `nest build` or `nest start` is called without a `project` option (e.g., when the default project is built or started). |
| `webpackConfigPath` | string | Points at a webpack options file. If not specified, Nest looks for the file `webpack.config.js`. See below for more details. |
| `deleteOutDir` | boolean | If `true`, whenever the compiler is invoked, it will first remove the compilation output directory (as configured in `tsconfig.json`, where the default is `./dist`). |
| `assets` | array | Enables automatically distributing non-TypeScript assets whenever a compilation step begins (asset distribution does **not** happen on incremental compiles in `--watch` mode). See below for details. |
| `watchAssets` | boolean | If `true`, run in watch-mode, watching **all** non-TypeScript assets. (For more fine-grained control of the assets to watch, see [Assets](https://docs.nestjs.com/cli/monorepo#assets) section below). |
| `manualRestart` | boolean | If `true`, enables the shortcut `rs` to manually restart the server. Default value is `false`. |
| `builder` | string/object | Instructs CLI on what `builder` to use to compile the project ( `tsc`, `swc`, or `webpack`). To customize builder's behavior, you can pass an object containing two attributes: `type` ( `tsc`, `swc`, or `webpack`) and `options`. |
| `typeCheck` | boolean | If `true`, enables type checking for SWC-driven projects (when `builder` is `swc`). Default value is `false`. |

#### Global generate options [\#](https://docs.nestjs.com/cli/monorepo\#global-generate-options)

These properties specify the default generate options to be used by the `nest generate` command.

| Property Name | Property Value Type | Description |
| --- | --- | --- |
| `spec` | boolean _or_ object | If the value is boolean, a value of `true` enables `spec` generation by default and a value of `false` disables it. A flag passed on the CLI command line overrides this setting, as does a project-specific `generateOptions` setting (more below). If the value is an object, each key represents a schematic name, and the boolean value determines whether the default spec generation is enabled / disabled for that specific schematic. |
| `flat` | boolean | If true, all generate commands will generate a flat structure |

The following example uses a boolean value to specify that spec file generation should be disabled by default for all projects:

```javascript

{
  "generateOptions": {
    "spec": false
  },
  ...
}

```

The following example uses a boolean value to specify flat file generation should be the default for all projects:

```javascript

{
  "generateOptions": {
    "flat": true
  },
  ...
}

```

In the following example, `spec` file generation is disabled only for `service` schematics (e.g., `nest generate service...`):

```javascript

{
  "generateOptions": {
    "spec": {
      "service": false
    }
  },
  ...
}

```

> **Warning** When specifying the `spec` as an object, the key for the generation schematic does not currently support automatic alias handling. This means that specifying a key as for example `service: false` and trying to generate a service via the alias `s`, the spec would still be generated. To make sure both the normal schematic name and the alias work as intended, specify both the normal command name as well as the alias, as seen below.
>
> ```javascript
>
> {
>   "generateOptions": {
>     "spec": {
>       "service": false,
>       "s": false
>     }
>   },
>   ...
> }
>
> ```

#### Project-specific generate options [\#](https://docs.nestjs.com/cli/monorepo\#project-specific-generate-options)

In addition to providing global generate options, you may also specify project-specific generate options. The project specific generate options follow the exact same format as the global generate options, but are specified directly on each project.

Project-specific generate options override global generate options.

```javascript

{
  "projects": {
    "cats-project": {
      "generateOptions": {
        "spec": {
          "service": false
        }
      },
      ...
    }
  },
  ...
}

```

> **Warning** The order of precedence for generate options is as follows. Options specified on the CLI command line take precedence over project-specific options. Project-specific options override global options.

#### Specified compiler [\#](https://docs.nestjs.com/cli/monorepo\#specified-compiler)

The reason for the different default compilers is that for larger projects (e.g., more typical in a monorepo) webpack can have significant advantages in build times and in producing a single file bundling all project components together. If you wish to generate individual files, set `"webpack"` to `false`, which will cause the build process to use `tsc` (or `swc`).

#### Webpack options [\#](https://docs.nestjs.com/cli/monorepo\#webpack-options)

The webpack options file can contain standard [webpack configuration options](https://webpack.js.org/configuration/). For example, to tell webpack to bundle `node_modules` (which are excluded by default), add the following to `webpack.config.js`:

```javascript

module.exports = {
  externals: [],
};

```

Since the webpack config file is a JavaScript file, you can even expose a function that takes default options and returns a modified object:

```javascript

module.exports = function (options) {
  return {
    ...options,
    externals: [],
  };
};

```

#### Assets [\#](https://docs.nestjs.com/cli/monorepo\#assets)

TypeScript compilation automatically distributes compiler output ( `.js` and `.d.ts` files) to the specified output directory. It can also be convenient to distribute non-TypeScript files, such as `.graphql` files, `images`, `.html` files and other assets. This allows you to treat `nest build` (and any initial compilation step) as a lightweight **development build** step, where you may be editing non-TypeScript files and iteratively compiling and testing.
The assets should be located in the `src` folder otherwise they will not be copied.

The value of the `assets` key should be an array of elements specifying the files to be distributed. The elements can be simple strings with `glob`-like file specs, for example:

content\_copy

```typescript

"assets": ["**/*.graphql"],
"watchAssets": true,

```

For finer control, the elements can be objects with the following keys:

- `"include"`: `glob`-like file specifications for the assets to be distributed
- `"exclude"`: `glob`-like file specifications for assets to be **excluded** from the `include` list
- `"outDir"`: a string specifying the path (relative to the root folder) where the assets should be distributed. Defaults to the same output directory configured for compiler output.
- `"watchAssets"`: boolean; if `true`, run in watch mode watching specified assets

For example:

content\_copy

```typescript

"assets": [\
  { "include": "**/*.graphql", "exclude": "**/omitted.graphql", "watchAssets": true },\
]

```

> **Warning** Setting `watchAssets` in a top-level `compilerOptions` property overrides any `watchAssets` settings within the `assets` property.

#### Project properties [\#](https://docs.nestjs.com/cli/monorepo\#project-properties)

This element exists only for monorepo-mode structures. You generally should not edit these properties, as they are used by Nest to locate projects and their configuration options within the monorepo.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Nest CLI Overview
- [Overview](https://docs.nestjs.com/cli/overview#overview)
- [Installation](https://docs.nestjs.com/cli/overview#installation)
- [Basic workflow](https://docs.nestjs.com/cli/overview#basic-workflow)
- [Project structure](https://docs.nestjs.com/cli/overview#project-structure)
- [CLI command syntax](https://docs.nestjs.com/cli/overview#cli-command-syntax)
- [Command overview](https://docs.nestjs.com/cli/overview#command-overview)
- [Requirements](https://docs.nestjs.com/cli/overview#requirements)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/cli/overview.md "Suggest Edits")

### Overview

The [Nest CLI](https://github.com/nestjs/nest-cli) is a command-line interface tool that helps you to initialize, develop, and maintain your Nest applications. It assists in multiple ways, including scaffolding the project, serving it in development mode, and building and bundling the application for production distribution. It embodies best-practice architectural patterns to encourage well-structured apps.

#### Installation [\#](https://docs.nestjs.com/cli/overview\#installation)

**Note**: In this guide we describe using [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) to install packages, including the Nest CLI. Other package managers may be used at your discretion. With npm, you have several options available for managing how your OS command line resolves the location of the `nest` CLI binary file. Here, we describe installing the `nest` binary globally using the `-g` option. This provides a measure of convenience, and is the approach we assume throughout the documentation. Note that installing **any** `npm` package globally leaves the responsibility of ensuring they're running the correct version up to the user. It also means that if you have different projects, each will run the **same** version of the CLI. A reasonable alternative is to use the [npx](https://github.com/npm/cli/blob/latest/docs/lib/content/commands/npx.md) program, built into the `npm` cli (or similar features with other package managers) to ensure that you run a **managed version** of the Nest CLI. We recommend you consult the [npx documentation](https://github.com/npm/cli/blob/latest/docs/lib/content/commands/npx.md) and/or your DevOps support staff for more information.

Install the CLI globally using the `npm install -g` command (see the **Note** above for details about global installs).

```bash

$ npm install -g @nestjs/cli

```

> **Hint** Alternatively, you can use this command `npx @nestjs/cli@latest` without installing the cli globally.

#### Basic workflow [\#](https://docs.nestjs.com/cli/overview\#basic-workflow)

Once installed, you can invoke CLI commands directly from your OS command line through the `nest` executable. See the available `nest` commands by entering the following:

```bash

$ nest --help

```

Get help on an individual command using the following construct. Substitute any command, like `new`, `add`, etc., where you see `generate` in the example below to get detailed help on that command:

```bash

$ nest generate --help

```

To create, build and run a new basic Nest project in development mode, go to the folder that should be the parent of your new project, and run the following commands:

```bash

$ nest new my-nest-project
$ cd my-nest-project
$ npm run start:dev

```

In your browser, open [http://localhost:3000](http://localhost:3000/) to see the new application running. The app will automatically recompile and reload when you change any of the source files.

> **Hint** We recommend using the [SWC builder](https://docs.nestjs.com/recipes/swc) for faster builds (10x more performant than the default TypeScript compiler).

#### Project structure [\#](https://docs.nestjs.com/cli/overview\#project-structure)

When you run `nest new`, Nest generates a boilerplate application structure by creating a new folder and populating an initial set of files. You can continue working in this default structure, adding new components, as described throughout this documentation. We refer to the project structure generated by `nest new` as **standard mode**. Nest also supports an alternate structure for managing multiple projects and libraries called **monorepo mode**.

Aside from a few specific considerations around how the **build** process works (essentially, monorepo mode simplifies build complexities that can sometimes arise from monorepo-style project structures), and built-in [library](https://docs.nestjs.com/cli/libraries) support, the rest of the Nest features, and this documentation, apply equally to both standard and monorepo mode project structures. In fact, you can easily switch from standard mode to monorepo mode at any time in the future, so you can safely defer this decision while you're still learning about Nest.

You can use either mode to manage multiple projects. Here's a quick summary of the differences:

| Feature | Standard Mode | Monorepo Mode |
| --- | --- | --- |
| Multiple projects | Separate file system structure | Single file system structure |
| `node_modules` & `package.json` | Separate instances | Shared across monorepo |
| Default compiler | `tsc` | webpack |
| Compiler settings | Specified separately | Monorepo defaults that can be overridden per project |
| Config files like `eslint.config.mjs`, `.prettierrc`, etc. | Specified separately | Shared across monorepo |
| `nest build` and `nest start` commands | Target defaults automatically to the (only) project in the context | Target defaults to the **default project** in the monorepo |
| Libraries | Managed manually, usually via npm packaging | Built-in support, including path management and bundling |

Read the sections on [Workspaces](https://docs.nestjs.com/cli/monorepo) and [Libraries](https://docs.nestjs.com/cli/libraries) for more detailed information to help you decide which mode is most suitable for you.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### CLI command syntax [\#](https://docs.nestjs.com/cli/overview\#cli-command-syntax)

All `nest` commands follow the same format:

```bash

nest commandOrAlias requiredArg [optionalArg] [options]

```

For example:

```bash

$ nest new my-nest-project --dry-run

```

Here, `new` is the _commandOrAlias_. The `new` command has an alias of `n`. `my-nest-project` is the _requiredArg_. If a _requiredArg_ is not supplied on the command line, `nest` will prompt for it. Also, `--dry-run` has an equivalent short-hand form `-d`. With this in mind, the following command is the equivalent of the above:

```bash

$ nest n my-nest-project -d

```

Most commands, and some options, have aliases. Try running `nest new --help` to see these options and aliases, and to confirm your understanding of the above constructs.

#### Command overview [\#](https://docs.nestjs.com/cli/overview\#command-overview)

Run `nest <command> --help` for any of the following commands to see command-specific options.

See [usage](https://docs.nestjs.com/cli/usages) for detailed descriptions for each command.

| Command | Alias | Description |
| --- | --- | --- |
| `new` | `n` | Scaffolds a new _standard mode_ application with all boilerplate files needed to run. |
| `generate` | `g` | Generates and/or modifies files based on a schematic. |
| `build` |  | Compiles an application or workspace into an output folder. |
| `start` |  | Compiles and runs an application (or default project in a workspace). |
| `add` |  | Imports a library that has been packaged as a **nest library**, running its install schematic. |
| `info` | `i` | Displays information about installed nest packages and other helpful system info. |

#### Requirements [\#](https://docs.nestjs.com/cli/overview\#requirements)

Nest CLI requires a Node.js binary built with [internationalization support](https://nodejs.org/api/intl.html) (ICU), such as the official binaries from the [Node.js project page](https://nodejs.org/en/download). If you encounter errors related to ICU, check that your binary meets this requirement.

```bash

node -p process.versions.icu

```

If the command prints `undefined`, your Node.js binary has no internationalization support.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## RabbitMQ with NestJS
- [RabbitMQ](https://docs.nestjs.com/microservices/rabbitmq#rabbitmq)
- [Installation](https://docs.nestjs.com/microservices/rabbitmq#installation)
- [Overview](https://docs.nestjs.com/microservices/rabbitmq#overview)
- [Options](https://docs.nestjs.com/microservices/rabbitmq#options)
- [Client](https://docs.nestjs.com/microservices/rabbitmq#client)
- [Context](https://docs.nestjs.com/microservices/rabbitmq#context)
- [Message acknowledgement](https://docs.nestjs.com/microservices/rabbitmq#message-acknowledgement)
- [Record builders](https://docs.nestjs.com/microservices/rabbitmq#record-builders)
- [Instance status updates](https://docs.nestjs.com/microservices/rabbitmq#instance-status-updates)
- [Listening to RabbitMQ events](https://docs.nestjs.com/microservices/rabbitmq#listening-to-rabbitmq-events)
- [Underlying driver access](https://docs.nestjs.com/microservices/rabbitmq#underlying-driver-access)
- [Wildcards](https://docs.nestjs.com/microservices/rabbitmq#wildcards)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/rabbitmq.md "Suggest Edits")

### RabbitMQ

[RabbitMQ](https://www.rabbitmq.com/) is an open-source and lightweight message broker which supports multiple messaging protocols. It can be deployed in distributed and federated configurations to meet high-scale, high-availability requirements. In addition, it's the most widely deployed message broker, used worldwide at small startups and large enterprises.

#### Installation [\#](https://docs.nestjs.com/microservices/rabbitmq\#installation)

To start building RabbitMQ-based microservices, first install the required packages:

```bash

$ npm i --save amqplib amqp-connection-manager

```

#### Overview [\#](https://docs.nestjs.com/microservices/rabbitmq\#overview)

To use the RabbitMQ transporter, pass the following options object to the `createMicroservice()` method:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.RMQ,
  options: {
    urls: ['amqp://localhost:5672'],
    queue: 'cats_queue',
    queueOptions: {
      durable: false
    },
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.RMQ,
  options: {
    urls: ['amqp://localhost:5672'],
    queue: 'cats_queue',
    queueOptions: {
      durable: false
    },
  },
});

```

> **Hint** The `Transport` enum is imported from the `@nestjs/microservices` package.

#### Options [\#](https://docs.nestjs.com/microservices/rabbitmq\#options)

The `options` property is specific to the chosen transporter. The **RabbitMQ** transporter exposes the properties described below.

|     |     |
| --- | --- |
| `urls` | An array of connection URLs to try in order |
| `queue` | Queue name which your server will listen to |
| `prefetchCount` | Sets the prefetch count for the channel |
| `isGlobalPrefetchCount` | Enables per channel prefetching |
| `noAck` | If `false`, manual acknowledgment mode enabled |
| `consumerTag` | A name which the server will use to distinguish message deliveries for the consumer; mustn’t be already in use on the channel. It’s usually easier to omit this, in which case the server will create a random name and supply it in the reply. Consumer Tag Identifier (read more [here](https://amqp-node.github.io/amqplib/channel_api.html#channel_consume)) |
| `queueOptions` | Additional queue options (read more [here](https://amqp-node.github.io/amqplib/channel_api.html#channel_assertQueue)) |
| `socketOptions` | Additional socket options (read more [here](https://amqp-node.github.io/amqplib/channel_api.html#connect)) |
| `headers` | Headers to be sent along with every message |
| `replyQueue` | Reply queue for the producer. Default is `amq.rabbitmq.reply-to` |
| `persistent` | If truthy, the message will survive broker restarts provided it’s in a queue that also survives restarts |
| `noAssert` | When false, a queue will not be asserted before consuming |
| `wildcards` | Set to true only if you want to use Topic Exchange for routing messages to queues. Enabling this will allow you to use wildcards (\*, #) as message and event patterns |
| `exchange` | Name for the exchange. Defaults to the queue name when "wildcards" is set to true |
| `exchangeType` | Type of the exchange. Default is `topic`. Valid values are `direct`, `fanout`, `topic`, and `headers` |
| `routingKey` | Additional routing key for the topic exchange |
| `maxConnectionAttempts` | Maximum number of connection attempts. Applies only to the consumer configuration. -1 === infinite |

#### Client [\#](https://docs.nestjs.com/microservices/rabbitmq\#client)

Like other microservice transporters, you have [several options](https://docs.nestjs.com/microservices/basics#client) for creating a RabbitMQ `ClientProxy` instance.

One method for creating an instance is to use the `ClientsModule`. To create a client instance with the `ClientsModule`, import it and use the `register()` method to pass an options object with the same properties shown above in the `createMicroservice()` method, as well as a `name` property to be used as the injection token. Read more about `ClientsModule` [here](https://docs.nestjs.com/microservices/basics#client).

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'MATH_SERVICE',\
        transport: Transport.RMQ,\
        options: {\
          urls: ['amqp://localhost:5672'],\
          queue: 'cats_queue',\
          queueOptions: {\
            durable: false\
          },\
        },\
      },\
    ]),\
  ]
  ...
})

```

Other options to create a client (either `ClientProxyFactory` or `@Client()`) can be used as well. You can read about them [here](https://docs.nestjs.com/microservices/basics#client).

#### Context [\#](https://docs.nestjs.com/microservices/rabbitmq\#context)

In more complex scenarios, you may need to access additional information about the incoming request. When using the RabbitMQ transporter, you can access the `RmqContext` object.

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {
  console.log(`Pattern: ${context.getPattern()}`);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(`Pattern: ${context.getPattern()}`);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `RmqContext` are imported from the `@nestjs/microservices` package.

To access the original RabbitMQ message (with the `properties`, `fields`, and `content`), use the `getMessage()` method of the `RmqContext` object, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {
  console.log(context.getMessage());
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(context.getMessage());
}

```

To retrieve a reference to the RabbitMQ [channel](https://www.rabbitmq.com/channels.html), use the `getChannelRef` method of the `RmqContext` object, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {
  console.log(context.getChannelRef());
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(context.getChannelRef());
}

```

#### Message acknowledgement [\#](https://docs.nestjs.com/microservices/rabbitmq\#message-acknowledgement)

To make sure a message is never lost, RabbitMQ supports [message acknowledgements](https://www.rabbitmq.com/confirms.html). An acknowledgement is sent back by the consumer to tell RabbitMQ that a particular message has been received, processed and that RabbitMQ is free to delete it. If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ack, RabbitMQ will understand that a message wasn't processed fully and will re-queue it.

To enable manual acknowledgment mode, set the `noAck` property to `false`:

content\_copy

```typescript

options: {
  urls: ['amqp://localhost:5672'],
  queue: 'cats_queue',
  noAck: false,
  queueOptions: {
    durable: false
  },
},

```

When manual consumer acknowledgements are turned on, we must send a proper acknowledgement from the worker to signal that we are done with a task.

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {
  const channel = context.getChannelRef();
  const originalMsg = context.getMessage();

  channel.ack(originalMsg);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  const channel = context.getChannelRef();
  const originalMsg = context.getMessage();

  channel.ack(originalMsg);
}

```

#### Record builders [\#](https://docs.nestjs.com/microservices/rabbitmq\#record-builders)

To configure message options, you can use the `RmqRecordBuilder` class (note: this is doable for event-based flows as well). For example, to set `headers` and `priority` properties, use the `setOptions` method, as follows:

content\_copy

```typescript

const message = ':cat:';
const record = new RmqRecordBuilder(message)
  .setOptions({
    headers: {
      ['x-version']: '1.0.0',
    },
    priority: 3,
  })
  .build();

this.client.send('replace-emoji', record).subscribe(...);

```

> **Hint** `RmqRecordBuilder` class is exported from the `@nestjs/microservices` package.

And you can read these values on the server-side as well, by accessing the `RmqContext`, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('replace-emoji')
replaceEmoji(@Payload() data: string, @Ctx() context: RmqContext): string {
  const { properties: { headers } } = context.getMessage();
  return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('replace-emoji')
replaceEmoji(data, context) {
  const { properties: { headers } } = context.getMessage();
  return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

#### Instance status updates [\#](https://docs.nestjs.com/microservices/rabbitmq\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For the RMQ driver, the `status` stream emits `connected` and `disconnected` events.

content\_copy

```typescript

this.client.status.subscribe((status: RmqStatus) => {
  console.log(status);
});

```

> **Hint** The `RmqStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: RmqStatus) => {
  console.log(status);
});

```

#### Listening to RabbitMQ events [\#](https://docs.nestjs.com/microservices/rabbitmq\#listening-to-rabbitmq-events)

In some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the `error` event to trigger additional operations when an error occurs. To do this, use the `on()` method, as shown below:

content\_copy

```typescript

this.client.on('error', (err) => {
  console.error(err);
});

```

Similarly, you can listen to the server's internal events:

content\_copy

```typescript

server.on<RmqEvents>('error', (err) => {
  console.error(err);
});

```

> **Hint** The `RmqEvents` type is imported from the `@nestjs/microservices` package.

#### Underlying driver access [\#](https://docs.nestjs.com/microservices/rabbitmq\#underlying-driver-access)

For more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use the `unwrap()` method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.

content\_copy

```typescript

const managerRef =
  this.client.unwrap<import('amqp-connection-manager').AmqpConnectionManager>();

```

Similarly, you can access the server's underlying driver instance:

content\_copy

```typescript

const managerRef =
  server.unwrap<import('amqp-connection-manager').AmqpConnectionManager>();

```

#### Wildcards [\#](https://docs.nestjs.com/microservices/rabbitmq\#wildcards)

RabbitMQ supports the use of wildcards in routing keys to allow for flexible message routing. The `#` wildcard matches zero or more words, while the `*` wildcard matches exactly one word.

For example, the routing key `cats.#` matches `cats`, `cats.meow`, and `cats.meow.purr`. The routing key `cats.*` matches `cats.meow` but not `cats.meow.purr`.

To enable wildcard support in your RabbitMQ microservice, set the `wildcards` configuration option to `true` in the options object:

content\_copy

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(
  AppModule,
  {
    transport: Transport.RMQ,
    options: {
      urls: ['amqp://localhost:5672'],
      queue: 'cats_queue',
      wildcards: true,
    },
  },
);

```

With this configuration, you can use wildcards in your routing keys when subscribing to events/messages. For example, to listen for messages with the routing key `cats.#`, you can use the following code:

content\_copy

```typescript

@MessagePattern('cats.#')
getCats(@Payload() data: { message: string }, @Ctx() context: RmqContext) {
  console.log(`Received message with routing key: ${context.getPattern()}`);

  return {
    message: 'Hello from the cats service!',
  }
}

```

To send a message with a specific routing key, you can use the `send()` method of the `ClientProxy` instance:

content\_copy

```typescript

this.client.send('cats.meow', { message: 'Meow!' }).subscribe((response) => {
  console.log(response);
});

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Exception Filters
- [Exception filters](https://docs.nestjs.com/exception-filters#exception-filters)
- [Throwing standard exceptions](https://docs.nestjs.com/exception-filters#throwing-standard-exceptions)
- [Exceptions logging](https://docs.nestjs.com/exception-filters#exceptions-logging)
- [Custom exceptions](https://docs.nestjs.com/exception-filters#custom-exceptions)
- [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
- [Exception filters](https://docs.nestjs.com/exception-filters#exception-filters-1)
- [Arguments host](https://docs.nestjs.com/exception-filters#arguments-host)
- [Binding filters](https://docs.nestjs.com/exception-filters#binding-filters)
- [Catch everything](https://docs.nestjs.com/exception-filters#catch-everything)
- [Inheritance](https://docs.nestjs.com/exception-filters#inheritance)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/exception-filters.md "Suggest Edits")

### Exception filters

Nest comes with a built-in **exceptions layer** which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.

![](https://docs.nestjs.com/assets/Filter_1.png)

Out of the box, this action is performed by a built-in **global exception filter**, which handles exceptions of type `HttpException` (and subclasses of it). When an exception is **unrecognized** (is neither `HttpException` nor a class that inherits from `HttpException`), the built-in exception filter generates the following default JSON response:

```json

{
  "statusCode": 500,
  "message": "Internal server error"
}

```

> **Hint** The global exception filter partially supports the `http-errors` library. Basically, any thrown exception containing the `statusCode` and `message` properties will be properly populated and sent back as a response (instead of the default `InternalServerErrorException` for unrecognized exceptions).

#### Throwing standard exceptions [\#](https://docs.nestjs.com/exception-filters\#throwing-standard-exceptions)

Nest provides a built-in `HttpException` class, exposed from the `@nestjs/common` package. For typical HTTP REST/GraphQL API based applications, it's best practice to send standard HTTP response objects when certain error conditions occur.

For example, in the `CatsController`, we have a `findAll()` method (a `GET` route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows:

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
async findAll() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}

```

> **Hint** We used the `HttpStatus` here. This is a helper enum imported from the `@nestjs/common` package.

When the client calls this endpoint, the response looks like this:

```json

{
  "statusCode": 403,
  "message": "Forbidden"
}

```

The `HttpException` constructor takes two required arguments which determine the
response:

- The `response` argument defines the JSON response body. It can be a `string`
or an `object` as described below.
- The `status` argument defines the [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

By default, the JSON response body contains two properties:

- `statusCode`: defaults to the HTTP status code provided in the `status` argument
- `message`: a short description of the HTTP error based on the `status`

To override just the message portion of the JSON response body, supply a string
in the `response` argument. To override the entire JSON response body, pass an object in the `response` argument. Nest will serialize the object and return it as the JSON response body.

The second constructor argument - `status` \- should be a valid HTTP status code.
Best practice is to use the `HttpStatus` enum imported from `@nestjs/common`.

There is a **third** constructor argument (optional) - `options` \- that can be used to provide an error [cause](https://nodejs.org/en/blog/release/v16.9.0/#error-cause). This `cause` object is not serialized into the response object, but it can be useful for logging purposes, providing valuable information about the inner error that caused the `HttpException` to be thrown.

Here's an example overriding the entire response body and providing an error cause:

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
async findAll() {
  try {
    await this.service.findAll()
  } catch (error) {
    throw new HttpException({
      status: HttpStatus.FORBIDDEN,
      error: 'This is a custom message',
    }, HttpStatus.FORBIDDEN, {
      cause: error
    });
  }
}

```

Using the above, this is how the response would look:

```json

{
  "status": 403,
  "error": "This is a custom message"
}

```

#### Exceptions logging [\#](https://docs.nestjs.com/exception-filters\#exceptions-logging)

By default, the exception filter does not log built-in exceptions like `HttpException` (and any exceptions that inherit from it). When these exceptions are thrown, they won't appear in the console, as they are treated as part of the normal application flow. The same behavior applies to other built-in exceptions such as `WsException` and `RpcException`.

These exceptions all inherit from the base `IntrinsicException` class, which is exported from the `@nestjs/common` package. This class helps differentiate between exceptions that are part of normal application operation and those that are not.

If you want to log these exceptions, you can create a custom exception filter. We'll explain how to do this in the next section.

#### Custom exceptions [\#](https://docs.nestjs.com/exception-filters\#custom-exceptions)

In many cases, you will not need to write custom exceptions, and can use the built-in Nest HTTP exception, as described in the next section. If you do need to create customized exceptions, it's good practice to create your own **exceptions hierarchy**, where your custom exceptions inherit from the base `HttpException` class. With this approach, Nest will recognize your exceptions, and automatically take care of the error responses. Let's implement such a custom exception:

content\_copy forbidden.exception.ts

JS  TS

```typescript

export class ForbiddenException extends HttpException {
  constructor() {
    super('Forbidden', HttpStatus.FORBIDDEN);
  }
}

```

Since `ForbiddenException` extends the base `HttpException`, it will work seamlessly with the built-in exception handler, and therefore we can use it inside the `findAll()` method.

content\_copy cats.controller.ts

JS  TS

```typescript

@Get()
async findAll() {
  throw new ForbiddenException();
}

```

#### Built-in HTTP exceptions [\#](https://docs.nestjs.com/exception-filters\#built-in-http-exceptions)

Nest provides a set of standard exceptions that inherit from the base `HttpException`. These are exposed from the `@nestjs/common` package, and represent many of the most common HTTP exceptions:

- `BadRequestException`
- `UnauthorizedException`
- `NotFoundException`
- `ForbiddenException`
- `NotAcceptableException`
- `RequestTimeoutException`
- `ConflictException`
- `GoneException`
- `HttpVersionNotSupportedException`
- `PayloadTooLargeException`
- `UnsupportedMediaTypeException`
- `UnprocessableEntityException`
- `InternalServerErrorException`
- `NotImplementedException`
- `ImATeapotException`
- `MethodNotAllowedException`
- `BadGatewayException`
- `ServiceUnavailableException`
- `GatewayTimeoutException`
- `PreconditionFailedException`

All the built-in exceptions can also provide both an error `cause` and an error description using the `options` parameter:

content\_copy

```typescript

throw new BadRequestException('Something bad happened', {
  cause: new Error(),
  description: 'Some error description',
});

```

Using the above, this is how the response would look:

```json

{
  "message": "Something bad happened",
  "error": "Some error description",
  "statusCode": 400
}

```

#### Exception filters [\#](https://docs.nestjs.com/exception-filters\#exception-filters-1)

While the base (built-in) exception filter can automatically handle many cases for you, you may want **full control** over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. **Exception filters** are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client.

Let's create an exception filter that is responsible for catching exceptions which are an instance of the `HttpException` class, and implementing custom response logic for them. To do this, we'll need to access the underlying platform `Request` and `Response` objects. We'll access the `Request` object so we can pull out the original `url` and include that in the logging information. We'll use the `Response` object to take direct control of the response that is sent, using the `response.json()` method.

content\_copy http-exception.filter.ts

JS  TS

```typescript

import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}

```

```typescript

import { Catch, HttpException } from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter {
  catch(exception, host) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}

```

> **Hint** All exception filters should implement the generic `ExceptionFilter<T>` interface. This requires you to provide the `catch(exception: T, host: ArgumentsHost)` method with its indicated signature. `T` indicates the type of the exception.

> **Warning** If you are using `@nestjs/platform-fastify` you can use `response.send()` instead of `response.json()`. Don't forget to import the correct types from `fastify`.

The `@Catch(HttpException)` decorator binds the required metadata to the exception filter, telling Nest that this particular filter is looking for exceptions of type `HttpException` and nothing else. The `@Catch()` decorator may take a single parameter, or a comma-separated list. This lets you set up the filter for several types of exceptions at once.

#### Arguments host [\#](https://docs.nestjs.com/exception-filters\#arguments-host)

Let's look at the parameters of the `catch()` method. The `exception` parameter is the exception object currently being processed. The `host` parameter is an `ArgumentsHost` object. `ArgumentsHost` is a powerful utility object that we'll examine further in the [execution context chapter](https://docs.nestjs.com/fundamentals/execution-context)\*. In this code sample, we use it to obtain a reference to the `Request` and `Response` objects that are being passed to the original request handler (in the controller where the exception originates). In this code sample, we've used some helper methods on `ArgumentsHost` to get the desired `Request` and `Response` objects. Learn more about `ArgumentsHost` [here](https://docs.nestjs.com/fundamentals/execution-context).

\*The reason for this level of abstraction is that `ArgumentsHost` functions in all contexts (e.g., the HTTP server context we're working with now, but also Microservices and WebSockets). In the execution context chapter we'll see how we can access the appropriate [underlying arguments](https://docs.nestjs.com/fundamentals/execution-context#host-methods) for **any** execution context with the power of `ArgumentsHost` and its helper functions. This will allow us to write generic exception filters that operate across all contexts.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Binding filters [\#](https://docs.nestjs.com/exception-filters\#binding-filters)

Let's tie our new `HttpExceptionFilter` to the `CatsController`'s `create()` method.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@UseFilters(new HttpExceptionFilter())
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}

```

```typescript

@Post()
@UseFilters(new HttpExceptionFilter())
@Bind(Body())
async create(createCatDto) {
  throw new ForbiddenException();
}

```

> **Hint** The `@UseFilters()` decorator is imported from the `@nestjs/common` package.

We have used the `@UseFilters()` decorator here. Similar to the `@Catch()` decorator, it can take a single filter instance, or a comma-separated list of filter instances. Here, we created the instance of `HttpExceptionFilter` in place. Alternatively, you may pass the class (instead of an instance), leaving responsibility for instantiation to the framework, and enabling **dependency injection**.

content\_copy cats.controller.ts

JS  TS

```typescript

@Post()
@UseFilters(HttpExceptionFilter)
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}

```

```typescript

@Post()
@UseFilters(HttpExceptionFilter)
@Bind(Body())
async create(createCatDto) {
  throw new ForbiddenException();
}

```

> **Hint** Prefer applying filters by using classes instead of instances when possible. It reduces **memory usage** since Nest can easily reuse instances of the same class across your entire module.

In the example above, the `HttpExceptionFilter` is applied only to the single `create()` route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped of the controller/resolver/gateway, controller-scoped, or global-scoped.
For example, to set up a filter as controller-scoped, you would do the following:

content\_copy cats.controller.ts

JS  TS

```typescript

@Controller()
@UseFilters(new HttpExceptionFilter())
export class CatsController {}

```

This construction sets up the `HttpExceptionFilter` for every route handler defined inside the `CatsController`.

To create a global-scoped filter, you would do the following:

content\_copy main.ts

JS  TS

```typescript

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

> **Warning** The `useGlobalFilters()` method does not set up filters for gateways or hybrid applications.

Global-scoped filters are used across the whole application, for every controller and every route handler. In terms of dependency injection, global filters registered from outside of any module (with `useGlobalFilters()` as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can register a global-scoped filter **directly from any module** using the following construction:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';

@Module({
  providers: [\
    {\
      provide: APP_FILTER,\
      useClass: HttpExceptionFilter,\
    },\
  ],
})
export class AppModule {}

```

> **Hint** When using this approach to perform dependency injection for the filter, note that regardless of the module where this construction is employed, the filter is, in fact, global. Where should this be done? Choose the module where the filter ( `HttpExceptionFilter` in the example above) is defined. Also, `useClass` is not the only way of dealing with custom provider registration. Learn more [here](https://docs.nestjs.com/fundamentals/custom-providers).

You can add as many filters with this technique as needed; simply add each to the providers array.

#### Catch everything [\#](https://docs.nestjs.com/exception-filters\#catch-everything)

In order to catch **every** unhandled exception (regardless of the exception type), leave the `@Catch()` decorator's parameter list empty, e.g., `@Catch()`.

In the example below we have a code that is platform-agnostic because it uses the [HTTP adapter](https://docs.nestjs.com/faq/http-adapter) to deliver the response, and doesn't use any of the platform-specific objects ( `Request` and `Response`) directly:

content\_copy

```typescript

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';

@Catch()
export class CatchEverythingFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: unknown, host: ArgumentsHost): void {
    // In certain situations `httpAdapter` might not be available in the
    // constructor method, thus we should resolve it here.
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();

    const httpStatus =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const responseBody = {
      statusCode: httpStatus,
      timestamp: new Date().toISOString(),
      path: httpAdapter.getRequestUrl(ctx.getRequest()),
    };

    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
  }
}

```

> **Warning** When combining an exception filter that catches everything with a filter that is bound to a specific type, the "Catch anything" filter should be declared first to allow the specific filter to correctly handle the bound type.

#### Inheritance [\#](https://docs.nestjs.com/exception-filters\#inheritance)

Typically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the built-in default **global exception filter**, and override the behavior based on certain factors.

In order to delegate exception processing to the base filter, you need to extend `BaseExceptionFilter` and call the inherited `catch()` method.

content\_copy all-exceptions.filter.ts

JS  TS

```typescript

import { Catch, ArgumentsHost } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    super.catch(exception, host);
  }
}

```

```typescript

import { Catch } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception, host) {
    super.catch(exception, host);
  }
}

```

> **Warning** Method-scoped and Controller-scoped filters that extend the `BaseExceptionFilter` should not be instantiated with `new`. Instead, let the framework instantiate them automatically.

Global filters **can** extend the base filter. This can be done in either of two ways.

The first method is to inject the `HttpAdapter` reference when instantiating the custom global filter:

content\_copy

```typescript

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const { httpAdapter } = app.get(HttpAdapterHost);
  app.useGlobalFilters(new AllExceptionsFilter(httpAdapter));

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

The second method is to use the `APP_FILTER` token [as shown here](https://docs.nestjs.com/exception-filters#binding-filters).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS WebSocket Interceptors
- [Interceptors](https://docs.nestjs.com/websockets/interceptors#interceptors)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/websockets/interceptors.md "Suggest Edits")

### Interceptors

There is no difference between [regular interceptors](https://docs.nestjs.com/interceptors) and web sockets interceptors. The following example uses a manually instantiated method-scoped interceptor. Just as with HTTP based applications, you can also use gateway-scoped interceptors (i.e., prefix the gateway class with a `@UseInterceptors()` decorator).

content\_copy

JS  TS

```typescript

@UseInterceptors(new TransformInterceptor())
@SubscribeMessage('events')
handleEvent(client: Client, data: unknown): WsResponse<unknown> {
  const event = 'events';
  return { event, data };
}

```

```typescript

@UseInterceptors(new TransformInterceptor())
@SubscribeMessage('events')
handleEvent(client, data) {
  const event = 'events';
  return { event, data };
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS GraphQL Plugins
- [Plugins with Apollo](https://docs.nestjs.com/graphql/plugins#plugins-with-apollo)
- [Custom plugins](https://docs.nestjs.com/graphql/plugins#custom-plugins)
- [Using external plugins](https://docs.nestjs.com/graphql/plugins#using-external-plugins)
- [Plugins with Mercurius](https://docs.nestjs.com/graphql/plugins#plugins-with-mercurius)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/plugins.md "Suggest Edits")

### Plugins with Apollo

Plugins enable you to extend Apollo Server's core functionality by performing custom operations in response to certain events. Currently, these events correspond to individual phases of the GraphQL request lifecycle, and to the startup of Apollo Server itself (read more [here](https://www.apollographql.com/docs/apollo-server/integrations/plugins/)). For example, a basic logging plugin might log the GraphQL query string associated with each request that's sent to Apollo Server.

#### Custom plugins [\#](https://docs.nestjs.com/graphql/plugins\#custom-plugins)

To create a plugin, declare a class annotated with the `@Plugin` decorator exported from the `@nestjs/apollo` package. Also, for better code autocompletion, implement the `ApolloServerPlugin` interface from the `@apollo/server` package.

content\_copy

```typescript

import { ApolloServerPlugin, GraphQLRequestListener } from '@apollo/server';
import { Plugin } from '@nestjs/apollo';

@Plugin()
export class LoggingPlugin implements ApolloServerPlugin {
  async requestDidStart(): Promise<GraphQLRequestListener<any>> {
    console.log('Request started');
    return {
      async willSendResponse() {
        console.log('Will send response');
      },
    };
  }
}

```

With this in place, we can register the `LoggingPlugin` as a provider.

content\_copy

```typescript

@Module({
  providers: [LoggingPlugin],
})
export class CommonModule {}

```

Nest will automatically instantiate a plugin and apply it to the Apollo Server.

#### Using external plugins [\#](https://docs.nestjs.com/graphql/plugins\#using-external-plugins)

There are several plugins provided out-of-the-box. To use an existing plugin, simply import it and add it to the `plugins` array:

content\_copy

```typescript

GraphQLModule.forRoot({
  // ...
  plugins: [ApolloServerOperationRegistry({ /* options */})]
}),

```

> **Hint** The `ApolloServerOperationRegistry` plugin is exported from the `@apollo/server-plugin-operation-registry` package.

#### Plugins with Mercurius [\#](https://docs.nestjs.com/graphql/plugins\#plugins-with-mercurius)

Some of the existing mercurius-specific Fastify plugins must be loaded after the mercurius plugin (read more [here](https://mercurius.dev/#/docs/plugins)) on the plugin tree.

> **Warning** [mercurius-upload](https://github.com/mercurius-js/mercurius-upload) is an exception and should be registered in the main file.

For this, `MercuriusDriver` exposes an optional `plugins` configuration option. It represents an array of objects that consist of two attributes: `plugin` and its `options`. Therefore, registering the [cache plugin](https://github.com/mercurius-js/cache) would look like this:

content\_copy

```typescript

GraphQLModule.forRoot({
  driver: MercuriusDriver,
  // ...
  plugins: [\
    {\
      plugin: cache,\
      options: {\
        ttl: 10,\
        policy: {\
          Query: {\
            add: true\
          }\
        }\
      },\
    }\
  ]
}),

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS WebSocket Pipes
- [Pipes](https://docs.nestjs.com/websockets/pipes#pipes)
- [Binding pipes](https://docs.nestjs.com/websockets/pipes#binding-pipes)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/websockets/pipes.md "Suggest Edits")

### Pipes

There is no fundamental difference between [regular pipes](https://docs.nestjs.com/pipes) and web sockets pipes. The only difference is that instead of throwing `HttpException`, you should use `WsException`. In addition, all pipes will be only applied to the `data` parameter (because validating or transforming `client` instance is useless).

> **Hint** The `WsException` class is exposed from `@nestjs/websockets` package.

#### Binding pipes [\#](https://docs.nestjs.com/websockets/pipes\#binding-pipes)

The following example uses a manually instantiated method-scoped pipe. Just as with HTTP based applications, you can also use gateway-scoped pipes (i.e., prefix the gateway class with a `@UsePipes()` decorator).

content\_copy

JS  TS

```typescript

@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new WsException(errors) }))
@SubscribeMessage('events')
handleEvent(client: Client, data: unknown): WsResponse<unknown> {
  const event = 'events';
  return { event, data };
}

```

```typescript

@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new WsException(errors) }))
@SubscribeMessage('events')
handleEvent(client, data) {
  const event = 'events';
  return { event, data };
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Nest Standalone Applications
- [Standalone applications](https://docs.nestjs.com/standalone-applications#standalone-applications)
- [Getting started](https://docs.nestjs.com/standalone-applications#getting-started)
- [Retrieving providers from static modules](https://docs.nestjs.com/standalone-applications#retrieving-providers-from-static-modules)
- [Retrieving providers from dynamic modules](https://docs.nestjs.com/standalone-applications#retrieving-providers-from-dynamic-modules)
- [Terminating phase](https://docs.nestjs.com/standalone-applications#terminating-phase)
- [Example](https://docs.nestjs.com/standalone-applications#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/application-context.md "Suggest Edits")

### Standalone applications

There are several ways of mounting a Nest application. You can create a web app, a microservice or just a bare Nest **standalone application** (without any network listeners). The Nest standalone application is a wrapper around the Nest **IoC container**, which holds all instantiated classes. We can obtain a reference to any existing instance from within any imported module directly using the standalone application object. Thus, you can take advantage of the Nest framework anywhere, including, for example, scripted **CRON** jobs. You can even build a **CLI** on top of it.

#### Getting started [\#](https://docs.nestjs.com/standalone-applications\#getting-started)

To create a Nest standalone application, use the following construction:

content\_copy

JS  TS

```typescript

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);
  // your application logic here ...
}
bootstrap();

```

#### Retrieving providers from static modules [\#](https://docs.nestjs.com/standalone-applications\#retrieving-providers-from-static-modules)

The standalone application object allows you to obtain a reference to any instance registered within the Nest application. Let's imagine that we have a `TasksService` provider in the `TasksModule` module that was imported by our `AppModule` module. This class provides a set of methods that we want to call from within a CRON job.

content\_copy

JS  TS

```typescript

const tasksService = app.get(TasksService);

```

To access the `TasksService` instance we use the `get()` method. The `get()` method acts like a **query** that searches for an instance in each registered module. You can pass any provider's token to it. Alternatively, for strict context checking, pass an options object with the `strict: true` property. With this option in effect, you have to navigate through specific modules to obtain a particular instance from the selected context.

content\_copy

JS  TS

```typescript

const tasksService = app.select(TasksModule).get(TasksService, { strict: true });

```

Following is a summary of the methods available for retrieving instance references from the standalone application object.

|     |     |
| --- | --- |
| `get()` | Retrieves an instance of a controller or provider (including guards, filters, and so on) available in the application context. |
| `select()` | Navigates through the module's graph to pull out a specific instance of the selected module (used together with strict mode as described above). |

> **Hint** In non-strict mode, the root module is selected by default. To select any other module, you need to navigate the modules graph manually, step by step.

Keep in mind that a standalone application does not have any network listeners, so any Nest features related to HTTP (e.g., middleware, interceptors, pipes, guards, etc.) are not available in this context.

For example, even if you register a global interceptor in your application and then retrieve a controller's instance using the `app.get()` method, the interceptor will not be executed.

#### Retrieving providers from dynamic modules [\#](https://docs.nestjs.com/standalone-applications\#retrieving-providers-from-dynamic-modules)

When dealing with [dynamic modules](https://docs.nestjs.com/fundamentals/dynamic-modules), we should supply the same object that represents the registered dynamic module in the application to `app.select`. For example:

content\_copy

JS  TS

```typescript

export const dynamicConfigModule = ConfigModule.register({ folder: './config' });

@Module({
  imports: [dynamicConfigModule],
})
export class AppModule {}

```

Then you can select that module later on:

content\_copy

JS  TS

```typescript

const configService = app.select(dynamicConfigModule).get(ConfigService, { strict: true });

```

#### Terminating phase [\#](https://docs.nestjs.com/standalone-applications\#terminating-phase)

If you want the Node application to close after the script finishes (e.g., for a script running CRON jobs), you must call the `app.close()` method in the end of your `bootstrap` function like this:

content\_copy

JS  TS

```typescript

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);
  // application logic...
  await app.close();
}
bootstrap();

```

And as mentioned in the [Lifecycle events](https://docs.nestjs.com/fundamentals/lifecycle-events) chapter, that will trigger lifecycle hooks.

#### Example [\#](https://docs.nestjs.com/standalone-applications\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/18-context).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## MongoDB with NestJS
- [MongoDB (Mongoose)](https://docs.nestjs.com/recipes/mongodb#mongodb-mongoose)
- [Getting started](https://docs.nestjs.com/recipes/mongodb#getting-started)
- [Model injection](https://docs.nestjs.com/recipes/mongodb#model-injection)
- [Example](https://docs.nestjs.com/recipes/mongodb#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/mongodb.md "Suggest Edits")

### MongoDB (Mongoose)

> **Warning** In this article, you'll learn how to create a `DatabaseModule` based on the **Mongoose** package from scratch using custom components. As a consequence, this solution contains a lot of overhead that you can omit using ready to use and available out-of-the-box dedicated `@nestjs/mongoose` package. To learn more, see [here](https://docs.nestjs.com/techniques/mongodb).

[Mongoose](https://mongoosejs.com/) is the most popular [MongoDB](https://www.mongodb.org/) object modeling tool.

#### Getting started [\#](https://docs.nestjs.com/recipes/mongodb\#getting-started)

To start the adventure with this library we have to install all required dependencies:

content\_copy

```typescript

$ npm install --save mongoose

```

The first step we need to do is to establish the connection with our database using `connect()` function. The `connect()` function returns a `Promise`, and therefore we have to create an [async provider](https://docs.nestjs.com/fundamentals/async-components).

content\_copy database.providers.ts

JS  TS

```typescript

import * as mongoose from 'mongoose';

export const databaseProviders = [\
  {\
    provide: 'DATABASE_CONNECTION',\
    useFactory: (): Promise<typeof mongoose> =>\
      mongoose.connect('mongodb://localhost/nest'),\
  },\
];

```

```typescript

import * as mongoose from 'mongoose';

export const databaseProviders = [\
  {\
    provide: 'DATABASE_CONNECTION',\
    useFactory: () => mongoose.connect('mongodb://localhost/nest'),\
  },\
];

```

> **Hint** Following best practices, we declared the custom provider in the separated file which has a `*.providers.ts` suffix.

Then, we need to export these providers to make them **accessible** for the rest part of the application.

content\_copy database.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { databaseProviders } from './database.providers';

@Module({
  providers: [...databaseProviders],
  exports: [...databaseProviders],
})
export class DatabaseModule {}

```

Now we can inject the `Connection` object using `@Inject()` decorator. Each class that would depend on the `Connection` async provider will wait until a `Promise` is resolved.

#### Model injection [\#](https://docs.nestjs.com/recipes/mongodb\#model-injection)

With Mongoose, everything is derived from a [Schema](https://mongoosejs.com/docs/guide.html). Let's define the `CatSchema`:

content\_copy schemas/cat.schema.ts

JS  TS

```typescript

import * as mongoose from 'mongoose';

export const CatSchema = new mongoose.Schema({
  name: String,
  age: Number,
  breed: String,
});

```

The `CatsSchema` belongs to the `cats` directory. This directory represents the `CatsModule`.

Now it's time to create a **Model** provider:

content\_copy cats.providers.ts

JS  TS

```typescript

import { Connection } from 'mongoose';
import { CatSchema } from './schemas/cat.schema';

export const catsProviders = [\
  {\
    provide: 'CAT_MODEL',\
    useFactory: (connection: Connection) => connection.model('Cat', CatSchema),\
    inject: ['DATABASE_CONNECTION'],\
  },\
];

```

```typescript

import { CatSchema } from './schemas/cat.schema';

export const catsProviders = [\
  {\
    provide: 'CAT_MODEL',\
    useFactory: (connection) => connection.model('Cat', CatSchema),\
    inject: ['DATABASE_CONNECTION'],\
  },\
];

```

> **Warning** In the real-world applications you should avoid **magic strings**. Both `CAT_MODEL` and `DATABASE_CONNECTION` should be kept in the separated `constants.ts` file.

Now we can inject the `CAT_MODEL` to the `CatsService` using the `@Inject()` decorator:

content\_copy cats.service.ts

JS  TS

```typescript

import { Model } from 'mongoose';
import { Injectable, Inject } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';
import { CreateCatDto } from './dto/create-cat.dto';

@Injectable()
export class CatsService {
  constructor(
    @Inject('CAT_MODEL')
    private catModel: Model<Cat>,
  ) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const createdCat = new this.catModel(createCatDto);
    return createdCat.save();
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';

@Injectable()
@Dependencies('CAT_MODEL')
export class CatsService {
  constructor(catModel) {
    this.catModel = catModel;
  }

  async create(createCatDto) {
    const createdCat = new this.catModel(createCatDto);
    return createdCat.save();
  }

  async findAll() {
    return this.catModel.find().exec();
  }
}

```

In the above example we have used the `Cat` interface. This interface extends the `Document` from the mongoose package:

content\_copy

```typescript

import { Document } from 'mongoose';

export interface Cat extends Document {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}

```

The database connection is **asynchronous**, but Nest makes this process completely invisible for the end-user. The `CatModel` class is waiting for the db connection, and the `CatsService` is delayed until model is ready to use. The entire application can start when each class is instantiated.

Here is a final `CatsModule`:

content\_copy cats.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { catsProviders } from './cats.providers';
import { DatabaseModule } from '../database/database.module';

@Module({
  imports: [DatabaseModule],
  controllers: [CatsController],
  providers: [\
    CatsService,\
    ...catsProviders,\
  ],
})
export class CatsModule {}

```

> **Hint** Do not forget to import the `CatsModule` into the root `AppModule`.

#### Example [\#](https://docs.nestjs.com/recipes/mongodb\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/14-mongoose-base).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Mutations in NestJS
- [Mutations](https://docs.nestjs.com/graphql/mutations#mutations)
- [Code first](https://docs.nestjs.com/graphql/mutations#code-first)
- [Schema first](https://docs.nestjs.com/graphql/mutations#schema-first)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/mutations.md "Suggest Edits")

### Mutations

Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well. In REST, any request could end up causing side-effects on the server, but best practice suggests we should not modify data in GET requests. GraphQL is similar - technically any query could be implemented to cause a data write. However, like REST, it's recommended to observe the convention that any operations that cause writes should be sent explicitly via a mutation (read more [here](https://graphql.org/learn/queries/#mutations)).

The official [Apollo](https://www.apollographql.com/docs/graphql-tools/generate-schema.html) documentation uses an `upvotePost()` mutation example. This mutation implements a method to increase a post's `votes` property value. To create an equivalent mutation in Nest, we'll make use of the `@Mutation()` decorator.

#### Code first [\#](https://docs.nestjs.com/graphql/mutations\#code-first)

Let's add another method to the `AuthorResolver` used in the previous section (see [resolvers](https://docs.nestjs.com/graphql/resolvers)).

content\_copy

```typescript

@Mutation(() => Post)
async upvotePost(@Args({ name: 'postId', type: () => Int }) postId: number) {
  return this.postsService.upvoteById({ id: postId });
}

```

> **Hint** All decorators (e.g., `@Resolver`, `@ResolveField`, `@Args`, etc.) are exported from the `@nestjs/graphql` package.

This will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Mutation {
  upvotePost(postId: Int!): Post
}

```

The `upvotePost()` method takes `postId` ( `Int`) as an argument and returns an updated `Post` entity. For the reasons explained in the [resolvers](https://docs.nestjs.com/graphql/resolvers) section, we have to explicitly set the expected type.

If the mutation needs to take an object as an argument, we can create an **input type**. The input type is a special kind of object type that can be passed in as an argument (read more [here](https://graphql.org/learn/schema/#input-types)). To declare an input type, use the `@InputType()` decorator.

content\_copy

```typescript

import { InputType, Field } from '@nestjs/graphql';

@InputType()
export class UpvotePostInput {
  @Field()
  postId: number;
}

```

> **Hint** The `@InputType()` decorator takes an options object as an argument, so you can, for example, specify the input type's description. Note that, due to TypeScript's metadata reflection system limitations, you must either use the `@Field` decorator to manually indicate a type, or use a [CLI plugin](https://docs.nestjs.com/graphql/cli-plugin).

We can then use this type in the resolver class:

content\_copy

```typescript

@Mutation(() => Post)
async upvotePost(
  @Args('upvotePostData') upvotePostData: UpvotePostInput,
) {}

```

#### Schema first [\#](https://docs.nestjs.com/graphql/mutations\#schema-first)

Let's extend our `AuthorResolver` used in the previous section (see [resolvers](https://docs.nestjs.com/graphql/resolvers)).

content\_copy

```typescript

@Mutation()
async upvotePost(@Args('postId') postId: number) {
  return this.postsService.upvoteById({ id: postId });
}

```

Note that we assumed above that the business logic has been moved to the `PostsService` (querying the post and incrementing its `votes` property). The logic inside the `PostsService` class can be as simple or sophisticated as needed. The main point of this example is to show how resolvers can interact with other providers.

The last step is to add our mutation to the existing types definition.

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String
  votes: Int
}

type Query {
  author(id: Int!): Author
}

type Mutation {
  upvotePost(postId: Int!): Post
}

```

The `upvotePost(postId: Int!): Post` mutation is now available to be called as part of our application's GraphQL API.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Documentation Guide
- [Documentation](https://docs.nestjs.com/recipes/documentation#documentation)
- [Setup](https://docs.nestjs.com/recipes/documentation#setup)
- [Generation](https://docs.nestjs.com/recipes/documentation#generation)
- [Contribute](https://docs.nestjs.com/recipes/documentation#contribute)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/documentation.md "Suggest Edits")

### Documentation

**Compodoc** is a documentation tool for Angular applications. Since Nest and Angular share similar project and code structures, **Compodoc** works with Nest applications as well.

#### Setup [\#](https://docs.nestjs.com/recipes/documentation\#setup)

Setting up Compodoc inside an existing Nest project is very simple. Start by adding the dev-dependency with the following command in your OS terminal:

```bash

$ npm i -D @compodoc/compodoc

```

#### Generation [\#](https://docs.nestjs.com/recipes/documentation\#generation)

Generate project documentation using the following command (npm 6 is required for `npx` support). See [the official documentation](https://compodoc.app/guides/usage.html) for more options.

```bash

$ npx @compodoc/compodoc -p tsconfig.json -s

```

Open your browser and navigate to [http://localhost:8080](http://localhost:8080/). You should see an initial Nest CLI project:

![](https://docs.nestjs.com/assets/documentation-compodoc-1.jpg)![](https://docs.nestjs.com/assets/documentation-compodoc-2.jpg)

#### Contribute [\#](https://docs.nestjs.com/recipes/documentation\#contribute)

You can participate and contribute to the Compodoc project [here](https://github.com/compodoc/compodoc).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS WebSocket Gateways
- [Gateways](https://docs.nestjs.com/websockets/gateways#gateways)
- [Installation](https://docs.nestjs.com/websockets/gateways#installation)
- [Overview](https://docs.nestjs.com/websockets/gateways#overview)
- [Multiple responses](https://docs.nestjs.com/websockets/gateways#multiple-responses)
- [Asynchronous responses](https://docs.nestjs.com/websockets/gateways#asynchronous-responses)
- [Lifecycle hooks](https://docs.nestjs.com/websockets/gateways#lifecycle-hooks)
- [Server and Namespace](https://docs.nestjs.com/websockets/gateways#server-and-namespace)
- [Example](https://docs.nestjs.com/websockets/gateways#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/websockets/gateways.md "Suggest Edits")

### Gateways

Most of the concepts discussed elsewhere in this documentation, such as dependency injection, decorators, exception filters, pipes, guards and interceptors, apply equally to gateways. Wherever possible, Nest abstracts implementation details so that the same components can run across HTTP-based platforms, WebSockets, and Microservices. This section covers the aspects of Nest that are specific to WebSockets.

In Nest, a gateway is simply a class annotated with `@WebSocketGateway()` decorator. Technically, gateways are platform-agnostic which makes them compatible with any WebSockets library once an adapter is created. There are two WS platforms supported out-of-the-box: [socket.io](https://github.com/socketio/socket.io) and [ws](https://github.com/websockets/ws). You can choose the one that best suits your needs. Also, you can build your own adapter by following this [guide](https://docs.nestjs.com/websockets/adapter).

![](https://docs.nestjs.com/assets/Gateways_1.png)

> **Hint** Gateways can be treated as [providers](https://docs.nestjs.com/providers); this means they can inject dependencies through the class constructor. Also, gateways can be injected by other classes (providers and controllers) as well.

#### Installation [\#](https://docs.nestjs.com/websockets/gateways\#installation)

To start building WebSockets-based applications, first install the required package:

content\_copy

JS  TS

```typescript

$ npm i --save @nestjs/websockets @nestjs/platform-socket.io

```

```typescript

$ npm i --save @nestjs/websockets @nestjs/platform-socket.io

```

#### Overview [\#](https://docs.nestjs.com/websockets/gateways\#overview)

In general, each gateway is listening on the same port as the **HTTP server**, unless your app is not a web application, or you have changed the port manually. This default behavior can be modified by passing an argument to the `@WebSocketGateway(80)` decorator where `80` is a chosen port number. You can also set a [namespace](https://socket.io/docs/v4/namespaces/) used by the gateway using the following construction:

content\_copy

```typescript

@WebSocketGateway(80, { namespace: 'events' })

```

> **Warning** Gateways are not instantiated until they are referenced in the providers array of an existing module.

You can pass any supported [option](https://socket.io/docs/v4/server-options/) to the socket constructor with the second argument to the `@WebSocketGateway()` decorator, as shown below:

content\_copy

```typescript

@WebSocketGateway(81, { transports: ['websocket'] })

```

The gateway is now listening, but we have not yet subscribed to any incoming messages. Let's create a handler that will subscribe to the `events` messages and respond to the user with the exact same data.

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
handleEvent(@MessageBody() data: string): string {
  return data;
}

```

```typescript

@Bind(MessageBody())
@SubscribeMessage('events')
handleEvent(data) {
  return data;
}

```

> **Hint** `@SubscribeMessage()` and `@MessageBody()` decorators are imported from `@nestjs/websockets` package.

Once the gateway is created, we can register it in our module.

content\_copy events.module.ts

JS  TS

```typescript

@Module({
  providers: [EventsGateway]
})
export class EventsModule {}

```

You can also pass in a property key to the decorator to extract it from the incoming message body:

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
handleEvent(@MessageBody('id') id: number): number {
  // id === messageBody.id
  return id;
}

```

```typescript

@Bind(MessageBody('id'))
@SubscribeMessage('events')
handleEvent(id) {
  // id === messageBody.id
  return id;
}

```

If you would prefer not to use decorators, the following code is functionally equivalent:

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
handleEvent(client: Socket, data: string): string {
  return data;
}

```

```typescript

@SubscribeMessage('events')
handleEvent(client, data) {
  return data;
}

```

In the example above, the `handleEvent()` function takes two arguments. The first one is a platform-specific [socket instance](https://socket.io/docs/v4/server-api/#socket), while the second one is the data received from the client. This approach is not recommended though, because it requires mocking the `socket` instance in each unit test.

Once the `events` message is received, the handler sends an acknowledgment with the same data that was sent over the network. In addition, it's possible to emit messages using a library-specific approach, for example, by making use of `client.emit()` method. In order to access a connected socket instance, use `@ConnectedSocket()` decorator.

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
handleEvent(
  @MessageBody() data: string,
  @ConnectedSocket() client: Socket,
): string {
  return data;
}

```

```typescript

@Bind(MessageBody(), ConnectedSocket())
@SubscribeMessage('events')
handleEvent(data, client) {
  return data;
}

```

> **Hint** `@ConnectedSocket()` decorator is imported from `@nestjs/websockets` package.

However, in this case, you won't be able to leverage interceptors. If you don't want to respond to the user, you can simply skip the `return` statement (or explicitly return a "falsy" value, e.g. `undefined`).

Now when a client emits the message as follows:

content\_copy

```typescript

socket.emit('events', { name: 'Nest' });

```

The `handleEvent()` method will be executed. In order to listen for messages emitted from within the above handler, the client has to attach a corresponding acknowledgment listener:

content\_copy

```typescript

socket.emit('events', { name: 'Nest' }, (data) => console.log(data));

```

#### Multiple responses [\#](https://docs.nestjs.com/websockets/gateways\#multiple-responses)

The acknowledgment is dispatched only once. Furthermore, it is not supported by native WebSockets implementation. To solve this limitation, you may return an object which consists of two properties. The `event` which is a name of the emitted event and the `data` that has to be forwarded to the client.

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
handleEvent(@MessageBody() data: unknown): WsResponse<unknown> {
  const event = 'events';
  return { event, data };
}

```

```typescript

@Bind(MessageBody())
@SubscribeMessage('events')
handleEvent(data) {
  const event = 'events';
  return { event, data };
}

```

> **Hint** The `WsResponse` interface is imported from `@nestjs/websockets` package.

> **Warning** You should return a class instance that implements `WsResponse` if your `data` field relies on `ClassSerializerInterceptor`, as it ignores plain JavaScript object responses.

In order to listen for the incoming response(s), the client has to apply another event listener.

content\_copy

```typescript

socket.on('events', (data) => console.log(data));

```

#### Asynchronous responses [\#](https://docs.nestjs.com/websockets/gateways\#asynchronous-responses)

Message handlers are able to respond either synchronously or **asynchronously**. Hence, `async` methods are supported. A message handler is also able to return an `Observable`, in which case the result values will be emitted until the stream is completed.

content\_copy events.gateway.ts

JS  TS

```typescript

@SubscribeMessage('events')
onEvent(@MessageBody() data: unknown): Observable<WsResponse<number>> {
  const event = 'events';
  const response = [1, 2, 3];

  return from(response).pipe(
    map(data => ({ event, data })),
  );
}

```

```typescript

@Bind(MessageBody())
@SubscribeMessage('events')
onEvent(data) {
  const event = 'events';
  const response = [1, 2, 3];

  return from(response).pipe(
    map(data => ({ event, data })),
  );
}

```

In the example above, the message handler will respond **3 times** (with each item from the array).

#### Lifecycle hooks [\#](https://docs.nestjs.com/websockets/gateways\#lifecycle-hooks)

There are 3 useful lifecycle hooks available. All of them have corresponding interfaces and are described in the following table:

|     |     |
| --- | --- |
| `OnGatewayInit` | Forces to implement the `afterInit()` method. Takes library-specific server instance as an argument (and spreads the rest if required). |
| `OnGatewayConnection` | Forces to implement the `handleConnection()` method. Takes library-specific client socket instance as an argument. |
| `OnGatewayDisconnect` | Forces to implement the `handleDisconnect()` method. Takes library-specific client socket instance as an argument. |

> **Hint** Each lifecycle interface is exposed from `@nestjs/websockets` package.

#### Server and Namespace [\#](https://docs.nestjs.com/websockets/gateways\#server-and-namespace)

Occasionally, you may want to have a direct access to the native, **platform-specific** server instance. The reference to this object is passed as an argument to the `afterInit()` method ( `OnGatewayInit` interface). Another option is to use the `@WebSocketServer()` decorator.

content\_copy

```typescript

@WebSocketServer()
server: Server;

```

Also, you can retrieve the corresponding namespace using the `namespace` attribute, as follows:

content\_copy

```typescript

@WebSocketGateway({ namespace: 'my-namespace' })
export class EventsGateway {
  @WebSocketServer()
  namespace: Namespace;
}

```

`@WebSocketServer()` decorator injects a server instance by referencing the metadata stored by the `@WebSocketGateway()` decorator. If you provide the namespace option to the `@WebSocketGateway()` decorator, `@WebSocketServer()` decorator returns a `Namespace` instance instead of a `Server` instance.

> **Notice** The `@WebSocketServer()` decorator is imported from the `@nestjs/websockets` package.

Nest will automatically assign the server instance to this property once it is ready to use.

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

#### Example [\#](https://docs.nestjs.com/websockets/gateways\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/02-gateways).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Necord Discord Bot Guide
- [Necord](https://docs.nestjs.com/recipes/necord#necord)
- [Installation](https://docs.nestjs.com/recipes/necord#installation)
- [Usage](https://docs.nestjs.com/recipes/necord#usage)
- [Text commands](https://docs.nestjs.com/recipes/necord#text-commands)
- [Application commands](https://docs.nestjs.com/recipes/necord#application-commands)
- [Slash commands](https://docs.nestjs.com/recipes/necord#slash-commands)
- [User context menu](https://docs.nestjs.com/recipes/necord#user-context-menu)
- [Message context menu](https://docs.nestjs.com/recipes/necord#message-context-menu)
- [Buttons](https://docs.nestjs.com/recipes/necord#buttons)
- [Select menus](https://docs.nestjs.com/recipes/necord#select-menus)
- [Modals](https://docs.nestjs.com/recipes/necord#modals)
- [More information](https://docs.nestjs.com/recipes/necord#more-information)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/necord.md "Suggest Edits")

### Necord

Necord is a powerful module that simplifies the creation of [Discord](https://discord.com/) bots, allowing for seamless integration with your NestJS application.

> **Note** Necord is a third-party package and is not officially maintained by the NestJS core team. If you encounter any issues, please report them in the [official repository](https://github.com/necordjs/necord).

#### Installation [\#](https://docs.nestjs.com/recipes/necord\#installation)

To get started, you need to install Necord alongside its dependency, [`Discord.js`](https://discord.js.org/).

```bash

$ npm install necord discord.js

```

#### Usage [\#](https://docs.nestjs.com/recipes/necord\#usage)

To utilize Necord in your project, import the `NecordModule` and configure it with the necessary options.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { NecordModule } from 'necord';
import { IntentsBitField } from 'discord.js';
import { AppService } from './app.service';

@Module({
  imports: [\
    NecordModule.forRoot({\
      token: process.env.DISCORD_TOKEN,\
      intents: [IntentsBitField.Flags.Guilds],\
      development: [process.env.DISCORD_DEVELOPMENT_GUILD_ID],\
    }),\
  ],
  providers: [AppService],
})
export class AppModule {}

```

> **Hint** You can find a comprehensive list of available intents [here](https://discord.com/developers/docs/topics/gateway#gateway-intents).

With this setup, you can inject the `AppService` into your providers to easily register commands, events, and more.

content\_copy app.service.ts

JS  TS

```typescript

import { Injectable, Logger } from '@nestjs/common';
import { Context, On, Once, ContextOf } from 'necord';
import { Client } from 'discord.js';

@Injectable()
export class AppService {
  private readonly logger = new Logger(AppService.name);

  @Once('ready')
  public onReady(@Context() [client]: ContextOf<'ready'>) {
    this.logger.log(`Bot logged in as ${client.user.username}`);
  }

  @On('warn')
  public onWarn(@Context() [message]: ContextOf<'warn'>) {
    this.logger.warn(message);
  }
}

```

##### Understanding context

You may have noticed the `@Context` decorator in the examples above. This decorator injects the event context into your method, allowing you to access various event-specific data. Since there are multiple types of events, the context type is inferred using the `ContextOf<type: string>` type. You can easily access context variables by using the `@Context()` decorator, which fills the variable with an array of arguments relevant to the event.

#### Text commands [\#](https://docs.nestjs.com/recipes/necord\#text-commands)

> **Caution** Text commands rely on message content, which is set to be deprecated for verified bots and applications with over 100 servers. This means that if your bot is unable to access message content, text commands will not function. Read more about this change [here](https://support-dev.discord.com/hc/en-us/articles/4404772028055-Message-Content-Access-Deprecation-for-Verified-Bots).

Here's how to create a simple command handler for messages using the `@TextCommand` decorator.

content\_copy app.commands.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, TextCommand, TextCommandContext, Arguments } from 'necord';

@Injectable()
export class AppCommands {
  @TextCommand({
    name: 'ping',
    description: 'Responds with pong!',
  })
  public onPing(
    @Context() [message]: TextCommandContext,
    @Arguments() args: string[],
  ) {
    return message.reply('pong!');
  }
}

```

#### Application commands [\#](https://docs.nestjs.com/recipes/necord\#application-commands)

Application commands provide a native way for users to interact with your app within the Discord client. There are three types of application commands that can be accessed through different interfaces: chat input, message context menu (accessed by right-clicking a message), and user context menu (accessed by right-clicking a user).

![](https://i.imgur.com/4EmG8G8.png)

#### Slash commands [\#](https://docs.nestjs.com/recipes/necord\#slash-commands)

Slash commands are an excellent way to engage with users in a structured manner. They allow you to create commands with precise arguments and options, enhancing the user experience significantly.

To define a slash command using Necord, you can use the `SlashCommand` decorator.

content\_copy app.commands.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, SlashCommand, SlashCommandContext } from 'necord';

@Injectable()
export class AppCommands {
  @SlashCommand({
    name: 'ping',
    description: 'Responds with pong!',
  })
  public async onPing(@Context() [interaction]: SlashCommandContext) {
    return interaction.reply({ content: 'Pong!' });
  }
}

```

> **Hint** When your bot client logs in, it will automatically register all defined commands. Note that global commands are cached for up to an hour. To avoid issues with the global cache, utilize the `development` argument in the Necord module, which restricts command visibility to a single guild.

##### Options

You can define parameters for your slash commands using option decorators. Let's create a `TextDto` class for this purpose:

content\_copy text.dto.ts

JS  TS

```typescript

import { StringOption } from 'necord';

export class TextDto {
  @StringOption({
    name: 'text',
    description: 'Input your text here',
    required: true,
  })
  text: string;
}

```

You can then use this DTO in the `AppCommands` class:

content\_copy app.commands.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, SlashCommand, Options, SlashCommandContext } from 'necord';
import { TextDto } from './length.dto';

@Injectable()
export class AppCommands {
  @SlashCommand({
    name: 'length',
    description: 'Calculate the length of your text',
  })
  public async onLength(
    @Context() [interaction]: SlashCommandContext,
    @Options() { text }: TextDto,
  ) {
    return interaction.reply({
      content: `The length of your text is: ${text.length}`,
    });
  }
}

```

For a complete list of built-in option decorators, check out [this documentation](https://necord.org/interactions/slash-commands#options).

##### Autocomplete

To implement autocomplete functionality for your slash commands, you'll need to create an interceptor. This interceptor will handle requests as users type in the autocomplete field.

content\_copy cats-autocomplete.interceptor.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { AutocompleteInteraction } from 'discord.js';
import { AutocompleteInterceptor } from 'necord';

@Injectable()
class CatsAutocompleteInterceptor extends AutocompleteInterceptor {
  public transformOptions(interaction: AutocompleteInteraction) {
    const focused = interaction.options.getFocused(true);
    let choices: string[];

    if (focused.name === 'cat') {
      choices = ['Siamese', 'Persian', 'Maine Coon'];
    }

    return interaction.respond(
      choices
        .filter((choice) => choice.startsWith(focused.value.toString()))
        .map((choice) => ({ name: choice, value: choice })),
    );
  }
}

```

You will also need to mark your options class with `autocomplete: true`:

content\_copy cat.dto.ts

JS  TS

```typescript

import { StringOption } from 'necord';

export class CatDto {
  @StringOption({
    name: 'cat',
    description: 'Choose a cat breed',
    autocomplete: true,
    required: true,
  })
  cat: string;
}

```

Finally, apply the interceptor to your slash command:

content\_copy cats.commands.ts

JS  TS

```typescript

import { Injectable, UseInterceptors } from '@nestjs/common';
import { Context, SlashCommand, Options, SlashCommandContext } from 'necord';
import { CatDto } from '/cat.dto';
import { CatsAutocompleteInterceptor } from './cats-autocomplete.interceptor';

@Injectable()
export class CatsCommands {
  @UseInterceptors(CatsAutocompleteInterceptor)
  @SlashCommand({
    name: 'cat',
    description: 'Retrieve information about a specific cat breed',
  })
  public async onSearch(
    @Context() [interaction]: SlashCommandContext,
    @Options() { cat }: CatDto,
  ) {
    return interaction.reply({
      content: `I found information on the breed of ${cat} cat!`,
    });
  }
}

```

#### User context menu [\#](https://docs.nestjs.com/recipes/necord\#user-context-menu)

User commands appear on the context menu that appears when right-clicking (or tapping) on users. These commands provide quick actions that target users directly.

content\_copy app.commands.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, UserCommand, UserCommandContext, TargetUser } from 'necord';
import { User } from 'discord.js';

@Injectable()
export class AppCommands {
  @UserCommand({ name: 'Get avatar' })
  public async getUserAvatar(
    @Context() [interaction]: UserCommandContext,
    @TargetUser() user: User,
  ) {
    return interaction.reply({
      embeds: [\
        new MessageEmbed()\
          .setTitle(`Avatar of ${user.username}`)\
          .setImage(user.displayAvatarURL({ size: 4096, dynamic: true })),\
      ],
    });
  }
}

```

#### Message context menu [\#](https://docs.nestjs.com/recipes/necord\#message-context-menu)

Message commands show up in the context menu when right-clicking on messages, allowing for quick actions relevant to those messages.

content\_copy app.commands.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, MessageCommand, MessageCommandContext, TargetMessage } from 'necord';
import { Message } from 'discord.js';

@Injectable()
export class AppCommands {
  @MessageCommand({ name: 'Copy Message' })
  public async copyMessage(
    @Context() [interaction]: MessageCommandContext,
    @TargetMessage() message: Message,
  ) {
    return interaction.reply({ content: message.content });
  }
}

```

#### Buttons [\#](https://docs.nestjs.com/recipes/necord\#buttons)

[Buttons](https://discord.com/developers/docs/interactions/message-components#buttons) are interactive elements that can be included in messages. When clicked, they send an [interaction](https://discord.com/developers/docs/interactions/receiving-and-responding#interaction-object) to your application.

content\_copy app.components.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, Button, ButtonContext } from 'necord';

@Injectable()
export class AppComponents {
  @Button('BUTTON')
  public onButtonClick(@Context() [interaction]: ButtonContext) {
    return interaction.reply({ content: 'Button clicked!' });
  }
}

```

#### Select menus [\#](https://docs.nestjs.com/recipes/necord\#select-menus)

[Select menus](https://discord.com/developers/docs/interactions/message-components#select-menus) are another type of interactive component that appears on messages. They provide a dropdown-like UI for users to select options.

content\_copy app.components.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, StringSelect, StringSelectContext, SelectedStrings } from 'necord';

@Injectable()
export class AppComponents {
  @StringSelect('SELECT_MENU')
  public onSelectMenu(
    @Context() [interaction]: StringSelectContext,
    @SelectedStrings() values: string[],
  ) {
    return interaction.reply({ content: `You selected: ${values.join(', ')}` });
  }
}

```

For a full list of built-in select menu components, visit [this link](https://necord.org/interactions/message-components#select-menu).

#### Modals [\#](https://docs.nestjs.com/recipes/necord\#modals)

Modals are pop-up forms that allow users to submit formatted input. Here's how to create and handle modals using Necord:

content\_copy app.modals.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Context, Modal, ModalContext } from 'necord';

@Injectable()
export class AppModals {
  @Modal('pizza')
  public onModal(@Context() [interaction]: ModalContext) {
    return interaction.reply({
      content: `Your fav pizza : ${interaction.fields.getTextInputValue('pizza')}`
    });
  }
}

```

#### More information [\#](https://docs.nestjs.com/recipes/necord\#more-information)

Visit the [Necord](https://necord.org/) website for more information.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Event Management
- [Events](https://docs.nestjs.com/techniques/events#events)
- [Getting started](https://docs.nestjs.com/techniques/events#getting-started)
- [Dispatching events](https://docs.nestjs.com/techniques/events#dispatching-events)
- [Listening to events](https://docs.nestjs.com/techniques/events#listening-to-events)
- [Preventing event loss](https://docs.nestjs.com/techniques/events#preventing-event-loss)
- [Example](https://docs.nestjs.com/techniques/events#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/events.md "Suggest Edits")

### Events

[Event Emitter](https://www.npmjs.com/package/@nestjs/event-emitter) package ( `@nestjs/event-emitter`) provides a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other.

`EventEmitterModule` internally uses the [eventemitter2](https://github.com/EventEmitter2/EventEmitter2) package.

#### Getting started [\#](https://docs.nestjs.com/techniques/events\#getting-started)

First install the required package:

```shell

$ npm i --save @nestjs/event-emitter

```

Once the installation is complete, import the `EventEmitterModule` into the root `AppModule` and run the `forRoot()` static method as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';

@Module({
  imports: [\
    EventEmitterModule.forRoot()\
  ],
})
export class AppModule {}

```

The `.forRoot()` call initializes the event emitter and registers any declarative event listeners that exist within your app. Registration occurs when the `onApplicationBootstrap` lifecycle hook occurs, ensuring that all modules have loaded and declared any scheduled jobs.

To configure the underlying `EventEmitter` instance, pass the configuration object to the `.forRoot()` method, as follows:

content\_copy

```typescript

EventEmitterModule.forRoot({
  // set this to `true` to use wildcards
  wildcard: false,
  // the delimiter used to segment namespaces
  delimiter: '.',
  // set this to `true` if you want to emit the newListener event
  newListener: false,
  // set this to `true` if you want to emit the removeListener event
  removeListener: false,
  // the maximum amount of listeners that can be assigned to an event
  maxListeners: 10,
  // show event name in memory leak message when more than maximum amount of listeners is assigned
  verboseMemoryLeak: false,
  // disable throwing uncaughtException if an error event is emitted and it has no listeners
  ignoreErrors: false,
});

```

#### Dispatching events [\#](https://docs.nestjs.com/techniques/events\#dispatching-events)

To dispatch (i.e., fire) an event, first inject `EventEmitter2` using standard constructor injection:

content\_copy

```typescript

constructor(private eventEmitter: EventEmitter2) {}

```

> **Hint** Import the `EventEmitter2` from the `@nestjs/event-emitter` package.

Then use it in a class as follows:

content\_copy

```typescript

this.eventEmitter.emit(
  'order.created',
  new OrderCreatedEvent({
    orderId: 1,
    payload: {},
  }),
);

```

#### Listening to events [\#](https://docs.nestjs.com/techniques/events\#listening-to-events)

To declare an event listener, decorate a method with the `@OnEvent()` decorator preceding the method definition containing the code to be executed, as follows:

content\_copy

```typescript

@OnEvent('order.created')
handleOrderCreatedEvent(payload: OrderCreatedEvent) {
  // handle and process "OrderCreatedEvent" event
}

```

> **Warning** Event subscribers cannot be request-scoped.

The first argument can be a `string` or `symbol` for a simple event emitter and a `string | symbol | Array<string | symbol>` in a case of a wildcard emitter.

The second argument (optional) is a listener options object as follows:

content\_copy

```typescript

export type OnEventOptions = OnOptions & {
  /**
   * If "true", prepends (instead of append) the given listener to the array of listeners.
   *
   * @see https://github.com/EventEmitter2/EventEmitter2#emitterprependlistenerevent-listener-options
   *
   * @default false
   */
  prependListener?: boolean;

  /**
   * If "true", the onEvent callback will not throw an error while handling the event. Otherwise, if "false" it will throw an error.
   *
   * @default true
   */
  suppressErrors?: boolean;
};

```

> **Hint** Read more about the `OnOptions` options object from [`eventemitter2`](https://github.com/EventEmitter2/EventEmitter2#emitteronevent-listener-options-objectboolean).

content\_copy

```typescript

@OnEvent('order.created', { async: true })
handleOrderCreatedEvent(payload: OrderCreatedEvent) {
  // handle and process "OrderCreatedEvent" event
}

```

To use namespaces/wildcards, pass the `wildcard` option into the `EventEmitterModule#forRoot()` method. When namespaces/wildcards are enabled, events can either be strings ( `foo.bar`) separated by a delimiter or arrays ( `['foo', 'bar']`). The delimiter is also configurable as a configuration property ( `delimiter`). With namespaces feature enabled, you can subscribe to events using a wildcard:

content\_copy

```typescript

@OnEvent('order.*')
handleOrderEvents(payload: OrderCreatedEvent | OrderRemovedEvent | OrderUpdatedEvent) {
  // handle and process an event
}

```

Note that such a wildcard only applies to one block. The argument `order.*` will match, for example, the events `order.created` and `order.shipped` but not `order.delayed.out_of_stock`. In order to listen to such events,
use the `multilevel wildcard` pattern (i.e, `**`), described in the `EventEmitter2` [documentation](https://github.com/EventEmitter2/EventEmitter2#multi-level-wildcards).

With this pattern, you can, for example, create an event listener that catches all events.

content\_copy

```typescript

@OnEvent('**')
handleEverything(payload: any) {
  // handle and process an event
}

```

> **Hint** `EventEmitter2` class provides several useful methods for interacting with events, like `waitFor` and `onAny`. You can read more about them [here](https://github.com/EventEmitter2/EventEmitter2).

#### Preventing event loss [\#](https://docs.nestjs.com/techniques/events\#preventing-event-loss)

Events triggered before or during the `onApplicationBootstrap` lifecycle hook—such as those from module constructors or the `onModuleInit` method—may be missed because the `EventSubscribersLoader` might not have finished setting up the listeners.

To avoid this issue, you can use the `waitUntilReady` method of the `EventEmitterReadinessWatcher`, which returns a promise that resolves once all listeners have been registered. This method can be called in the `onApplicationBootstrap` lifecycle hook of a module to ensure that all events are properly captured.

content\_copy

```typescript

await this.eventEmitterReadinessWatcher.waitUntilReady();
this.eventEmitter.emit(
  'order.created',
  new OrderCreatedEvent({ orderId: 1, payload: {} }),
);

```

> **Note** This is only necessary for events emitted before the `onApplicationBootstrap` lifecycle hook is complete.

#### Example [\#](https://docs.nestjs.com/techniques/events\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/30-event-emitter).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## OpenAPI Integration Guide
- [Introduction](https://docs.nestjs.com/openapi/introduction#introduction)
- [Installation](https://docs.nestjs.com/openapi/introduction#installation)
- [Bootstrap](https://docs.nestjs.com/openapi/introduction#bootstrap)
- [Document options](https://docs.nestjs.com/openapi/introduction#document-options)
- [Setup options](https://docs.nestjs.com/openapi/introduction#setup-options)
- [Example](https://docs.nestjs.com/openapi/introduction#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/introduction.md "Suggest Edits")

### Introduction

The [OpenAPI](https://swagger.io/specification/) specification is a language-agnostic definition format used to describe RESTful APIs. Nest provides a dedicated [module](https://github.com/nestjs/swagger) which allows generating such a specification by leveraging decorators.

#### Installation [\#](https://docs.nestjs.com/openapi/introduction\#installation)

To begin using it, we first install the required dependency.

```bash

$ npm install --save @nestjs/swagger

```

#### Bootstrap [\#](https://docs.nestjs.com/openapi/introduction\#bootstrap)

Once the installation process is complete, open the `main.ts` file and initialize Swagger using the `SwaggerModule` class:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
    .setTitle('Cats example')
    .setDescription('The cats API description')
    .setVersion('1.0')
    .addTag('cats')
    .build();
  const documentFactory = () => SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, documentFactory);

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

> **Hint** The factory method `SwaggerModule.createDocument()` is used specifically to generate the Swagger document when you request it. This approach helps save some initialization time, and the resulting document is a serializable object that conforms to the [OpenAPI Document](https://swagger.io/specification/#openapi-document) specification. Instead of serving the document over HTTP, you can also save it as a JSON or YAML file and use it in various ways.

The `DocumentBuilder` helps to structure a base document that conforms to the OpenAPI Specification. It provides several methods that allow setting such properties as title, description, version, etc. In order to create a full document (with all HTTP routes defined) we use the `createDocument()` method of the `SwaggerModule` class. This method takes two arguments, an application instance and a Swagger options object. Alternatively, we can provide a third argument, which should be of type `SwaggerDocumentOptions`. More on this in the [Document options section](https://docs.nestjs.com/openapi/introduction#document-options).

Once we create a document, we can call the `setup()` method. It accepts:

1. The path to mount the Swagger UI
2. An application instance
3. The document object instantiated above
4. Optional configuration parameter (read more [here](https://docs.nestjs.com/openapi/introduction#setup-options))

Now you can run the following command to start the HTTP server:

```bash

$ npm run start

```

While the application is running, open your browser and navigate to `http://localhost:3000/api`. You should see the Swagger UI.

![](https://docs.nestjs.com/assets/swagger1.png)

As you can see, the `SwaggerModule` automatically reflects all of your endpoints.

> **Hint** To generate and download a Swagger JSON file, navigate to `http://localhost:3000/api-json` (assuming that your Swagger documentation is available under `http://localhost:3000/api`).
> It is also possible to expose it on a route of your choice using only the setup method from `@nestjs/swagger`, like this:
> content\_copy
>
> ```typescript
>
> SwaggerModule.setup('swagger', app, documentFactory, {
>   jsonDocumentUrl: 'swagger/json',
> });
>
> ```
>
> Which would expose it at `http://localhost:3000/swagger/json`

> **Warning** When using `fastify` and `helmet`, there may be a problem with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), to solve this collision, configure the CSP as shown below:
> content\_copy
>
> ```typescript
>
> app.register(helmet, {
>   contentSecurityPolicy: {
>     directives: {
>       defaultSrc: [`'self'`],
>       styleSrc: [`'self'`, `'unsafe-inline'`],
>       imgSrc: [`'self'`, 'data:', 'validator.swagger.io'],
>       scriptSrc: [`'self'`, `https: 'unsafe-inline'`],
>     },
>   },
> });
>
> // If you are not going to use CSP at all, you can use this:
> app.register(helmet, {
>   contentSecurityPolicy: false,
> });
>
> ```

#### Document options [\#](https://docs.nestjs.com/openapi/introduction\#document-options)

When creating a document, it is possible to provide some extra options to fine tune the library's behavior. These options should be of type `SwaggerDocumentOptions`, which can be the following:

```typescript

export interface SwaggerDocumentOptions {
  /**
   * List of modules to include in the specification
   */
  include?: Function[];

  /**
   * Additional, extra models that should be inspected and included in the specification
   */
  extraModels?: Function[];

  /**
   * If `true`, swagger will ignore the global prefix set through `setGlobalPrefix()` method
   */
  ignoreGlobalPrefix?: boolean;

  /**
   * If `true`, swagger will also load routes from the modules imported by `include` modules
   */
  deepScanRoutes?: boolean;

  /**
   * Custom operationIdFactory that will be used to generate the `operationId`
   * based on the `controllerKey`, `methodKey`, and version.
   * @default () => controllerKey_methodKey_version
   */
  operationIdFactory?: OperationIdFactory;

  /**
   * Custom linkNameFactory that will be used to generate the name of links
   * in the `links` field of responses
   *
   * @see [Link objects](https://swagger.io/docs/specification/links/)
   *
   * @default () => `${controllerKey}_${methodKey}_from_${fieldKey}`
   */
  linkNameFactory?: (
    controllerKey: string,
    methodKey: string,
    fieldKey: string
  ) => string;

  /*
   * Generate tags automatically based on the controller name.
   * If `false`, you must use the `@ApiTags()` decorator to define tags.
   * Otherwise, the controller name without the suffix `Controller` will be used.
   * @default true
   */
  autoTagControllers?: boolean;
}

```

For example, if you want to make sure that the library generates operation names like `createUser` instead of `UsersController_createUser`, you can set the following:

```typescript

const options: SwaggerDocumentOptions =  {
  operationIdFactory: (
    controllerKey: string,
    methodKey: string
  ) => methodKey
};
const documentFactory = () => SwaggerModule.createDocument(app, config, options);

```

#### Setup options [\#](https://docs.nestjs.com/openapi/introduction\#setup-options)

You can configure Swagger UI by passing the options object which fulfills the `SwaggerCustomOptions` interface as a fourth argument of the `SwaggerModule#setup` method.

```typescript

export interface SwaggerCustomOptions {
  /**
   * If `true`, Swagger resources paths will be prefixed by the global prefix set through `setGlobalPrefix()`.
   * Default: `false`.
   * @see https://docs.nestjs.com/faq/global-prefix
   */
  useGlobalPrefix?: boolean;

  /**
   * If `false`, the Swagger UI will not be served. Only API definitions (JSON and YAML)
   * will be accessible (on `/{path}-json` and `/{path}-yaml`). To fully disable both the Swagger UI and API definitions, use `raw: false`.
   * Default: `true`.
   * @deprecated Use `ui` instead.
   */
  swaggerUiEnabled?: boolean;

  /**
   * If `false`, the Swagger UI will not be served. Only API definitions (JSON and YAML)
   * will be accessible (on `/{path}-json` and `/{path}-yaml`). To fully disable both the Swagger UI and API definitions, use `raw: false`.
   * Default: `true`.
   */
  ui?: boolean;

  /**
   * If `true`, raw definitions for all formats will be served.
   * Alternatively, you can pass an array to specify the formats to be served, e.g., `raw: ['json']` to serve only JSON definitions.
   * If omitted or set to an empty array, no definitions (JSON or YAML) will be served.
   * Use this option to control the availability of Swagger-related endpoints.
   * Default: `true`.
   */
  raw?: boolean | Array<'json' | 'yaml'>;

  /**
   * Url point the API definition to load in Swagger UI.
   */
  swaggerUrl?: string;

  /**
   * Path of the JSON API definition to serve.
   * Default: `<path>-json`.
   */
  jsonDocumentUrl?: string;

  /**
   * Path of the YAML API definition to serve.
   * Default: `<path>-yaml`.
   */
  yamlDocumentUrl?: string;

  /**
   * Hook allowing to alter the OpenAPI document before being served.
   * It's called after the document is generated and before it is served as JSON & YAML.
   */
  patchDocumentOnRequest?: <TRequest = any, TResponse = any>(
    req: TRequest,
    res: TResponse,
    document: OpenAPIObject
  ) => OpenAPIObject;

  /**
   * If `true`, the selector of OpenAPI definitions is displayed in the Swagger UI interface.
   * Default: `false`.
   */
  explorer?: boolean;

  /**
   * Additional Swagger UI options
   */
  swaggerOptions?: SwaggerUiOptions;

  /**
   * Custom CSS styles to inject in Swagger UI page.
   */
  customCss?: string;

  /**
   * URL(s) of a custom CSS stylesheet to load in Swagger UI page.
   */
  customCssUrl?: string | string[];

  /**
   * URL(s) of custom JavaScript files to load in Swagger UI page.
   */
  customJs?: string | string[];

  /**
   * Custom JavaScript scripts to load in Swagger UI page.
   */
  customJsStr?: string | string[];

  /**
   * Custom favicon for Swagger UI page.
   */
  customfavIcon?: string;

  /**
   * Custom title for Swagger UI page.
   */
  customSiteTitle?: string;

  /**
   * File system path (ex: ./node_modules/swagger-ui-dist) containing static Swagger UI assets.
   */
  customSwaggerUiPath?: string;

  /**
   * @deprecated This property has no effect.
   */
  validatorUrl?: string;

  /**
   * @deprecated This property has no effect.
   */
  url?: string;

  /**
   * @deprecated This property has no effect.
   */
  urls?: Record<'url' | 'name', string>[];
}

```

> **Hint** `ui` and `raw` are independent options. Disabling Swagger UI ( `ui: false`) does not disable API definitions (JSON/YAML). Conversely, disabling API definitions ( `raw: []`) does not disable the Swagger UI.
>
> For example, the following configuration will disable the Swagger UI but still allow access to API definitions:
>
> content\_copy
>
> ```typescript
>
> const options: SwaggerCustomOptions = {
>   ui: false, // Swagger UI is disabled
>   raw: ['json'], // JSON API definition is still accessible (YAML is disabled)
> };
> SwaggerModule.setup('api', app, options);
>
> ```
>
> In this case, [http://localhost:3000/api-json](http://localhost:3000/api-json) will still be accessible, but [http://localhost:3000/api](http://localhost:3000/api) (Swagger UI) will not.

#### Example [\#](https://docs.nestjs.com/openapi/introduction\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/11-swagger).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Complexity Management
- [Complexity](https://docs.nestjs.com/graphql/complexity#complexity)
- [Installation](https://docs.nestjs.com/graphql/complexity#installation)
- [Getting started](https://docs.nestjs.com/graphql/complexity#getting-started)
- [Field-level complexity](https://docs.nestjs.com/graphql/complexity#field-level-complexity)
- [Query/Mutation-level complexity](https://docs.nestjs.com/graphql/complexity#querymutation-level-complexity)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/complexity.md "Suggest Edits")

### Complexity

> **Warning** This chapter applies only to the code first approach.

Query complexity allows you to define how complex certain fields are, and to restrict queries with a **maximum complexity**. The idea is to define how complex each field is by using a simple number. A common default is to give each field a complexity of `1`. In addition, the complexity calculation of a GraphQL query can be customized with so-called complexity estimators. A complexity estimator is a simple function that calculates the complexity for a field. You can add any number of complexity estimators to the rule, which are then executed one after another. The first estimator that returns a numeric complexity value determines the complexity for that field.

The `@nestjs/graphql` package integrates very well with tools like [graphql-query-complexity](https://github.com/slicknode/graphql-query-complexity) that provides a cost analysis-based solution. With this library, you can reject queries to your GraphQL server that are deemed too costly to execute.

#### Installation [\#](https://docs.nestjs.com/graphql/complexity\#installation)

To begin using it, we first install the required dependency.

```bash

$ npm install --save graphql-query-complexity

```

#### Getting started [\#](https://docs.nestjs.com/graphql/complexity\#getting-started)

Once the installation process is complete, we can define the `ComplexityPlugin` class:

content\_copy

```typescript

import { GraphQLSchemaHost } from '@nestjs/graphql';
import { Plugin } from '@nestjs/apollo';
import {
  ApolloServerPlugin,
  BaseContext,
  GraphQLRequestListener,
} from '@apollo/server';
import { GraphQLError } from 'graphql';
import {
  fieldExtensionsEstimator,
  getComplexity,
  simpleEstimator,
} from 'graphql-query-complexity';

@Plugin()
export class ComplexityPlugin implements ApolloServerPlugin {
  constructor(private gqlSchemaHost: GraphQLSchemaHost) {}

  async requestDidStart(): Promise<GraphQLRequestListener<BaseContext>> {
    const maxComplexity = 20;
    const { schema } = this.gqlSchemaHost;

    return {
      async didResolveOperation({ request, document }) {
        const complexity = getComplexity({
          schema,
          operationName: request.operationName,
          query: document,
          variables: request.variables,
          estimators: [\
            fieldExtensionsEstimator(),\
            simpleEstimator({ defaultComplexity: 1 }),\
          ],
        });
        if (complexity > maxComplexity) {
          throw new GraphQLError(
            `Query is too complex: ${complexity}. Maximum allowed complexity: ${maxComplexity}`,
          );
        }
        console.log('Query Complexity:', complexity);
      },
    };
  }
}

```

For demonstration purposes, we specified the maximum allowed complexity as `20`. In the example above, we used 2 estimators, the `simpleEstimator` and the `fieldExtensionsEstimator`.

- `simpleEstimator`: the simple estimator returns a fixed complexity for each field
- `fieldExtensionsEstimator`: the field extensions estimator extracts the complexity value for each field of your schema

> **Hint** Remember to add this class to the providers array in any module.

#### Field-level complexity [\#](https://docs.nestjs.com/graphql/complexity\#field-level-complexity)

With this plugin in place, we can now define the complexity for any field by specifying the `complexity` property in the options object passed into the `@Field()` decorator, as follows:

content\_copy

```typescript

@Field({ complexity: 3 })
title: string;

```

Alternatively, you can define the estimator function:

content\_copy

```typescript

@Field({ complexity: (options: ComplexityEstimatorArgs) => ... })
title: string;

```

#### Query/Mutation-level complexity [\#](https://docs.nestjs.com/graphql/complexity\#querymutation-level-complexity)

In addition, `@Query()` and `@Mutation()` decorators may have a `complexity` property specified like so:

content\_copy

```typescript

@Query({ complexity: (options: ComplexityEstimatorArgs) => options.args.count * options.childComplexity })
items(@Args('count') count: number) {
  return this.itemsService.getItems({ count });
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Sentry Integration Guide
- [Sentry](https://docs.nestjs.com/recipes/sentry#sentry)
- [Installation](https://docs.nestjs.com/recipes/sentry#installation)
- [Basic setup](https://docs.nestjs.com/recipes/sentry#basic-setup)
- [Exception handling](https://docs.nestjs.com/recipes/sentry#exception-handling)
- [Readable stack traces](https://docs.nestjs.com/recipes/sentry#readable-stack-traces)
- [Testing the integration](https://docs.nestjs.com/recipes/sentry#testing-the-integration)
- [Summary](https://docs.nestjs.com/recipes/sentry#summary)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/sentry.md "Suggest Edits")

### Sentry

[Sentry](https://sentry.io/) is an error tracking and performance monitoring platform that helps developers identify and fix issues in real-time. This recipe shows how to integrate Sentry's [NestJS SDK](https://docs.sentry.io/platforms/javascript/guides/nestjs/) with your NestJS application.

#### Installation [\#](https://docs.nestjs.com/recipes/sentry\#installation)

First, install the required dependencies:

```bash

$ npm install --save @sentry/nestjs @sentry/profiling-node

```

> **Hint** `@sentry/profiling-node` is optional, but recommended for performance profiling.

#### Basic setup [\#](https://docs.nestjs.com/recipes/sentry\#basic-setup)

To get started with Sentry, you'll need to create a file named `instrument.ts` that should be imported before any other modules in your application:

content\_copy instrument.ts

JS  TS

```typescript

const Sentry = require("@sentry/nestjs");
const { nodeProfilingIntegration } = require("@sentry/profiling-node");

// Ensure to call this before requiring any other modules!
Sentry.init({
  dsn: SENTRY_DSN,
  integrations: [\
    // Add our Profiling integration\
    nodeProfilingIntegration(),\
  ],

  // Add Tracing by setting tracesSampleRate
  // We recommend adjusting this value in production
  tracesSampleRate: 1.0,

  // Set sampling rate for profiling
  // This is relative to tracesSampleRate
  profilesSampleRate: 1.0,
});

```

Update your `main.ts` file to import `instrument.ts` before other imports:

content\_copy main.ts

JS  TS

```typescript

// Import this first!
import "./instrument";

// Now import other modules
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}

bootstrap();

```

Afterwards, add the `SentryModule` as a root module to your main module:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from "@nestjs/common";
import { SentryModule } from "@sentry/nestjs/setup";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";

@Module({
  imports: [\
    SentryModule.forRoot(),\
    // ...other modules\
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

#### Exception handling [\#](https://docs.nestjs.com/recipes/sentry\#exception-handling)

If you're using a global catch-all exception filter (which is either a filter registered with `app.useGlobalFilters()` or a filter registered in your app module providers annotated with a `@Catch()` decorator without arguments), add a `@SentryExceptionCaptured()` decorator to the filter's `catch()` method. This decorator will report all unexpected errors that are received by your global error filter to Sentry:

content\_copy

```typescript

import { Catch, ExceptionFilter } from '@nestjs/common';
import { SentryExceptionCaptured } from '@sentry/nestjs';

@Catch()
export class YourCatchAllExceptionFilter implements ExceptionFilter {
  @SentryExceptionCaptured()
  catch(exception, host): void {
    // your implementation here
  }
}

```

By default, only unhandled exceptions that are not caught by an error filter are reported to Sentry. `HttpExceptions` (including [derivatives](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)) are also not captured by default because they mostly act as control flow vehicles.

If you don't have a global catch-all exception filter, add the `SentryGlobalFilter` to the providers of your main module. This filter will report any unhandled errors that aren't caught by other error filters to Sentry.

> **Warning** The `SentryGlobalFilter` needs to be registered before any other exception filters.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from "@nestjs/common";
import { APP_FILTER } from "@nestjs/core";
import { SentryGlobalFilter } from "@sentry/nestjs/setup";

@Module({
  providers: [\
    {\
      provide: APP_FILTER,\
      useClass: SentryGlobalFilter,\
    },\
    // ..other providers\
  ],
})
export class AppModule {}

```

#### Readable stack traces [\#](https://docs.nestjs.com/recipes/sentry\#readable-stack-traces)

Depending on how you've set up your project, the stack traces in your Sentry errors probably won't look like your actual code.

To fix this, upload your source maps to Sentry. The easiest way to do this is by using the Sentry Wizard:

```bash

npx @sentry/wizard@latest -i sourcemaps

```

#### Testing the integration [\#](https://docs.nestjs.com/recipes/sentry\#testing-the-integration)

To verify your Sentry integration is working, you can add a test endpoint that throws an error:

content\_copy

```typescript

@Get("debug-sentry")
getError() {
  throw new Error("My first Sentry error!");
}

```

Visit `/debug-sentry` in your application, and you should see the error appear in your Sentry dashboard.

### Summary

For complete documentation about Sentry's NestJS SDK, including advanced configuration options and features, visit the [official Sentry documentation](https://docs.sentry.io/platforms/javascript/guides/nestjs/).

While software bugs are Sentry's thing, we still write them. If you come across any problems while installing our SDK, please open a [GitHub Issue](https://github.com/getsentry/sentry-javascript/issues) or reach out on [Discord](https://discord.com/invite/sentry).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## SWC with NestJS
- [SWC](https://docs.nestjs.com/recipes/swc#swc)
- [Installation](https://docs.nestjs.com/recipes/swc#installation)
- [Getting started](https://docs.nestjs.com/recipes/swc#getting-started)
- [Type checking](https://docs.nestjs.com/recipes/swc#type-checking)
- [CLI Plugins (SWC)](https://docs.nestjs.com/recipes/swc#cli-plugins-swc)
- [SWC configuration](https://docs.nestjs.com/recipes/swc#swc-configuration)
- [Monorepo](https://docs.nestjs.com/recipes/swc#monorepo)
- [Monorepo and CLI plugins](https://docs.nestjs.com/recipes/swc#monorepo-and-cli-plugins)
- [Common pitfalls](https://docs.nestjs.com/recipes/swc#common-pitfalls)
- [Jest + SWC](https://docs.nestjs.com/recipes/swc#jest--swc)
- [Vitest](https://docs.nestjs.com/recipes/swc#vitest)
- [Installation](https://docs.nestjs.com/recipes/swc#installation-1)
- [Configuration](https://docs.nestjs.com/recipes/swc#configuration)
- [Path aliases](https://docs.nestjs.com/recipes/swc#path-aliases)
- [Update imports in E2E tests](https://docs.nestjs.com/recipes/swc#update-imports-in-e2e-tests)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/swc.md "Suggest Edits")

### SWC

[SWC](https://swc.rs/) (Speedy Web Compiler) is an extensible Rust-based platform that can be used for both compilation and bundling.
Using SWC with Nest CLI is a great and simple way to significantly speed up your development process.

> **Hint** SWC is approximately **x20 times faster** than the default TypeScript compiler.

#### Installation [\#](https://docs.nestjs.com/recipes/swc\#installation)

To get started, first install a few packages:

```bash

$ npm i --save-dev @swc/cli @swc/core

```

#### Getting started [\#](https://docs.nestjs.com/recipes/swc\#getting-started)

Once the installation process is complete, you can use the `swc` builder with Nest CLI, as follows:

```bash

$ nest start -b swc
# OR nest start --builder swc

```

> **Hint** If your repository is a monorepo, check out [this section](https://docs.nestjs.com/recipes/swc#monorepo).

Instead of passing the `-b` flag you can also just set the `compilerOptions.builder` property to `"swc"` in your `nest-cli.json` file, like so:

```json

{
  "compilerOptions": {
    "builder": "swc"
  }
}

```

To customize builder's behavior, you can pass an object containing two attributes, `type` ( `"swc"`) and `options`, as follows:

```json

{
  "compilerOptions": {
    "builder": {
      "type": "swc",
      "options": {
        "swcrcPath": "infrastructure/.swcrc",
      }
    }
  }
}

```

To run the application in watch mode, use the following command:

```bash

$ nest start -b swc -w
# OR nest start --builder swc --watch

```

#### Type checking [\#](https://docs.nestjs.com/recipes/swc\#type-checking)

SWC does not perform any type checking itself (as opposed to the default TypeScript compiler), so to turn it on, you need to use the `--type-check` flag:

```bash

$ nest start -b swc --type-check

```

This command will instruct the Nest CLI to run `tsc` in `noEmit` mode alongside SWC, which will asynchronously perform type checking. Again, instead of passing the `--type-check` flag you can also just set the `compilerOptions.typeCheck` property to `true` in your `nest-cli.json` file, like so:

```json

{
  "compilerOptions": {
    "builder": "swc",
    "typeCheck": true
  }
}

```

#### CLI Plugins (SWC) [\#](https://docs.nestjs.com/recipes/swc\#cli-plugins-swc)

The `--type-check` flag will automatically execute **NestJS CLI plugins** and produce a serialized metadata file which then can be loaded by the application at runtime.

#### SWC configuration [\#](https://docs.nestjs.com/recipes/swc\#swc-configuration)

SWC builder is pre-configured to match the requirements of NestJS applications. However, you can customize the configuration by creating a `.swcrc` file in the root directory and tweaking the options as you wish.

```json

{
  "$schema": "https://swc.rs/schema.json",
  "sourceMaps": true,
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true,
      "dynamicImport": true
    },
    "baseUrl": "./"
  },
  "minify": false
}

```

#### Monorepo [\#](https://docs.nestjs.com/recipes/swc\#monorepo)

If your repository is a monorepo, then instead of using `swc` builder you have to configure `webpack` to use `swc-loader`.

First, let's install the required package:

```bash

$ npm i --save-dev swc-loader

```

Once the installation is complete, create a `webpack.config.js` file in the root directory of your application with the following content:

```js

const swcDefaultConfig = require('@nestjs/cli/lib/compiler/defaults/swc-defaults').swcDefaultsFactory().swcOptions;

module.exports = {
  module: {
    rules: [\
      {\
        test: /\.ts$/,\
        exclude: /node_modules/,\
        use: {\
          loader: 'swc-loader',\
          options: swcDefaultConfig,\
        },\
      },\
    ],
  },
};

```

#### Monorepo and CLI plugins [\#](https://docs.nestjs.com/recipes/swc\#monorepo-and-cli-plugins)

Now if you use CLI plugins, `swc-loader` will not load them automatically. Instead, you have to create a separate file that will load them manually. To do so,
declare a `generate-metadata.ts` file near the `main.ts` file with the following content:

content\_copy

```ts

import { PluginMetadataGenerator } from '@nestjs/cli/lib/compiler/plugins/plugin-metadata-generator';
import { ReadonlyVisitor } from '@nestjs/swagger/dist/plugin';

const generator = new PluginMetadataGenerator();
generator.generate({
  visitors: [new ReadonlyVisitor({ introspectComments: true, pathToSource: __dirname })],
  outputDir: __dirname,
  watch: true,
  tsconfigPath: 'apps/<name>/tsconfig.app.json',
});

```

> **Hint** In this example we used `@nestjs/swagger` plugin, but you can use any plugin of your choice.

The `generate()` method accepts the following options:

| `watch` | Whether to watch the project for changes. |
| `tsconfigPath` | Path to the `tsconfig.json` file. Relative to the current working directory ( `process.cwd()`). |
| `outputDir` | Path to the directory where the metadata file will be saved. |
| `visitors` | An array of visitors that will be used to generate metadata. |
| `filename` | The name of the metadata file. Defaults to `metadata.ts`. |
| `printDiagnostics` | Whether to print diagnostics to the console. Defaults to `true`. |

Finally, you can run the `generate-metadata` script in a separate terminal window with the following command:

```bash

$ npx ts-node src/generate-metadata.ts
# OR npx ts-node apps/{YOUR_APP}/src/generate-metadata.ts

```

#### Common pitfalls [\#](https://docs.nestjs.com/recipes/swc\#common-pitfalls)

If you use TypeORM/MikroORM or any other ORM in your application, you may stumble upon circular import issues. SWC doesn't handle **circular imports** well, so you should use the following workaround:

content\_copy

```typescript

@Entity()
export class User {
  @OneToOne(() => Profile, (profile) => profile.user)
  profile: Relation<Profile>; // <--- see "Relation<>" type here instead of just "Profile"
}

```

> **Hint** `Relation` type is exported from the `typeorm` package.

Doing this prevents the type of the property from being saved in the transpiled code in the property metadata, preventing circular dependency issues.

If your ORM does not provide a similar workaround, you can define the wrapper type yourself:

content\_copy

```typescript

/**
 * Wrapper type used to circumvent ESM modules circular dependency issue
 * caused by reflection metadata saving the type of the property.
 */
export type WrapperType<T> = T; // WrapperType === Relation

```

For all [circular dependency injections](https://docs.nestjs.com/fundamentals/circular-dependency) in your project, you will also need to use the custom wrapper type described above:

content\_copy

```typescript

@Injectable()
export class UsersService {
  constructor(
    @Inject(forwardRef(() => ProfileService))
    private readonly profileService: WrapperType<ProfileService>,
  ) {};
}

```

### Jest + SWC

To use SWC with Jest, you need to install the following packages:

```bash

$ npm i --save-dev jest @swc/core @swc/jest

```

Once the installation is complete, update the `package.json`/ `jest.config.js` file (depending on your configuration) with the following content:

```json

{
  "jest": {
    "transform": {
      "^.+\\.(t|j)s?$": ["@swc/jest"]
    }
  }
}

```

Additionally you would need to add the following `transform` properties to your `.swcrc` file: `legacyDecorator`, `decoratorMetadata`:

```json

{
  "$schema": "https://swc.rs/schema.json",
  "sourceMaps": true,
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true,
      "dynamicImport": true
    },
    "transform": {
      "legacyDecorator": true,
      "decoratorMetadata": true
    },
    "baseUrl": "./"
  },
  "minify": false
}

```

If you use NestJS CLI Plugins in your project, you'll have to run `PluginMetadataGenerator` manually. Navigate to [this section](https://docs.nestjs.com/recipes/swc#monorepo-and-cli-plugins) to learn more.

### Vitest

[Vitest](https://vitest.dev/) is a fast and lightweight test runner designed to work with Vite. It provides a modern, fast, and easy-to-use testing solution that can be integrated with NestJS projects.

#### Installation [\#](https://docs.nestjs.com/recipes/swc\#installation-1)

To get started, first install the required packages:

```bash

$ npm i --save-dev vitest unplugin-swc @swc/core @vitest/coverage-v8

```

#### Configuration [\#](https://docs.nestjs.com/recipes/swc\#configuration)

Create a `vitest.config.ts` file in the root directory of your application with the following content:

content\_copy

```ts

import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    root: './',
  },
  plugins: [\
    // This is required to build the test files with SWC\
    swc.vite({\
      // Explicitly set the module type to avoid inheriting this value from a `.swcrc` config file\
      module: { type: 'es6' },\
    }),\
  ],
  resolve: {
    alias: {
      // Ensure Vitest correctly resolves TypeScript path aliases
      'src': resolve(__dirname, './src'),
    },
  },
});

```

This configuration file sets up the Vitest environment, root directory, and SWC plugin. You should also create a separate configuration
file for e2e tests, with an additional `include` field that specifies the test path regex:

content\_copy

```ts

import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: ['**/*.e2e-spec.ts'],
    globals: true,
    root: './',
  },
  plugins: [swc.vite()],
});

```

Additionally, you can set the `alias` options to support TypeScript paths in your tests:

content\_copy

```ts

import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: ['**/*.e2e-spec.ts'],
    globals: true,
    alias: {
      '@src': './src',
      '@test': './test',
    },
    root: './',
  },
  resolve: {
    alias: {
      '@src': './src',
      '@test': './test',
    },
  },
  plugins: [swc.vite()],
});

```

### Path aliases

Unlike Jest, Vitest does not automatically resolve TypeScript path aliases like `src/`. This may lead to dependency resolution errors during testing. To resolve this issue, add the following `resolve.alias` configuration in your `vitest.config.ts` file:

content\_copy

```ts

import { resolve } from 'path';

export default defineConfig({
  resolve: {
    alias: {
      'src': resolve(__dirname, './src'),
    },
  },
});

```

This ensures that Vitest correctly resolves module imports, preventing errors related to missing dependencies.

#### Update imports in E2E tests [\#](https://docs.nestjs.com/recipes/swc\#update-imports-in-e2e-tests)

Change any E2E test imports using `import * as request from 'supertest'` to `import request from 'supertest'`. This is necessary because Vitest, when bundled with Vite, expects a default import for supertest. Using a namespace import may cause issues in this specific setup.

Lastly, update the test scripts in your package.json file to the following:

```json

{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:cov": "vitest run --coverage",
    "test:debug": "vitest --inspect-brk --inspect --logHeapUsage --threads=false",
    "test:e2e": "vitest run --config ./vitest.config.e2e.ts"
  }
}

```

These scripts configure Vitest for running tests, watching for changes, generating code coverage reports, and debugging. The test:e2e script is specifically for running E2E tests with a custom configuration file.

With this setup, you can now enjoy the benefits of using Vitest in your NestJS project, including faster test execution and a more modern testing experience.

> **Hint** You can check out a working example in this [repository](https://github.com/TrilonIO/nest-vitest)

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## WebSocket Adapters in NestJS
- [Adapters](https://docs.nestjs.com/websockets/adapter#adapters)
- [Extend socket.io](https://docs.nestjs.com/websockets/adapter#extend-socketio)
- [Ws library](https://docs.nestjs.com/websockets/adapter#ws-library)
- [Advanced (custom adapter)](https://docs.nestjs.com/websockets/adapter#advanced-custom-adapter)
- [Example](https://docs.nestjs.com/websockets/adapter#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/websockets/adapter.md "Suggest Edits")

### Adapters

The WebSockets module is platform-agnostic, hence, you can bring your own library (or even a native implementation) by making use of `WebSocketAdapter` interface. This interface forces to implement few methods described in the following table:

|     |     |
| --- | --- |
| `create` | Creates a socket instance based on passed arguments |
| `bindClientConnect` | Binds the client connection event |
| `bindClientDisconnect` | Binds the client disconnection event (optional\*) |
| `bindMessageHandlers` | Binds the incoming message to the corresponding message handler |
| `close` | Terminates a server instance |

#### Extend socket.io [\#](https://docs.nestjs.com/websockets/adapter\#extend-socketio)

The [socket.io](https://github.com/socketio/socket.io) package is wrapped in an `IoAdapter` class. What if you would like to enhance the basic functionality of the adapter? For instance, your technical requirements require a capability to broadcast events across multiple load-balanced instances of your web service. For this, you can extend `IoAdapter` and override a single method which responsibility is to instantiate new socket.io servers. But first of all, let's install the required package.

> **Warning** To use socket.io with multiple load-balanced instances you either have to disable polling by setting `transports: ['websocket']` in your clients socket.io configuration or you have to enable cookie based routing in your load balancer. Redis alone is not enough. See [here](https://socket.io/docs/v4/using-multiple-nodes/#enabling-sticky-session) for more information.

```bash

$ npm i --save redis socket.io @socket.io/redis-adapter

```

Once the package is installed, we can create a `RedisIoAdapter` class.

content\_copy

```typescript

import { IoAdapter } from '@nestjs/platform-socket.io';
import { ServerOptions } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

export class RedisIoAdapter extends IoAdapter {
  private adapterConstructor: ReturnType<typeof createAdapter>;

  async connectToRedis(): Promise<void> {
    const pubClient = createClient({ url: `redis://localhost:6379` });
    const subClient = pubClient.duplicate();

    await Promise.all([pubClient.connect(), subClient.connect()]);

    this.adapterConstructor = createAdapter(pubClient, subClient);
  }

  createIOServer(port: number, options?: ServerOptions): any {
    const server = super.createIOServer(port, options);
    server.adapter(this.adapterConstructor);
    return server;
  }
}

```

Afterward, simply switch to your newly created Redis adapter.

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
const redisIoAdapter = new RedisIoAdapter(app);
await redisIoAdapter.connectToRedis();

app.useWebSocketAdapter(redisIoAdapter);

```

#### Ws library [\#](https://docs.nestjs.com/websockets/adapter\#ws-library)

Another available adapter is a `WsAdapter` which in turn acts like a proxy between the framework and integrate blazing fast and thoroughly tested [ws](https://github.com/websockets/ws) library. This adapter is fully compatible with native browser WebSockets and is far faster than socket.io package. Unluckily, it has significantly fewer functionalities available out-of-the-box. In some cases, you don't necessarily need them though.

> **Hint** `ws` library does not support namespaces (communication channels popularised by `socket.io`). However, to somehow mimic this feature, you can mount multiple `ws` servers on different paths (example: `@WebSocketGateway({ path: '/users' })`).

In order to use `ws`, we firstly have to install the required package:

```bash

$ npm i --save @nestjs/platform-ws

```

Once the package is installed, we can switch an adapter:

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
app.useWebSocketAdapter(new WsAdapter(app));

```

> **Hint** The `WsAdapter` is imported from `@nestjs/platform-ws`.

The `wsAdapter` is designed to handle messages in the `{ event: string, data: any }` format. If you need to receive and process messages in a different format, you'll need to configure a message parser to convert them into this required format.

content\_copy

```typescript

const wsAdapter = new WsAdapter(app, {
  // To handle messages in the [event, data] format
  messageParser: (data) => {
    const [event, payload] = JSON.parse(data.toString());
    return { event, data: payload };
  },
});

```

Alternatively, you can configure the message parser after the adapter is created by using the `setMessageParser` method.

#### Advanced (custom adapter) [\#](https://docs.nestjs.com/websockets/adapter\#advanced-custom-adapter)

For demonstration purposes, we are going to integrate the [ws](https://github.com/websockets/ws) library manually. As mentioned, the adapter for this library is already created and is exposed from the `@nestjs/platform-ws` package as a `WsAdapter` class. Here is how the simplified implementation could potentially look like:

content\_copy ws-adapter.ts

JS  TS

```typescript

import * as WebSocket from 'ws';
import { WebSocketAdapter, INestApplicationContext } from '@nestjs/common';
import { MessageMappingProperties } from '@nestjs/websockets';
import { Observable, fromEvent, EMPTY } from 'rxjs';
import { mergeMap, filter } from 'rxjs/operators';

export class WsAdapter implements WebSocketAdapter {
  constructor(private app: INestApplicationContext) {}

  create(port: number, options: any = {}): any {
    return new WebSocket.Server({ port, ...options });
  }

  bindClientConnect(server, callback: Function) {
    server.on('connection', callback);
  }

  bindMessageHandlers(
    client: WebSocket,
    handlers: MessageMappingProperties[],
    process: (data: any) => Observable<any>,
  ) {
    fromEvent(client, 'message')
      .pipe(
        mergeMap(data => this.bindMessageHandler(data, handlers, process)),
        filter(result => result),
      )
      .subscribe(response => client.send(JSON.stringify(response)));
  }

  bindMessageHandler(
    buffer,
    handlers: MessageMappingProperties[],
    process: (data: any) => Observable<any>,
  ): Observable<any> {
    const message = JSON.parse(buffer.data);
    const messageHandler = handlers.find(
      handler => handler.message === message.event,
    );
    if (!messageHandler) {
      return EMPTY;
    }
    return process(messageHandler.callback(message.data));
  }

  close(server) {
    server.close();
  }
}

```

> **Hint** When you want to take advantage of [ws](https://github.com/websockets/ws) library, use built-in `WsAdapter` instead of creating your own one.

Then, we can set up a custom adapter using `useWebSocketAdapter()` method:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.create(AppModule);
app.useWebSocketAdapter(new WsAdapter(app));

```

#### Example [\#](https://docs.nestjs.com/websockets/adapter\#example)

A working example that uses `WsAdapter` is available [here](https://github.com/nestjs/nest/tree/master/sample/16-gateways-ws).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Federation Guide
- [Federation](https://docs.nestjs.com/graphql/federation#federation)
- [Federation with Apollo](https://docs.nestjs.com/graphql/federation#federation-with-apollo)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first)
- [Federated example: Posts](https://docs.nestjs.com/graphql/federation#federated-example-posts)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first-1)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first-1)
- [Federated example: Gateway](https://docs.nestjs.com/graphql/federation#federated-example-gateway)
- [Federation with Mercurius](https://docs.nestjs.com/graphql/federation#federation-with-mercurius)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first-2)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first-2)
- [Federated example: Posts](https://docs.nestjs.com/graphql/federation#federated-example-posts-1)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first-3)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first-3)
- [Federated example: Gateway](https://docs.nestjs.com/graphql/federation#federated-example-gateway-1)
- [Federation 2](https://docs.nestjs.com/graphql/federation#federation-2)
- [Federated example: Users](https://docs.nestjs.com/graphql/federation#federated-example-users)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first-4)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first-4)
- [Federated example: Posts](https://docs.nestjs.com/graphql/federation#federated-example-posts-2)
- [Schema first](https://docs.nestjs.com/graphql/federation#schema-first-5)
- [Code first](https://docs.nestjs.com/graphql/federation#code-first-5)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/federation.md "Suggest Edits")

### Federation

Federation offers a means of splitting your monolithic GraphQL server into independent microservices. It consists of two components: a gateway and one or more federated microservices. Each microservice holds part of the schema and the gateway merges the schemas into a single schema that can be consumed by the client.

To quote the [Apollo docs](https://blog.apollographql.com/apollo-federation-f260cf525d21), Federation is designed with these core principles:

- Building a graph should be **declarative.** With federation, you compose a graph declaratively from within your schema instead of writing imperative schema stitching code.
- Code should be separated by **concern**, not by types. Often no single team controls every aspect of an important type like a User or Product, so the definition of these types should be distributed across teams and codebases, rather than centralized.
- The graph should be simple for clients to consume. Together, federated services can form a complete, product-focused graph that accurately reflects how it’s being consumed on the client.
- It’s just **GraphQL**, using only spec-compliant features of the language. Any language, not just JavaScript, can implement federation.

> **Warning** Federation currently does not support subscriptions.

In the following sections, we'll set up a demo application that consists of a gateway and two federated endpoints: Users service and Posts service.

#### Federation with Apollo [\#](https://docs.nestjs.com/graphql/federation\#federation-with-apollo)

Start by installing the required dependencies:

```bash

$ npm install --save @apollo/subgraph

```

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first)

The "User service" provides a simple schema. Note the `@key` directive: it instructs the Apollo query planner that a particular instance of `User` can be fetched if you specify its `id`. Also, note that we `extend` the `Query` type.

```graphql

type User @key(fields: "id") {
  id: ID!
  name: String!
}

extend type Query {
  getUser(id: ID!): User
}

```

Resolver provides one additional method named `resolveReference()`. This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the `@ResolveReference()` decorator.

content\_copy

```typescript

import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { UsersService } from './users.service';

@Resolver('User')
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query()
  getUser(@Args('id') id: string) {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: string }) {
    return this.usersService.findById(reference.id);
  }
}

```

Finally, we hook everything up by registering the `GraphQLModule` passing the `ApolloFederationDriver` driver in the configuration object:

content\_copy

```typescript

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { UsersResolver } from './users.resolver';

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      typePaths: ['**/*.graphql'],\
    }),\
  ],
  providers: [UsersResolver],
})
export class AppModule {}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first)

Start by adding some extra decorators to the `User` entity.

content\_copy

```ts

import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType()
@Directive('@key(fields: "id")')
export class User {
  @Field(() => ID)
  id: number;

  @Field()
  name: string;
}

```

Resolver provides one additional method named `resolveReference()`. This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the `@ResolveReference()` decorator.

content\_copy

```ts

import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { User } from './user.entity';
import { UsersService } from './users.service';

@Resolver(() => User)
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query(() => User)
  getUser(@Args('id') id: number): User {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: number }): User {
    return this.usersService.findById(reference.id);
  }
}

```

Finally, we hook everything up by registering the `GraphQLModule` passing the `ApolloFederationDriver` driver in the configuration object:

content\_copy

```typescript

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service'; // Not included in this example

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      autoSchemaFile: true,\
    }),\
  ],
  providers: [UsersResolver, UsersService],
})
export class AppModule {}

```

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/users-application) in code first mode and [here](https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/users-application) in schema first mode.

#### Federated example: Posts [\#](https://docs.nestjs.com/graphql/federation\#federated-example-posts)

Post service is supposed to serve aggregated posts through the `getPosts` query, but also extend our `User` type with the `user.posts` field.

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first-1)

"Posts service" references the `User` type in its schema by marking it with the `extend` keyword. It also declares one additional property on the `User` type ( `posts`). Note the `@key` directive used for matching instances of User, and the `@external` directive indicating that the `id` field is managed elsewhere.

```graphql

type Post @key(fields: "id") {
  id: ID!
  title: String!
  body: String!
  user: User
}

extend type User @key(fields: "id") {
  id: ID! @external
  posts: [Post]
}

extend type Query {
  getPosts: [Post]
}

```

In the following example, the `PostsResolver` provides the `getUser()` method that returns a reference containing `__typename` and some additional properties your application may need to resolve the reference, in this case `id`. `__typename` is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The "Users service" described above will be requested upon execution of the `resolveReference()` method.

content\_copy

```typescript

import { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './posts.interfaces';

@Resolver('Post')
export class PostsResolver {
  constructor(private postsService: PostsService) {}

  @Query('getPosts')
  getPosts() {
    return this.postsService.findAll();
  }

  @ResolveField('user')
  getUser(@Parent() post: Post) {
    return { __typename: 'User', id: post.userId };
  }
}

```

Lastly, we must register the `GraphQLModule`, similarly to what we did in the "Users service" section.

content\_copy

```typescript

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { PostsResolver } from './posts.resolver';

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      typePaths: ['**/*.graphql'],\
    }),\
  ],
  providers: [PostsResolvers],
})
export class AppModule {}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first-1)

First, we will have to declare a class representing the `User` entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the `@extends` and `@external` directives.

content\_copy

```ts

import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';
import { Post } from './post.entity';

@ObjectType()
@Directive('@extends')
@Directive('@key(fields: "id")')
export class User {
  @Field(() => ID)
  @Directive('@external')
  id: number;

  @Field(() => [Post])
  posts?: Post[];
}

```

Now let's create the corresponding resolver for our extension on the `User` entity, as follows:

content\_copy

```ts

import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './post.entity';
import { User } from './user.entity';

@Resolver(() => User)
export class UsersResolver {
  constructor(private readonly postsService: PostsService) {}

  @ResolveField(() => [Post])
  public posts(@Parent() user: User): Post[] {
    return this.postsService.forAuthor(user.id);
  }
}

```

We also have to define the `Post` entity class:

content\_copy

```ts

import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';
import { User } from './user.entity';

@ObjectType()
@Directive('@key(fields: "id")')
export class Post {
  @Field(() => ID)
  id: number;

  @Field()
  title: string;

  @Field(() => Int)
  authorId: number;

  @Field(() => User)
  user?: User;
}

```

And its resolver:

content\_copy

```ts

import { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './post.entity';
import { User } from './user.entity';

@Resolver(() => Post)
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {}

  @Query(() => Post)
  findPost(@Args('id') id: number): Post {
    return this.postsService.findOne(id);
  }

  @Query(() => [Post])
  getPosts(): Post[] {
    return this.postsService.all();
  }

  @ResolveField(() => User)
  user(@Parent() post: Post): any {
    return { __typename: 'User', id: post.authorId };
  }
}

```

And finally, tie it together in a module. Note the schema build options, where we specify that `User` is an orphaned (external) type.

content\_copy

```ts

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { User } from './user.entity';
import { PostsResolvers } from './posts.resolvers';
import { UsersResolvers } from './users.resolvers';
import { PostsService } from './posts.service'; // Not included in example

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      autoSchemaFile: true,\
      buildSchemaOptions: {\
        orphanedTypes: [User],\
      },\
    }),\
  ],
  providers: [PostsResolver, UsersResolver, PostsService],
})
export class AppModule {}

```

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/posts-application) for the code first mode and [here](https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/posts-application) for the schema first mode.

#### Federated example: Gateway [\#](https://docs.nestjs.com/graphql/federation\#federated-example-gateway)

Start by installing the required dependency:

```bash

$ npm install --save @apollo/gateway

```

The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway service will remain the same for both code and schema first approaches.

content\_copy

```typescript

import { IntrospectAndCompose } from '@apollo/gateway';
import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloGatewayDriverConfig>({\
      driver: ApolloGatewayDriver,\
      server: {\
        // ... Apollo server options\
        cors: true,\
      },\
      gateway: {\
        supergraphSdl: new IntrospectAndCompose({\
          subgraphs: [\
            { name: 'users', url: 'http://user-service/graphql' },\
            { name: 'posts', url: 'http://post-service/graphql' },\
          ],\
        }),\
      },\
    }),\
  ],
})
export class AppModule {}

```

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/gateway) for the code first mode and [here](https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/gateway) for the schema first mode.

#### Federation with Mercurius [\#](https://docs.nestjs.com/graphql/federation\#federation-with-mercurius)

Start by installing the required dependencies:

```bash

$ npm install --save @apollo/subgraph @nestjs/mercurius

```

> **Note** The `@apollo/subgraph` package is required to build a subgraph schema ( `buildSubgraphSchema`, `printSubgraphSchema` functions).

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first-2)

The "User service" provides a simple schema. Note the `@key` directive: it instructs the Mercurius query planner that a particular instance of `User` can be fetched if you specify its `id`. Also, note that we `extend` the `Query` type.

```graphql

type User @key(fields: "id") {
  id: ID!
  name: String!
}

extend type Query {
  getUser(id: ID!): User
}

```

Resolver provides one additional method named `resolveReference()`. This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the `@ResolveReference()` decorator.

content\_copy

```typescript

import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { UsersService } from './users.service';

@Resolver('User')
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query()
  getUser(@Args('id') id: string) {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: string }) {
    return this.usersService.findById(reference.id);
  }
}

```

Finally, we hook everything up by registering the `GraphQLModule` passing the `MercuriusFederationDriver` driver in the configuration object:

content\_copy

```typescript

import {
  MercuriusFederationDriver,
  MercuriusFederationDriverConfig,
} from '@nestjs/mercurius';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { UsersResolver } from './users.resolver';

@Module({
  imports: [\
    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\
      driver: MercuriusFederationDriver,\
      typePaths: ['**/*.graphql'],\
      federationMetadata: true,\
    }),\
  ],
  providers: [UsersResolver],
})
export class AppModule {}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first-2)

Start by adding some extra decorators to the `User` entity.

content\_copy

```ts

import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType()
@Directive('@key(fields: "id")')
export class User {
  @Field(() => ID)
  id: number;

  @Field()
  name: string;
}

```

Resolver provides one additional method named `resolveReference()`. This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the `@ResolveReference()` decorator.

content\_copy

```ts

import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { User } from './user.entity';
import { UsersService } from './users.service';

@Resolver(() => User)
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query(() => User)
  getUser(@Args('id') id: number): User {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: number }): User {
    return this.usersService.findById(reference.id);
  }
}

```

Finally, we hook everything up by registering the `GraphQLModule` passing the `MercuriusFederationDriver` driver in the configuration object:

content\_copy

```typescript

import {
  MercuriusFederationDriver,
  MercuriusFederationDriverConfig,
} from '@nestjs/mercurius';
import { Module } from '@nestjs/common';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service'; // Not included in this example

@Module({
  imports: [\
    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\
      driver: MercuriusFederationDriver,\
      autoSchemaFile: true,\
      federationMetadata: true,\
    }),\
  ],
  providers: [UsersResolver, UsersService],
})
export class AppModule {}

```

#### Federated example: Posts [\#](https://docs.nestjs.com/graphql/federation\#federated-example-posts-1)

Post service is supposed to serve aggregated posts through the `getPosts` query, but also extend our `User` type with the `user.posts` field.

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first-3)

"Posts service" references the `User` type in its schema by marking it with the `extend` keyword. It also declares one additional property on the `User` type ( `posts`). Note the `@key` directive used for matching instances of User, and the `@external` directive indicating that the `id` field is managed elsewhere.

```graphql

type Post @key(fields: "id") {
  id: ID!
  title: String!
  body: String!
  user: User
}

extend type User @key(fields: "id") {
  id: ID! @external
  posts: [Post]
}

extend type Query {
  getPosts: [Post]
}

```

In the following example, the `PostsResolver` provides the `getUser()` method that returns a reference containing `__typename` and some additional properties your application may need to resolve the reference, in this case `id`. `__typename` is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The "Users service" described above will be requested upon execution of the `resolveReference()` method.

content\_copy

```typescript

import { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './posts.interfaces';

@Resolver('Post')
export class PostsResolver {
  constructor(private postsService: PostsService) {}

  @Query('getPosts')
  getPosts() {
    return this.postsService.findAll();
  }

  @ResolveField('user')
  getUser(@Parent() post: Post) {
    return { __typename: 'User', id: post.userId };
  }
}

```

Lastly, we must register the `GraphQLModule`, similarly to what we did in the "Users service" section.

content\_copy

```typescript

import {
  MercuriusFederationDriver,
  MercuriusFederationDriverConfig,
} from '@nestjs/mercurius';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { PostsResolver } from './posts.resolver';

@Module({
  imports: [\
    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\
      driver: MercuriusFederationDriver,\
      federationMetadata: true,\
      typePaths: ['**/*.graphql'],\
    }),\
  ],
  providers: [PostsResolvers],
})
export class AppModule {}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first-3)

First, we will have to declare a class representing the `User` entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the `@extends` and `@external` directives.

content\_copy

```ts

import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';
import { Post } from './post.entity';

@ObjectType()
@Directive('@extends')
@Directive('@key(fields: "id")')
export class User {
  @Field(() => ID)
  @Directive('@external')
  id: number;

  @Field(() => [Post])
  posts?: Post[];
}

```

Now let's create the corresponding resolver for our extension on the `User` entity, as follows:

content\_copy

```ts

import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './post.entity';
import { User } from './user.entity';

@Resolver(() => User)
export class UsersResolver {
  constructor(private readonly postsService: PostsService) {}

  @ResolveField(() => [Post])
  public posts(@Parent() user: User): Post[] {
    return this.postsService.forAuthor(user.id);
  }
}

```

We also have to define the `Post` entity class:

content\_copy

```ts

import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';
import { User } from './user.entity';

@ObjectType()
@Directive('@key(fields: "id")')
export class Post {
  @Field(() => ID)
  id: number;

  @Field()
  title: string;

  @Field(() => Int)
  authorId: number;

  @Field(() => User)
  user?: User;
}

```

And its resolver:

content\_copy

```ts

import { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './post.entity';
import { User } from './user.entity';

@Resolver(() => Post)
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {}

  @Query(() => Post)
  findPost(@Args('id') id: number): Post {
    return this.postsService.findOne(id);
  }

  @Query(() => [Post])
  getPosts(): Post[] {
    return this.postsService.all();
  }

  @ResolveField(() => User)
  user(@Parent() post: Post): any {
    return { __typename: 'User', id: post.authorId };
  }
}

```

And finally, tie it together in a module. Note the schema build options, where we specify that `User` is an orphaned (external) type.

content\_copy

```ts

import {
  MercuriusFederationDriver,
  MercuriusFederationDriverConfig,
} from '@nestjs/mercurius';
import { Module } from '@nestjs/common';
import { User } from './user.entity';
import { PostsResolvers } from './posts.resolvers';
import { UsersResolvers } from './users.resolvers';
import { PostsService } from './posts.service'; // Not included in example

@Module({
  imports: [\
    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\
      driver: MercuriusFederationDriver,\
      autoSchemaFile: true,\
      federationMetadata: true,\
      buildSchemaOptions: {\
        orphanedTypes: [User],\
      },\
    }),\
  ],
  providers: [PostsResolver, UsersResolver, PostsService],
})
export class AppModule {}

```

#### Federated example: Gateway [\#](https://docs.nestjs.com/graphql/federation\#federated-example-gateway-1)

The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway service will remain the same for both code and schema first approaches.

content\_copy

```typescript

import {
  MercuriusGatewayDriver,
  MercuriusGatewayDriverConfig,
} from '@nestjs/mercurius';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [\
    GraphQLModule.forRoot<MercuriusGatewayDriverConfig>({\
      driver: MercuriusGatewayDriver,\
      gateway: {\
        services: [\
          { name: 'users', url: 'http://user-service/graphql' },\
          { name: 'posts', url: 'http://post-service/graphql' },\
        ],\
      },\
    }),\
  ],
})
export class AppModule {}

```

### Federation 2

To quote the [Apollo docs](https://www.apollographql.com/docs/federation/federation-2/new-in-federation-2), Federation 2 improves developer experience from the original Apollo Federation (called Federation 1 in this doc), which is backward compatible with most original supergraphs.

> **Warning** Mercurius doesn't fully support Federation 2. You can see the list of libraries that support Federation 2 [here](https://www.apollographql.com/docs/federation/supported-subgraphs#javascript--typescript).

In the following sections, we'll upgrade the previous example to Federation 2.

#### Federated example: Users [\#](https://docs.nestjs.com/graphql/federation\#federated-example-users)

One change in Federation 2 is that entities have no originating subgraph, so we don't need to extend `Query` anymore. For more detail please refer to [the entities topic](https://www.apollographql.com/docs/federation/federation-2/new-in-federation-2#entities) in Apollo Federation 2 docs.

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first-4)

We can simply remove `extend` keyword from the schema.

```graphql

type User @key(fields: "id") {
  id: ID!
  name: String!
}

type Query {
  getUser(id: ID!): User
}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first-4)

To use Federation 2, we need to specify the federation version in `autoSchemaFile` option.

content\_copy

```ts

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service'; // Not included in this example

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      autoSchemaFile: {\
        federation: 2,\
      },\
    }),\
  ],
  providers: [UsersResolver, UsersService],
})
export class AppModule {}

```

#### Federated example: Posts [\#](https://docs.nestjs.com/graphql/federation\#federated-example-posts-2)

With the same reason as above, we don't need to extend `User` and `Query` anymore.

#### Schema first [\#](https://docs.nestjs.com/graphql/federation\#schema-first-5)

We can simply remove `extend` and `external` directives from the schema

```graphql

type Post @key(fields: "id") {
  id: ID!
  title: String!
  body: String!
  user: User
}

type User @key(fields: "id") {
  id: ID!
  posts: [Post]
}

type Query {
  getPosts: [Post]
}

```

#### Code first [\#](https://docs.nestjs.com/graphql/federation\#code-first-5)

Since we don't extend `User` entity anymore, we can simply remove `extends` and `external` directives from `User`.

content\_copy

```ts

import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';
import { Post } from './post.entity';

@ObjectType()
@Directive('@key(fields: "id")')
export class User {
  @Field(() => ID)
  id: number;

  @Field(() => [Post])
  posts?: Post[];
}

```

Also, similarly to the User service, we need to specify in the `GraphQLModule` to use Federation 2.

content\_copy

```ts

import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { User } from './user.entity';
import { PostsResolvers } from './posts.resolvers';
import { UsersResolvers } from './users.resolvers';
import { PostsService } from './posts.service'; // Not included in example

@Module({
  imports: [\
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\
      driver: ApolloFederationDriver,\
      autoSchemaFile: {\
        federation: 2,\
      },\
      buildSchemaOptions: {\
        orphanedTypes: [User],\
      },\
    }),\
  ],
  providers: [PostsResolver, UsersResolver, PostsService],
})
export class AppModule {}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Microservices Interceptors
- [Interceptors](https://docs.nestjs.com/microservices/interceptors#interceptors)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/interceptors.md "Suggest Edits")

### Interceptors

There is no difference between [regular interceptors](https://docs.nestjs.com/interceptors) and microservices interceptors. The following example uses a manually instantiated method-scoped interceptor. Just as with HTTP based applications, you can also use controller-scoped interceptors (i.e., prefix the controller class with a `@UseInterceptors()` decorator).

content\_copy

JS  TS

```typescript

@UseInterceptors(new TransformInterceptor())
@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): number {
  return (data || []).reduce((a, b) => a + b);
}

```

```typescript

@UseInterceptors(new TransformInterceptor())
@MessagePattern({ cmd: 'sum' })
accumulate(data) {
  return (data || []).reduce((a, b) => a + b);
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NATS Microservices Guide
- [NATS](https://docs.nestjs.com/microservices/nats#nats)
- [Installation](https://docs.nestjs.com/microservices/nats#installation)
- [Overview](https://docs.nestjs.com/microservices/nats#overview)
- [Options](https://docs.nestjs.com/microservices/nats#options)
- [Client](https://docs.nestjs.com/microservices/nats#client)
- [Request-response](https://docs.nestjs.com/microservices/nats#request-response)
- [Event-based](https://docs.nestjs.com/microservices/nats#event-based)
- [Queue groups](https://docs.nestjs.com/microservices/nats#queue-groups)
- [Context](https://docs.nestjs.com/microservices/nats#context)
- [Wildcards](https://docs.nestjs.com/microservices/nats#wildcards)
- [Record builders](https://docs.nestjs.com/microservices/nats#record-builders)
- [Instance status updates](https://docs.nestjs.com/microservices/nats#instance-status-updates)
- [Listening to Nats events](https://docs.nestjs.com/microservices/nats#listening-to-nats-events)
- [Underlying driver access](https://docs.nestjs.com/microservices/nats#underlying-driver-access)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/nats.md "Suggest Edits")

### NATS

[NATS](https://nats.io/) is a simple, secure and high performance open source messaging system for cloud native applications, IoT messaging, and microservices architectures. The NATS server is written in the Go programming language, but client libraries to interact with the server are available for dozens of major programming languages. NATS supports both **At Most Once** and **At Least Once** delivery. It can run anywhere, from large servers and cloud instances, through edge gateways and even Internet of Things devices.

#### Installation [\#](https://docs.nestjs.com/microservices/nats\#installation)

To start building NATS-based microservices, first install the required package:

```bash

$ npm i --save nats

```

#### Overview [\#](https://docs.nestjs.com/microservices/nats\#overview)

To use the NATS transporter, pass the following options object to the `createMicroservice()` method:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.NATS,
  options: {
    servers: ['nats://localhost:4222'],
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.NATS,
  options: {
    servers: ['nats://localhost:4222'],
  },
});

```

> **Hint** The `Transport` enum is imported from the `@nestjs/microservices` package.

#### Options [\#](https://docs.nestjs.com/microservices/nats\#options)

The `options` object is specific to the chosen transporter. The **NATS** transporter exposes the properties described [here](https://github.com/nats-io/node-nats#connection-options) as well as the following properties:

|     |     |
| --- | --- |
| `queue` | Queue that your server should subscribe to (leave `undefined` to ignore this setting). Read more about NATS queue groups [below](https://docs.nestjs.com/microservices/nats#queue-groups). |
| `gracefulShutdown` | Enables graceful shutdown. When enabled, the server first unsubscribes from all channels before closing the connection. Default is `false`. |
| `gracePeriod` | Time in milliseconds to wait for the server after unsubscribing from all channels. Default is `10000` ms. |

#### Client [\#](https://docs.nestjs.com/microservices/nats\#client)

Like other microservice transporters, you have [several options](https://docs.nestjs.com/microservices/basics#client) for creating a NATS `ClientProxy` instance.

One method for creating an instance is to use the `ClientsModule`. To create a client instance with the `ClientsModule`, import it and use the `register()` method to pass an options object with the same properties shown above in the `createMicroservice()` method, as well as a `name` property to be used as the injection token. Read more about `ClientsModule` [here](https://docs.nestjs.com/microservices/basics#client).

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'MATH_SERVICE',\
        transport: Transport.NATS,\
        options: {\
          servers: ['nats://localhost:4222'],\
        }\
      },\
    ]),\
  ]
  ...
})

```

Other options to create a client (either `ClientProxyFactory` or `@Client()`) can be used as well. You can read about them [here](https://docs.nestjs.com/microservices/basics#client).

#### Request-response [\#](https://docs.nestjs.com/microservices/nats\#request-response)

For the **request-response** message style ( [read more](https://docs.nestjs.com/microservices/basics#request-response)), the NATS transporter does not use the NATS built-in [Request-Reply](https://docs.nats.io/nats-concepts/reqreply) mechanism. Instead, a "request" is published on a given subject using the `publish()` method with a unique reply subject name, and responders listen on that subject and send responses to the reply subject. Reply subjects are directed back to the requestor dynamically, regardless of location of either party.

#### Event-based [\#](https://docs.nestjs.com/microservices/nats\#event-based)

For the **event-based** message style ( [read more](https://docs.nestjs.com/microservices/basics#event-based)), the NATS transporter uses NATS built-in [Publish-Subscribe](https://docs.nats.io/nats-concepts/pubsub) mechanism. A publisher sends a message on a subject and any active subscriber listening on that subject receives the message. Subscribers can also register interest in wildcard subjects that work a bit like a regular expression. This one-to-many pattern is sometimes called fan-out.

#### Queue groups [\#](https://docs.nestjs.com/microservices/nats\#queue-groups)

NATS provides a built-in load balancing feature called [distributed queues](https://docs.nats.io/nats-concepts/queue). To create a queue subscription, use the `queue` property as follows:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.NATS,
  options: {
    servers: ['nats://localhost:4222'],
    queue: 'cats_queue',
  },
});

```

#### Context [\#](https://docs.nestjs.com/microservices/nats\#context)

In more complex scenarios, you may need to access additional information about the incoming request. When using the NATS transporter, you can access the `NatsContext` object.

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: NatsContext) {
  console.log(`Subject: ${context.getSubject()}`);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(`Subject: ${context.getSubject()}`);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `NatsContext` are imported from the `@nestjs/microservices` package.

#### Wildcards [\#](https://docs.nestjs.com/microservices/nats\#wildcards)

A subscription may be to an explicit subject, or it may include wildcards.

content\_copy

JS  TS

```typescript

@MessagePattern('time.us.*')
getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('time.us.*')
getDate(data, context) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}

```

#### Record builders [\#](https://docs.nestjs.com/microservices/nats\#record-builders)

To configure message options, you can use the `NatsRecordBuilder` class (note: this is doable for event-based flows as well). For example, to add `x-version` header, use the `setHeaders` method, as follows:

content\_copy

```typescript

import * as nats from 'nats';

// somewhere in your code
const headers = nats.headers();
headers.set('x-version', '1.0.0');

const record = new NatsRecordBuilder(':cat:').setHeaders(headers).build();
this.client.send('replace-emoji', record).subscribe(...);

```

> **Hint** `NatsRecordBuilder` class is exported from the `@nestjs/microservices` package.

And you can read these headers on the server-side as well, by accessing the `NatsContext`, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('replace-emoji')
replaceEmoji(@Payload() data: string, @Ctx() context: NatsContext): string {
  const headers = context.getHeaders();
  return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('replace-emoji')
replaceEmoji(data, context) {
  const headers = context.getHeaders();
  return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
}

```

In some cases you might want to configure headers for multiple requests, you can pass these as options to the `ClientProxyFactory`:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { ClientProxyFactory, Transport } from '@nestjs/microservices';

@Module({
  providers: [\
    {\
      provide: 'API_v1',\
      useFactory: () =>\
        ClientProxyFactory.create({\
          transport: Transport.NATS,\
          options: {\
            servers: ['nats://localhost:4222'],\
            headers: { 'x-version': '1.0.0' },\
          },\
        }),\
    },\
  ],
})
export class ApiModule {}

```

#### Instance status updates [\#](https://docs.nestjs.com/microservices/nats\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For the NATS driver, the `status` stream emits `connected`, `disconnected`, and `reconnecting` events.

content\_copy

```typescript

this.client.status.subscribe((status: NatsStatus) => {
  console.log(status);
});

```

> **Hint** The `NatsStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: NatsStatus) => {
  console.log(status);
});

```

#### Listening to Nats events [\#](https://docs.nestjs.com/microservices/nats\#listening-to-nats-events)

In some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the `error` event to trigger additional operations when an error occurs. To do this, use the `on()` method, as shown below:

content\_copy

```typescript

this.client.on('error', (err) => {
  console.error(err);
});

```

Similarly, you can listen to the server's internal events:

content\_copy

```typescript

server.on<NatsEvents>('error', (err) => {
  console.error(err);
});

```

> **Hint** The `NatsEvents` type is imported from the `@nestjs/microservices` package.

#### Underlying driver access [\#](https://docs.nestjs.com/microservices/nats\#underlying-driver-access)

For more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use the `unwrap()` method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.

content\_copy

```typescript

const natsConnection = this.client.unwrap<import('nats').NatsConnection>();

```

Similarly, you can access the server's underlying driver instance:

content\_copy

```typescript

const natsConnection = server.unwrap<import('nats').NatsConnection>();

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## OpenAPI Operations Guide
- [Operations](https://docs.nestjs.com/openapi/operations#operations)
- [Tags](https://docs.nestjs.com/openapi/operations#tags)
- [Headers](https://docs.nestjs.com/openapi/operations#headers)
- [Responses](https://docs.nestjs.com/openapi/operations#responses)
- [File upload](https://docs.nestjs.com/openapi/operations#file-upload)
- [Extensions](https://docs.nestjs.com/openapi/operations#extensions)
- [Advanced: Generic ApiResponse](https://docs.nestjs.com/openapi/operations#advanced-generic-apiresponse)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/operations.md "Suggest Edits")

### Operations

In OpenAPI terms, paths are endpoints (resources), such as `/users` or `/reports/summary`, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as `GET`, `POST` or `DELETE`.

#### Tags [\#](https://docs.nestjs.com/openapi/operations\#tags)

To attach a controller to a specific tag, use the `@ApiTags(...tags)` decorator.

content\_copy

```typescript

@ApiTags('cats')
@Controller('cats')
export class CatsController {}

```

#### Headers [\#](https://docs.nestjs.com/openapi/operations\#headers)

To define custom headers that are expected as part of the request, use `@ApiHeader()`.

content\_copy

```typescript

@ApiHeader({
  name: 'X-MyHeader',
  description: 'Custom header',
})
@Controller('cats')
export class CatsController {}

```

#### Responses [\#](https://docs.nestjs.com/openapi/operations\#responses)

To define a custom HTTP response, use the `@ApiResponse()` decorator.

content\_copy

```typescript

@Post()
@ApiResponse({ status: 201, description: 'The record has been successfully created.'})
@ApiResponse({ status: 403, description: 'Forbidden.'})
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

Nest provides a set of short-hand **API response** decorators that inherit from the `@ApiResponse` decorator:

- `@ApiOkResponse()`
- `@ApiCreatedResponse()`
- `@ApiAcceptedResponse()`
- `@ApiNoContentResponse()`
- `@ApiMovedPermanentlyResponse()`
- `@ApiFoundResponse()`
- `@ApiBadRequestResponse()`
- `@ApiUnauthorizedResponse()`
- `@ApiNotFoundResponse()`
- `@ApiForbiddenResponse()`
- `@ApiMethodNotAllowedResponse()`
- `@ApiNotAcceptableResponse()`
- `@ApiRequestTimeoutResponse()`
- `@ApiConflictResponse()`
- `@ApiPreconditionFailedResponse()`
- `@ApiTooManyRequestsResponse()`
- `@ApiGoneResponse()`
- `@ApiPayloadTooLargeResponse()`
- `@ApiUnsupportedMediaTypeResponse()`
- `@ApiUnprocessableEntityResponse()`
- `@ApiInternalServerErrorResponse()`
- `@ApiNotImplementedResponse()`
- `@ApiBadGatewayResponse()`
- `@ApiServiceUnavailableResponse()`
- `@ApiGatewayTimeoutResponse()`
- `@ApiDefaultResponse()`

content\_copy

```typescript

@Post()
@ApiCreatedResponse({ description: 'The record has been successfully created.'})
@ApiForbiddenResponse({ description: 'Forbidden.'})
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

```

To specify a return model for a request, we must create a class and annotate all properties with the `@ApiProperty()` decorator.

content\_copy

```typescript

export class Cat {
  @ApiProperty()
  id: number;

  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
}

```

Then the `Cat` model can be used in combination with the `type` property of the response decorator.

content\_copy

```typescript

@ApiTags('cats')
@Controller('cats')
export class CatsController {
  @Post()
  @ApiCreatedResponse({
    description: 'The record has been successfully created.',
    type: Cat,
  })
  async create(@Body() createCatDto: CreateCatDto): Promise<Cat> {
    return this.catsService.create(createCatDto);
  }
}

```

Let's open the browser and verify the generated `Cat` model:

![](https://docs.nestjs.com/assets/swagger-response-type.png)

Instead of defining responses for each endpoint or controller individually, you can define a global response for all endpoints using the `DocumentBuilder` class. This approach is useful when you want to define a global response for all endpoints in your application (e.g., for errors like `401 Unauthorized` or `500 Internal Server Error`).

content\_copy

```typescript

const config = new DocumentBuilder()
  .addGlobalResponse({
    status: 500,
    description: 'Internal server error',
  })
  // other configurations
  .build();

```

#### File upload [\#](https://docs.nestjs.com/openapi/operations\#file-upload)

You can enable file upload for a specific method with the `@ApiBody` decorator together with `@ApiConsumes()`. Here's a full example using the [File Upload](https://docs.nestjs.com/techniques/file-upload) technique:

content\_copy

```typescript

@UseInterceptors(FileInterceptor('file'))
@ApiConsumes('multipart/form-data')
@ApiBody({
  description: 'List of cats',
  type: FileUploadDto,
})
uploadFile(@UploadedFile() file: Express.Multer.File) {}

```

Where `FileUploadDto` is defined as follows:

content\_copy

```typescript

class FileUploadDto {
  @ApiProperty({ type: 'string', format: 'binary' })
  file: any;
}

```

To handle multiple files uploading, you can define `FilesUploadDto` as follows:

content\_copy

```typescript

class FilesUploadDto {
  @ApiProperty({ type: 'array', items: { type: 'string', format: 'binary' } })
  files: any[];
}

```

#### Extensions [\#](https://docs.nestjs.com/openapi/operations\#extensions)

To add an Extension to a request use the `@ApiExtension()` decorator. The extension name must be prefixed with `x-`.

content\_copy

```typescript

@ApiExtension('x-foo', { hello: 'world' })

```

#### Advanced: Generic `ApiResponse` [\#](https://docs.nestjs.com/openapi/operations\#advanced-generic-apiresponse)

With the ability to provide [Raw Definitions](https://docs.nestjs.com/openapi/types-and-parameters#raw-definitions), we can define Generic schema for Swagger UI. Assume we have the following DTO:

content\_copy

```ts

export class PaginatedDto<TData> {
  @ApiProperty()
  total: number;

  @ApiProperty()
  limit: number;

  @ApiProperty()
  offset: number;

  results: TData[];
}

```

We skip decorating `results` as we will be providing a raw definition for it later. Now, let's define another DTO and name it, for example, `CatDto`, as follows:

content\_copy

```ts

export class CatDto {
  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
}

```

With this in place, we can define a `PaginatedDto<CatDto>` response, as follows:

content\_copy

```ts

@ApiOkResponse({
  schema: {
    allOf: [\
      { $ref: getSchemaPath(PaginatedDto) },\
      {\
        properties: {\
          results: {\
            type: 'array',\
            items: { $ref: getSchemaPath(CatDto) },\
          },\
        },\
      },\
    ],
  },
})
async findAll(): Promise<PaginatedDto<CatDto>> {}

```

In this example, we specify that the response will have allOf `PaginatedDto` and the `results` property will be of type `Array<CatDto>`.

- `getSchemaPath()` function that returns the OpenAPI Schema path from within the OpenAPI Spec File for a given model.
- `allOf` is a concept that OAS 3 provides to cover various Inheritance related use-cases.

Lastly, since `PaginatedDto` is not directly referenced by any controller, the `SwaggerModule` will not be able to generate a corresponding model definition just yet. In this case, we must add it as an [Extra Model](https://docs.nestjs.com/openapi/types-and-parameters#extra-models). For example, we can use the `@ApiExtraModels()` decorator on the controller level, as follows:

content\_copy

```ts

@Controller('cats')
@ApiExtraModels(PaginatedDto)
export class CatsController {}

```

If you run Swagger now, the generated `swagger.json` for this specific endpoint should have the following response defined:

```json

"responses": {
  "200": {
    "description": "",
    "content": {
      "application/json": {
        "schema": {
          "allOf": [\
            {\
              "$ref": "#/components/schemas/PaginatedDto"\
            },\
            {\
              "properties": {\
                "results": {\
                  "$ref": "#/components/schemas/CatDto"\
                }\
              }\
            }\
          ]
        }
      }
    }
  }
}

```

To make it reusable, we can create a custom decorator for `PaginatedDto`, as follows:

content\_copy

```ts

export const ApiPaginatedResponse = <TModel extends Type<any>>(
  model: TModel,
) => {
  return applyDecorators(
    ApiExtraModels(PaginatedDto, model),
    ApiOkResponse({
      schema: {
        allOf: [\
          { $ref: getSchemaPath(PaginatedDto) },\
          {\
            properties: {\
              results: {\
                type: 'array',\
                items: { $ref: getSchemaPath(model) },\
              },\
            },\
          },\
        ],
      },
    }),
  );
};

```

> **Hint** `Type<any>` interface and `applyDecorators` function are imported from the `@nestjs/common` package.

To ensure that `SwaggerModule` will generate a definition for our model, we must add it as an extra model, like we did earlier with the `PaginatedDto` in the controller.

With this in place, we can use the custom `@ApiPaginatedResponse()` decorator on our endpoint:

content\_copy

```ts

@ApiPaginatedResponse(CatDto)
async findAll(): Promise<PaginatedDto<CatDto>> {}

```

For client generation tools, this approach poses an ambiguity in how the `PaginatedResponse<TModel>` is being generated for the client. The following snippet is an example of a client generator result for the above `GET /` endpoint.

content\_copy

```typescript

// Angular
findAll(): Observable<{ total: number, limit: number, offset: number, results: CatDto[] }>

```

As you can see, the **Return Type** here is ambiguous. To workaround this issue, you can add a `title` property to the `schema` for `ApiPaginatedResponse`:

content\_copy

```typescript

export const ApiPaginatedResponse = <TModel extends Type<any>>(
  model: TModel,
) => {
  return applyDecorators(
    ApiOkResponse({
      schema: {
        title: `PaginatedResponseOf${model.name}`,
        allOf: [\
          // ...\
        ],
      },
    }),
  );
};

```

Now the result of the client generator tool will become:

content\_copy

```ts

// Angular
findAll(): Observable<PaginatedResponseOfCatDto>

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Redis Microservices Guide
- [Redis](https://docs.nestjs.com/microservices/redis#redis)
- [Installation](https://docs.nestjs.com/microservices/redis#installation)
- [Overview](https://docs.nestjs.com/microservices/redis#overview)
- [Options](https://docs.nestjs.com/microservices/redis#options)
- [Client](https://docs.nestjs.com/microservices/redis#client)
- [Context](https://docs.nestjs.com/microservices/redis#context)
- [Wildcards](https://docs.nestjs.com/microservices/redis#wildcards)
- [Instance status updates](https://docs.nestjs.com/microservices/redis#instance-status-updates)
- [Listening to Redis events](https://docs.nestjs.com/microservices/redis#listening-to-redis-events)
- [Underlying driver access](https://docs.nestjs.com/microservices/redis#underlying-driver-access)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/redis.md "Suggest Edits")

### Redis

The [Redis](https://redis.io/) transporter implements the publish/subscribe messaging paradigm and leverages the [Pub/Sub](https://redis.io/topics/pubsub) feature of Redis. Published messages are categorized in channels, without knowing what subscribers (if any) will eventually receive the message. Each microservice can subscribe to any number of channels. In addition, more than one channel can be subscribed to at a time. Messages exchanged through channels are **fire-and-forget**, which means that if a message is published and there are no subscribers interested in it, the message is removed and cannot be recovered. Thus, you don't have a guarantee that either messages or events will be handled by at least one service. A single message can be subscribed to (and received) by multiple subscribers.

![](https://docs.nestjs.com/assets/Redis_1.png)

#### Installation [\#](https://docs.nestjs.com/microservices/redis\#installation)

To start building Redis-based microservices, first install the required package:

```bash

$ npm i --save ioredis

```

#### Overview [\#](https://docs.nestjs.com/microservices/redis\#overview)

To use the Redis transporter, pass the following options object to the `createMicroservice()` method:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.REDIS,
  options: {
    host: 'localhost',
    port: 6379,
  },
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.REDIS,
  options: {
    host: 'localhost',
    port: 6379,
  },
});

```

> **Hint** The `Transport` enum is imported from the `@nestjs/microservices` package.

#### Options [\#](https://docs.nestjs.com/microservices/redis\#options)

The `options` property is specific to the chosen transporter. The **Redis** transporter exposes the properties described below.

|     |     |
| --- | --- |
| `host` | Connection url |
| `port` | Connection port |
| `retryAttempts` | Number of times to retry message (default: `0`) |
| `retryDelay` | Delay between message retry attempts (ms) (default: `0`) |
| `wildcards` | Enables Redis wildcard subscriptions, instructing transporter to use `psubscribe`/ `pmessage` under the hood. (default: `false`) |

All the properties supported by the official [ioredis](https://redis.github.io/ioredis/index.html#RedisOptions) client are also supported by this transporter.

#### Client [\#](https://docs.nestjs.com/microservices/redis\#client)

Like other microservice transporters, you have [several options](https://docs.nestjs.com/microservices/basics#client) for creating a Redis `ClientProxy` instance.

One method for creating an instance is to use the `ClientsModule`. To create a client instance with the `ClientsModule`, import it and use the `register()` method to pass an options object with the same properties shown above in the `createMicroservice()` method, as well as a `name` property to be used as the injection token. Read more about `ClientsModule` [here](https://docs.nestjs.com/microservices/basics#client).

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'MATH_SERVICE',\
        transport: Transport.REDIS,\
        options: {\
          host: 'localhost',\
          port: 6379,\
        }\
      },\
    ]),\
  ]
  ...
})

```

Other options to create a client (either `ClientProxyFactory` or `@Client()`) can be used as well. You can read about them [here](https://docs.nestjs.com/microservices/basics#client).

#### Context [\#](https://docs.nestjs.com/microservices/redis\#context)

In more complex scenarios, you may need to access additional information about the incoming request. When using the Redis transporter, you can access the `RedisContext` object.

content\_copy

JS  TS

```typescript

@MessagePattern('notifications')
getNotifications(@Payload() data: number[], @Ctx() context: RedisContext) {
  console.log(`Channel: ${context.getChannel()}`);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('notifications')
getNotifications(data, context) {
  console.log(`Channel: ${context.getChannel()}`);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `RedisContext` are imported from the `@nestjs/microservices` package.

#### Wildcards [\#](https://docs.nestjs.com/microservices/redis\#wildcards)

To enable wildcards support, set the `wildcards` option to `true`. This instructs the transporter to use `psubscribe` and `pmessage` under the hood.

content\_copy

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.REDIS,
  options: {
    // Other options
    wildcards: true,
  },
});

```

Make sure to pass the `wildcards` option when creating a client instance as well.

With this option enabled, you can use wildcards in your message and event patterns. For example, to subscribe to all channels starting with `notifications`, you can use the following pattern:

content\_copy

```typescript

@EventPattern('notifications.*')

```

#### Instance status updates [\#](https://docs.nestjs.com/microservices/redis\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For the Redis driver, the `status` stream emits `connected`, `disconnected`, and `reconnecting` events.

content\_copy

```typescript

this.client.status.subscribe((status: RedisStatus) => {
  console.log(status);
});

```

> **Hint** The `RedisStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: RedisStatus) => {
  console.log(status);
});

```

#### Listening to Redis events [\#](https://docs.nestjs.com/microservices/redis\#listening-to-redis-events)

In some cases, you might want to listen to internal events emitted by the microservice. For example, you could listen for the `error` event to trigger additional operations when an error occurs. To do this, use the `on()` method, as shown below:

content\_copy

```typescript

this.client.on('error', (err) => {
  console.error(err);
});

```

Similarly, you can listen to the server's internal events:

content\_copy

```typescript

server.on<RedisEvents>('error', (err) => {
  console.error(err);
});

```

> **Hint** The `RedisEvents` type is imported from the `@nestjs/microservices` package.

#### Underlying driver access [\#](https://docs.nestjs.com/microservices/redis\#underlying-driver-access)

For more advanced use cases, you may need to access the underlying driver instance. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use the `unwrap()` method, which returns the underlying driver instance. The generic type parameter should specify the type of driver instance you expect.

content\_copy

```typescript

const [pub, sub] =
  this.client.unwrap<[import('ioredis').Redis, import('ioredis').Redis]>();

```

Similarly, you can access the server's underlying driver instance:

content\_copy

```typescript

const [pub, sub] =
  server.unwrap<[import('ioredis').Redis, import('ioredis').Redis]>();

```

Note that, in contrary to other transporters, the Redis transporter returns a tuple of two `ioredis` instances: the first one is used for publishing messages, and the second one is used for subscribing to messages.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Compression Techniques
- [Compression](https://docs.nestjs.com/techniques/compression#compression)
- [Use with Express (default)](https://docs.nestjs.com/techniques/compression#use-with-express-default)
- [Use with Fastify](https://docs.nestjs.com/techniques/compression#use-with-fastify)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/compression.md "Suggest Edits")

### Compression

Compression can greatly decrease the size of the response body, thereby increasing the speed of a web app.

For **high-traffic** websites in production, it is strongly recommended to offload compression from the application server - typically in a reverse proxy (e.g., Nginx). In that case, you should not use compression middleware.

#### Use with Express (default) [\#](https://docs.nestjs.com/techniques/compression\#use-with-express-default)

Use the [compression](https://github.com/expressjs/compression) middleware package to enable gzip compression.

First install the required package:

```bash

$ npm i --save compression
$ npm i --save-dev @types/compression

```

Once the installation is complete, apply the compression middleware as global middleware.

content\_copy

```typescript

import * as compression from 'compression';
// somewhere in your initialization file
app.use(compression());

```

#### Use with Fastify [\#](https://docs.nestjs.com/techniques/compression\#use-with-fastify)

If using the `FastifyAdapter`, you'll want to use [fastify-compress](https://github.com/fastify/fastify-compress):

```bash

$ npm i --save @fastify/compress

```

Once the installation is complete, apply the `@fastify/compress` middleware as global middleware.

> **Warning** Please ensure, that you use the type `NestFastifyApplication` when creating the application. Otherwise, you cannot use `register` to apply the compression-middleware.

content\_copy

```typescript

import { FastifyAdapter, NestFastifyApplication } from '@nestjs/platform-fastify';

import compression from '@fastify/compress';

// inside bootstrap()
const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter());
await app.register(compression);

```

By default, `@fastify/compress` will use Brotli compression (on Node >= 11.7.0) when browsers indicate support for the encoding. While Brotli can be quite efficient in terms of compression ratio, it can also be quite slow. By default, Brotli sets a maximum compression quality of 11, although it can be adjusted to reduce compression time in lieu of compression quality by adjusting the `BROTLI_PARAM_QUALITY` between 0 min and 11 max. This will require fine tuning to optimize space/time performance. An example with quality 4:

content\_copy

```typescript

import { constants } from 'zlib';
// somewhere in your initialization file
await app.register(compression, { brotliOptions: { params: { [constants.BROTLI_PARAM_QUALITY]: 4 } } });

```

To simplify, you may want to tell `fastify-compress` to only use deflate and gzip to compress responses; you'll end up with potentially larger responses but they'll be delivered much more quickly.

To specify encodings, provide a second argument to `app.register`:

content\_copy

```typescript

await app.register(compression, { encodings: ['gzip', 'deflate'] });

```

The above tells `fastify-compress` to only use gzip and deflate encodings, preferring gzip if the client supports both.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## MikroORM Integration Guide
- [MikroORM](https://docs.nestjs.com/recipes/mikroorm#mikroorm)
- [Installation](https://docs.nestjs.com/recipes/mikroorm#installation)
- [Repositories](https://docs.nestjs.com/recipes/mikroorm#repositories)
- [Using custom repositories](https://docs.nestjs.com/recipes/mikroorm#using-custom-repositories)
- [Load entities automatically](https://docs.nestjs.com/recipes/mikroorm#load-entities-automatically)
- [Serialization](https://docs.nestjs.com/recipes/mikroorm#serialization)
- [Request scoped handlers in queues](https://docs.nestjs.com/recipes/mikroorm#request-scoped-handlers-in-queues)
- [Testing](https://docs.nestjs.com/recipes/mikroorm#testing)
- [Example](https://docs.nestjs.com/recipes/mikroorm#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/mikroorm.md "Suggest Edits")

### MikroORM

This recipe is here to help users get started with MikroORM in Nest. MikroORM is the TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns. It is a great alternative to TypeORM and migration from TypeORM should be fairly easy. The complete documentation on MikroORM can be found [here](https://mikro-orm.io/docs).

> **info** `@mikro-orm/nestjs` is a third party package and is not managed by the NestJS core team. Please report any issues found with the library in the [appropriate repository](https://github.com/mikro-orm/nestjs).

#### Installation [\#](https://docs.nestjs.com/recipes/mikroorm\#installation)

Easiest way to integrate MikroORM to Nest is via [`@mikro-orm/nestjs` module](https://github.com/mikro-orm/nestjs).
Simply install it next to Nest, MikroORM and underlying driver:

```bash

$ npm i @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite

```

MikroORM also supports `postgres`, `sqlite`, and `mongo`. See the [official docs](https://mikro-orm.io/docs/usage-with-sql/) for all drivers.

Once the installation process is completed, we can import the `MikroOrmModule` into the root `AppModule`.

content\_copy

```typescript

import { SqliteDriver } from '@mikro-orm/sqlite';

@Module({
  imports: [\
    MikroOrmModule.forRoot({\
      entities: ['./dist/entities'],\
      entitiesTs: ['./src/entities'],\
      dbName: 'my-db-name.sqlite3',\
      driver: SqliteDriver,\
    }),\
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

The `forRoot()` method accepts the same configuration object as `init()` from the MikroORM package. Check [this page](https://mikro-orm.io/docs/configuration) for the complete configuration documentation.

Alternatively we can [configure the CLI](https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool) by creating a configuration file `mikro-orm.config.ts` and then call the `forRoot()` without any arguments.

content\_copy

```typescript

@Module({
  imports: [\
    MikroOrmModule.forRoot(),\
  ],
  ...
})
export class AppModule {}

```

But this won't work when you use a build tools that use tree shaking, for that it is better to provide the config explicitly:

content\_copy

```typescript

import config from './mikro-orm.config'; // your ORM config

@Module({
  imports: [\
    MikroOrmModule.forRoot(config),\
  ],
  ...
})
export class AppModule {}

```

Afterward, the `EntityManager` will be available to inject across the entire project (without importing any module elsewhere).

content\_copy

```ts

// Import everything from your driver package or `@mikro-orm/knex`
import { EntityManager, MikroORM } from '@mikro-orm/sqlite';

@Injectable()
export class MyService {
  constructor(
    private readonly orm: MikroORM,
    private readonly em: EntityManager,
  ) {}
}

```

> **info** Notice that the `EntityManager` is imported from the `@mikro-orm/driver` package, where driver is `mysql`, `sqlite`, `postgres` or what driver you are using. In case you have `@mikro-orm/knex` installed as a dependency, you can also import the `EntityManager` from there.

#### Repositories [\#](https://docs.nestjs.com/recipes/mikroorm\#repositories)

MikroORM supports the repository design pattern. For every entity, we can create a repository. Read the complete documentation on repositories [here](https://mikro-orm.io/docs/repositories). To define which repositories should be registered in the current scope you can use the `forFeature()` method. For example, in this way:

> **info** You should **not** register your base entities via `forFeature()`, as there are no
> repositories for those. On the other hand, base entities need to be part of the list in `forRoot()` (or in the ORM config in general).

content\_copy

```typescript

// photo.module.ts
@Module({
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}

```

and import it into the root `AppModule`:

content\_copy

```typescript

// app.module.ts
@Module({
  imports: [MikroOrmModule.forRoot(...), PhotoModule],
})
export class AppModule {}

```

In this way we can inject the `PhotoRepository` to the `PhotoService` using the `@InjectRepository()` decorator:

content\_copy

```typescript

@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>,
  ) {}
}

```

#### Using custom repositories [\#](https://docs.nestjs.com/recipes/mikroorm\#using-custom-repositories)

When using custom repositories, we no longer need the `@InjectRepository()`
decorator, as Nest DI resolved based on the class references.

content\_copy

```ts

// `**./author.entity.ts**`
@Entity({ repository: () => AuthorRepository })
export class Author {
  // to allow inference in `em.getRepository()`
  [EntityRepositoryType]?: AuthorRepository;
}

// `**./author.repository.ts**`
export class AuthorRepository extends EntityRepository<Author> {
  // your custom methods...
}

```

As the custom repository name is the same as what `getRepositoryToken()` would
return, we do not need the `@InjectRepository()` decorator anymore:

content\_copy

```ts

@Injectable()
export class MyService {
  constructor(private readonly repo: AuthorRepository) {}
}

```

#### Load entities automatically [\#](https://docs.nestjs.com/recipes/mikroorm\#load-entities-automatically)

Manually adding entities to the entities array of the connection options can be
tedious. In addition, referencing entities from the root module breaks application
domain boundaries and causes leaking implementation details to other parts of the
application. To solve this issue, static glob paths can be used.

Note, however, that glob paths are not supported by webpack, so if you are building
your application within a monorepo, you won't be able to use them. To address this
issue, an alternative solution is provided. To automatically load entities, set the
`autoLoadEntities` property of the configuration object (passed into the `forRoot()`
method) to `true`, as shown below:

content\_copy

```ts

@Module({
  imports: [\
    MikroOrmModule.forRoot({\
      ...\
      autoLoadEntities: true,\
    }),\
  ],
})
export class AppModule {}

```

With that option specified, every entity registered through the `forFeature()`
method will be automatically added to the entities array of the configuration
object.

> **info** Note that entities that aren't registered through the `forFeature()` method, but
> are only referenced from the entity (via a relationship), won't be included by
> way of the `autoLoadEntities` setting.

> **info** Using `autoLoadEntities` also has no effect on the MikroORM CLI - for that we
> still need CLI config with the full list of entities. On the other hand, we can
> use globs there, as the CLI won't go thru webpack.

#### Serialization [\#](https://docs.nestjs.com/recipes/mikroorm\#serialization)

> **Note** MikroORM wraps every single entity relation in a `Reference<T>` or a `Collection<T>` object, in order to provide better type-safety. This will make [Nest's built-in serializer](https://docs.nestjs.com/techniques/serialization) blind to any wrapped relations. In other words, if you return MikroORM entities from your HTTP or WebSocket handlers, all of their relations will NOT be serialized.

Luckily, MikroORM provides a [serialization API](https://mikro-orm.io/docs/serializing) which can be used in lieu of `ClassSerializerInterceptor`.

content\_copy

```typescript

@Entity()
export class Book {
  @Property({ hidden: true }) // Equivalent of class-transformer's `@Exclude`
  hiddenField = Date.now();

  @Property({ persist: false }) // Similar to class-transformer's `@Expose()`. Will only exist in memory, and will be serialized.
  count?: number;

  @ManyToOne({
    serializer: (value) => value.name,
    serializedName: 'authorName',
  }) // Equivalent of class-transformer's `@Transform()`
  author: Author;
}

```

#### Request scoped handlers in queues [\#](https://docs.nestjs.com/recipes/mikroorm\#request-scoped-handlers-in-queues)

As mentioned in the [docs](https://mikro-orm.io/docs/identity-map), we need a clean state for each request. That is handled automatically thanks to the `RequestContext` helper registered via middleware.

But middlewares are executed only for regular HTTP request handles, what if we need
a request scoped method outside of that? One example of that is queue handlers or
scheduled tasks.

We can use the `@CreateRequestContext()` decorator. It requires you to first inject the
`MikroORM` instance to current context, it will be then used to create the context
for you. Under the hood, the decorator will register new request context for your
method and execute it inside the context.

content\_copy

```ts

@Injectable()
export class MyService {
  constructor(private readonly orm: MikroORM) {}

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }
}

```

> **Note** As the name suggests, this decorator always creates new context, as opposed to its alternative `@EnsureRequestContext` that only creates it if it's already not inside another one.

#### Testing [\#](https://docs.nestjs.com/recipes/mikroorm\#testing)

The `@mikro-orm/nestjs` package exposes `getRepositoryToken()` function that returns prepared token based on a given entity to allow mocking the repository.

content\_copy

```typescript

@Module({
  providers: [\
    PhotoService,\
    {\
      // or when you have a custom repository: `provide: PhotoRepository`\
      provide: getRepositoryToken(Photo),\
      useValue: mockedRepository,\
    },\
  ],
})
export class PhotoModule {}

```

#### Example [\#](https://docs.nestjs.com/recipes/mikroorm\#example)

A real world example of NestJS with MikroORM can be found [here](https://github.com/mikro-orm/nestjs-realworld-example-app)

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS CQRS Guide
- [CQRS](https://docs.nestjs.com/recipes/cqrs#cqrs)
- [Installation](https://docs.nestjs.com/recipes/cqrs#installation)
- [Commands](https://docs.nestjs.com/recipes/cqrs#commands)
- [Queries](https://docs.nestjs.com/recipes/cqrs#queries)
- [Events](https://docs.nestjs.com/recipes/cqrs#events)
- [Sagas](https://docs.nestjs.com/recipes/cqrs#sagas)
- [Unhandled exceptions](https://docs.nestjs.com/recipes/cqrs#unhandled-exceptions)
- [Subscribing to all events](https://docs.nestjs.com/recipes/cqrs#subscribing-to-all-events)
- [Request-scoping](https://docs.nestjs.com/recipes/cqrs#request-scoping)
- [Example](https://docs.nestjs.com/recipes/cqrs#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/cqrs.md "Suggest Edits")

### CQRS

The flow of simple [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) (Create, Read, Update and Delete) applications can be described as follows:

1. The controllers layer handles HTTP requests and delegates tasks to the services layer.
2. The services layer is where most of the business logic lives.
3. Services use repositories / DAOs to change / persist entities.
4. Entities act as containers for the values, with setters and getters.

While this pattern is usually sufficient for small and medium-sized applications, it may not be the best choice for larger, more complex applications. In such cases, the **CQRS** (Command and Query Responsibility Segregation) model may be more appropriate and scalable (depending on the application's requirements). Benefits of this model include:

- **Separation of concerns**. The model separates the read and write operations into separate models.
- **Scalability**. The read and write operations can be scaled independently.
- **Flexibility**. The model allows for the use of different data stores for read and write operations.
- **Performance**. The model allows for the use of different data stores optimized for read and write operations.

To facilitate that model, Nest provides a lightweight [CQRS module](https://github.com/nestjs/cqrs). This chapter describes how to use it.

#### Installation [\#](https://docs.nestjs.com/recipes/cqrs\#installation)

First install the required package:

```bash

$ npm install --save @nestjs/cqrs

```

Once the installation is complete, navigate to the root module of your application (usually `AppModule`), and import the `CqrsModule.forRoot()`:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { CqrsModule } from '@nestjs/cqrs';

@Module({
  imports: [CqrsModule.forRoot()],
})
export class AppModule {}

```

This module accepts an optional configuration object. The following options are available:

| Attribute | Description | Default |
| --- | --- | --- |
| `commandPublisher` | The publisher responsible for dispatching commands to the system. | `DefaultCommandPubSub` |
| `eventPublisher` | The publisher used to publish events, allowing them to be broadcasted or processed. | `DefaultPubSub` |
| `queryPublisher` | The publisher used for publishing queries, which can trigger data retrieval operations. | `DefaultQueryPubSub` |
| `unhandledExceptionPublisher` | Publisher responsible for handling unhandled exceptions, ensuring they are tracked and reported. | `DefaultUnhandledExceptionPubSub` |
| `eventIdProvider` | Service that provides unique event IDs by generating or retrieving them from event instances. | `DefaultEventIdProvider` |
| `rethrowUnhandled` | Determines whether unhandled exceptions should be rethrown after being processed, useful for debugging and error management. | `false` |

#### Commands [\#](https://docs.nestjs.com/recipes/cqrs\#commands)

Commands are used to change the application state. They should be task-based, rather than data centric. When a command is dispatched, it is handled by a corresponding **Command Handler**. The handler is responsible for updating the application state.

content\_copy heroes-game.service.ts

JS  TS

```typescript

@Injectable()
export class HeroesGameService {
  constructor(private commandBus: CommandBus) {}

  async killDragon(heroId: string, killDragonDto: KillDragonDto) {
    return this.commandBus.execute(
      new KillDragonCommand(heroId, killDragonDto.dragonId)
    );
  }
}

```

```typescript

@Injectable()
@Dependencies(CommandBus)
export class HeroesGameService {
  constructor(commandBus) {
    this.commandBus = commandBus;
  }

  async killDragon(heroId, killDragonDto) {
    return this.commandBus.execute(
      new KillDragonCommand(heroId, killDragonDto.dragonId)
    );
  }
}

```

In the code snippet above, we instantiate the `KillDragonCommand` class and pass it to the `CommandBus`'s `execute()` method. This is the demonstrated command class:

content\_copy kill-dragon.command.ts

JS  TS

```typescript

export class KillDragonCommand extends Command<{
  actionId: string // This type represents the command execution result
}> {
  constructor(
    public readonly heroId: string,
    public readonly dragonId: string,
  ) {
    super();
  }
}

```

```typescript

export class KillDragonCommand extends Command {
  constructor(heroId, dragonId) {
    this.heroId = heroId;
    this.dragonId = dragonId;
  }
}

```

As you can see, the `KillDragonCommand` class extends the `Command` class. The `Command` class is a simple utility class exported from the `@nestjs/cqrs` package that lets you define the command's return type. In this case, the return type is an object with an `actionId` property. Now, whenever the `KillDragonCommand` command is dispatched, the `CommandBus#execute()` method return-type will be inferred as `Promise<{ actionId: string }>`. This is useful when you want to return some data from the command handler.

> **Hint** Inheritance from the `Command` class is optional. It is only necessary if you want to define the return type of the command.

The `CommandBus` represents a **stream** of commands. It is responsible for dispatching commands to the appropriate handlers. The `execute()` method returns a promise, which resolves to the value returned by the handler.

Let's create a handler for the `KillDragonCommand` command.

content\_copy kill-dragon.handler.ts

JS  TS

```typescript

@CommandHandler(KillDragonCommand)
export class KillDragonHandler implements ICommandHandler<KillDragonCommand> {
  constructor(private repository: HeroesRepository) {}

  async execute(command: KillDragonCommand) {
    const { heroId, dragonId } = command;
    const hero = this.repository.findOneById(+heroId);

    hero.killEnemy(dragonId);
    await this.repository.persist(hero);

    // "ICommandHandler<KillDragonCommand>" forces you to return a value that matches the command's return type
    return {
      actionId: crypto.randomUUID(), // This value will be returned to the caller
    }
  }
}

```

```typescript

@CommandHandler(KillDragonCommand)
@Dependencies(HeroesRepository)
export class KillDragonHandler {
  constructor(repository) {
    this.repository = repository;
  }

  async execute(command) {
    const { heroId, dragonId } = command;
    const hero = this.repository.findOneById(+heroId);

    hero.killEnemy(dragonId);
    await this.repository.persist(hero);

    // "ICommandHandler<KillDragonCommand>" forces you to return a value that matches the command's return type
    return {
      actionId: crypto.randomUUID(), // This value will be returned to the caller
    }
  }
}

```

This handler retrieves the `Hero` entity from the repository, calls the `killEnemy()` method, and then persists the changes. The `KillDragonHandler` class implements the `ICommandHandler` interface, which requires the implementation of the `execute()` method. The `execute()` method receives the command object as an argument.

Note that `ICommandHandler<KillDragonCommand>` forces you to return a value that matches the command's return type. In this case, the return type is an object with an `actionId` property. This only applies to commands that inherit from the `Command` class. Otherwise, you can return whatever you want.

Lastly, make sure to register the `KillDragonHandler` as a provider in a module:

content\_copy

```typescript

providers: [KillDragonHandler];

```

#### Queries [\#](https://docs.nestjs.com/recipes/cqrs\#queries)

Queries are used to retrieve data from the application state. They should be data centric, rather than task-based. When a query is dispatched, it is handled by a corresponding **Query Handler**. The handler is responsible for retrieving the data.

The `QueryBus` follows the same pattern as the `CommandBus`. Query handlers should implement the `IQueryHandler` interface and be annotated with the `@QueryHandler()` decorator. See the following example:

content\_copy

```typescript

export class GetHeroQuery extends Query<Hero> {
  constructor(public readonly heroId: string) {}
}

```

Similar to the `Command` class, the `Query` class is a simple utility class exported from the `@nestjs/cqrs` package that lets you define the query's return type. In this case, the return type is a `Hero` object. Now, whenever the `GetHeroQuery` query is dispatched, the `QueryBus#execute()` method return-type will be inferred as `Promise<Hero>`.

To retrieve the hero, we need to create a query handler:

content\_copy get-hero.handler.ts

JS  TS

```typescript

@QueryHandler(GetHeroQuery)
export class GetHeroHandler implements IQueryHandler<GetHeroQuery> {
  constructor(private repository: HeroesRepository) {}

  async execute(query: GetHeroQuery) {
    return this.repository.findOneById(query.hero);
  }
}

```

```typescript

@QueryHandler(GetHeroQuery)
@Dependencies(HeroesRepository)
export class GetHeroHandler {
  constructor(repository) {
    this.repository = repository;
  }

  async execute(query) {
    return this.repository.findOneById(query.hero);
  }
}

```

The `GetHeroHandler` class implements the `IQueryHandler` interface, which requires the implementation of the `execute()` method. The `execute()` method receives the query object as an argument, and must return the data that matches the query's return type (in this case, a `Hero` object).

Lastly, make sure to register the `GetHeroHandler` as a provider in a module:

content\_copy

```typescript

providers: [GetHeroHandler];

```

Now, to dispatch the query, use the `QueryBus`:

content\_copy

```typescript

const hero = await this.queryBus.execute(new GetHeroQuery(heroId)); // "hero" will be auto-inferred as "Hero" type

```

#### Events [\#](https://docs.nestjs.com/recipes/cqrs\#events)

Events are used to notify other parts of the application about changes in the application state. They are dispatched by **models** or directly using the `EventBus`. When an event is dispatched, it is handled by corresponding **Event Handlers**. Handlers can then, for example, update the read model.

For demonstration purposes, let's create an event class:

content\_copy hero-killed-dragon.event.ts

JS  TS

```typescript

export class HeroKilledDragonEvent {
  constructor(
    public readonly heroId: string,
    public readonly dragonId: string,
  ) {}
}

```

```typescript

export class HeroKilledDragonEvent {
  constructor(heroId, dragonId) {
    this.heroId = heroId;
    this.dragonId = dragonId;
  }
}

```

Now while events can be dispatched directly using the `EventBus.publish()` method, we can also dispatch them from the model. Let's update the `Hero` model to dispatch the `HeroKilledDragonEvent` event when the `killEnemy()` method is called.

content\_copy hero.model.ts

JS  TS

```typescript

export class Hero extends AggregateRoot {
  constructor(private id: string) {
    super();
  }

  killEnemy(enemyId: string) {
    // Business logic
    this.apply(new HeroKilledDragonEvent(this.id, enemyId));
  }
}

```

```typescript

export class Hero extends AggregateRoot {
  constructor(id) {
    super();
    this.id = id;
  }

  killEnemy(enemyId) {
    // Business logic
    this.apply(new HeroKilledDragonEvent(this.id, enemyId));
  }
}

```

The `apply()` method is used to dispatch events. It accepts an event object as an argument. However, since our model is not aware of the `EventBus`, we need to associate it with the model. We can do that by using the `EventPublisher` class.

content\_copy kill-dragon.handler.ts

JS  TS

```typescript

@CommandHandler(KillDragonCommand)
export class KillDragonHandler implements ICommandHandler<KillDragonCommand> {
  constructor(
    private repository: HeroesRepository,
    private publisher: EventPublisher,
  ) {}

  async execute(command: KillDragonCommand) {
    const { heroId, dragonId } = command;
    const hero = this.publisher.mergeObjectContext(
      await this.repository.findOneById(+heroId),
    );
    hero.killEnemy(dragonId);
    hero.commit();
  }
}

```

```typescript

@CommandHandler(KillDragonCommand)
@Dependencies(HeroesRepository, EventPublisher)
export class KillDragonHandler {
  constructor(repository, publisher) {
    this.repository = repository;
    this.publisher = publisher;
  }

  async execute(command) {
    const { heroId, dragonId } = command;
    const hero = this.publisher.mergeObjectContext(
      await this.repository.findOneById(+heroId),
    );
    hero.killEnemy(dragonId);
    hero.commit();
  }
}

```

The `EventPublisher#mergeObjectContext` method merges the event publisher into the provided object, which means that the object will now be able to publish events to the events stream.

Notice that in this example we also call the `commit()` method on the model. This method is used to dispatch any outstanding events. To automatically dispatch events, we can set the `autoCommit` property to `true`:

content\_copy

```typescript

export class Hero extends AggregateRoot {
  constructor(private id: string) {
    super();
    this.autoCommit = true;
  }
}

```

In case we want to merge the event publisher into a non-existing object, but rather into a class, we can use the `EventPublisher#mergeClassContext` method:

content\_copy

```typescript

const HeroModel = this.publisher.mergeClassContext(Hero);
const hero = new HeroModel('id'); // <-- HeroModel is a class

```

Now every instance of the `HeroModel` class will be able to publish events without using `mergeObjectContext()` method.

Additionally, we can emit events manually using `EventBus`:

content\_copy

```typescript

this.eventBus.publish(new HeroKilledDragonEvent());

```

> **Hint** The `EventBus` is an injectable class.

Each event can have multiple **Event Handlers**.

content\_copy hero-killed-dragon.handler.ts

JS  TS

```typescript

@EventsHandler(HeroKilledDragonEvent)
export class HeroKilledDragonHandler implements IEventHandler<HeroKilledDragonEvent> {
  constructor(private repository: HeroesRepository) {}

  handle(event: HeroKilledDragonEvent) {
    // Business logic
  }
}

```

> **Hint** Be aware that when you start using event handlers you get out of the traditional HTTP web context.
>
> - Errors in `CommandHandlers` can still be caught by built-in [Exception filters](https://docs.nestjs.com/exception-filters).
> - Errors in `EventHandlers` can't be caught by Exception filters: you will have to handle them manually. Either by a simple `try/catch`, using [Sagas](https://docs.nestjs.com/recipes/cqrs#sagas) by triggering a compensating event, or whatever other solution you choose.
> - HTTP Responses in `CommandHandlers` can still be sent back to the client.
> - HTTP Responses in `EventHandlers` cannot. If you want to send information to the client you could use [WebSocket](https://docs.nestjs.com/websockets/gateways), [SSE](https://docs.nestjs.com/techniques/server-sent-events), or whatever other solution you choose.

As with commands and queries, make sure to register the `HeroKilledDragonHandler` as a provider in a module:

content\_copy

```typescript

providers: [HeroKilledDragonHandler];

```

#### Sagas [\#](https://docs.nestjs.com/recipes/cqrs\#sagas)

Saga is a long-running process that listens to events and may trigger new commands. It is usually used to manage complex workflows in the application. For example, when a user signs up, a saga may listen to the `UserRegisteredEvent` and send a welcome email to the user.

Sagas are an extremely powerful feature. A single saga may listen for 1..\* events. Using the [RxJS](https://github.com/ReactiveX/rxjs) library, we can filter, map, fork, and merge event streams to create sophisticated workflows. Each saga returns an Observable which produces a command instance. This command is then dispatched **asynchronously** by the `CommandBus`.

Let's create a saga that listens to the `HeroKilledDragonEvent` and dispatches the `DropAncientItemCommand` command.

content\_copy heroes-game.saga.ts

JS  TS

```typescript

@Injectable()
export class HeroesGameSagas {
  @Saga()
  dragonKilled = (events$: Observable<any>): Observable<ICommand> => {
    return events$.pipe(
      ofType(HeroKilledDragonEvent),
      map((event) => new DropAncientItemCommand(event.heroId, fakeItemID)),
    );
  }
}

```

```typescript

@Injectable()
export class HeroesGameSagas {
  @Saga()
  dragonKilled = (events$) => {
    return events$.pipe(
      ofType(HeroKilledDragonEvent),
      map((event) => new DropAncientItemCommand(event.heroId, fakeItemID)),
    );
  }
}

```

> **Hint** The `ofType` operator and the `@Saga()` decorator are exported from the `@nestjs/cqrs` package.

The `@Saga()` decorator marks the method as a saga. The `events$` argument is an Observable stream of all events. The `ofType` operator filters the stream by the specified event type. The `map` operator maps the event to a new command instance.

In this example, we map the `HeroKilledDragonEvent` to the `DropAncientItemCommand` command. The `DropAncientItemCommand` command is then auto-dispatched by the `CommandBus`.

As with query, command, and event handlers, make sure to register the `HeroesGameSagas` as a provider in a module:

content\_copy

```typescript

providers: [HeroesGameSagas];

```

#### Unhandled exceptions [\#](https://docs.nestjs.com/recipes/cqrs\#unhandled-exceptions)

Event handlers are executed asynchronously, so they must always handle exceptions properly to prevent the application from entering an inconsistent state. If an exception is not handled, the `EventBus` will create an `UnhandledExceptionInfo` object and push it to the `UnhandledExceptionBus` stream. This stream is an `Observable` that can be used to process unhandled exceptions.

content\_copy

```typescript

private destroy$ = new Subject<void>();

constructor(private unhandledExceptionsBus: UnhandledExceptionBus) {
  this.unhandledExceptionsBus
    .pipe(takeUntil(this.destroy$))
    .subscribe((exceptionInfo) => {
      // Handle exception here
      // e.g. send it to external service, terminate process, or publish a new event
    });
}

onModuleDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}

```

To filter out exceptions, we can use the `ofType` operator, as follows:

content\_copy

```typescript

this.unhandledExceptionsBus
  .pipe(
    takeUntil(this.destroy$),
    UnhandledExceptionBus.ofType(TransactionNotAllowedException),
  )
  .subscribe((exceptionInfo) => {
    // Handle exception here
  });

```

Where `TransactionNotAllowedException` is the exception we want to filter out.

The `UnhandledExceptionInfo` object contains the following properties:

content\_copy

```typescript

export interface UnhandledExceptionInfo<
  Cause = IEvent | ICommand,
  Exception = any,
> {
  /**
   * The exception that was thrown.
   */
  exception: Exception;
  /**
   * The cause of the exception (event or command reference).
   */
  cause: Cause;
}

```

#### Subscribing to all events [\#](https://docs.nestjs.com/recipes/cqrs\#subscribing-to-all-events)

`CommandBus`, `QueryBus` and `EventBus` are all **Observables**. This means that we can subscribe to the entire stream and, for example, process all events. For example, we can log all events to the console, or save them to the event store.

content\_copy

```typescript

private destroy$ = new Subject<void>();

constructor(private eventBus: EventBus) {
  this.eventBus
    .pipe(takeUntil(this.destroy$))
    .subscribe((event) => {
      // Save events to database
    });
}

onModuleDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}

```

#### Request-scoping [\#](https://docs.nestjs.com/recipes/cqrs\#request-scoping)

For those coming from different programming language backgrounds, it may be surprising to learn that in Nest, most things are shared across incoming requests. This includes a connection pool to the database, singleton services with global state, and more. Keep in mind that Node.js does not follow the request/response multi-threaded stateless model, where each request is processed by a separate thread. As a result, using singleton instances is **safe** for our applications.

However, there are edge cases where a request-based lifetime for the handler might be desirable. This could include scenarios like per-request caching in GraphQL applications, request tracking, or multi-tenancy. You can learn more about how to control scopes [here](https://docs.nestjs.com/fundamentals/injection-scopes).

Using request-scoped providers alongside CQRS can be complex because the `CommandBus`, `QueryBus`, and `EventBus` are singletons. Thankfully, the `@nestjs/cqrs` package simplifies this by automatically creating a new instance of request-scoped handlers for each processed command, query, or event.

To make a handler request-scoped, you can either:

1. Depend on a request-scoped provider.
2. Explicitly set its scope to `REQUEST` using the `@CommandHandler`, `@QueryHandler`, or `@EventsHandler` decorator, as shown:

content\_copy

```typescript

@CommandHandler(KillDragonCommand, {
  scope: Scope.REQUEST,
})
export class KillDragonHandler {
  // Implementation here
}

```

To inject the request payload into any request-scoped provider, you use the `@Inject(REQUEST)` decorator. However, the nature of the request payload in CQRS depends on the context—it could be an HTTP request, a scheduled job, or any other operation that triggers a command.

The payload must be an instance of a class extending `AsyncContext` (provided by `@nestjs/cqrs`), which acts as the request context and holds data accessible throughout the request lifecycle.

content\_copy

```typescript

import { AsyncContext } from '@nestjs/cqrs';

export class MyRequest extends AsyncContext {
  constructor(public readonly user: User) {
    super();
  }
}

```

When executing a command, pass the custom request context as the second argument to the `CommandBus#execute` method:

content\_copy

```typescript

const myRequest = new MyRequest(user);
await this.commandBus.execute(
  new KillDragonCommand(heroId, killDragonDto.dragonId),
  myRequest,
);

```

This makes the `MyRequest` instance available as the `REQUEST` provider to the corresponding handler:

content\_copy

```typescript

@CommandHandler(KillDragonCommand, {
  scope: Scope.REQUEST,
})
export class KillDragonHandler {
  constructor(
    @Inject(REQUEST) private request: MyRequest, // Inject the request context
  ) {}

  // Handler implementation here
}

```

You can follow the same approach for queries:

content\_copy

```typescript

const myRequest = new MyRequest(user);
const hero = await this.queryBus.execute(new GetHeroQuery(heroId), myRequest);

```

And in the query handler:

content\_copy

```typescript

@QueryHandler(GetHeroQuery, {
  scope: Scope.REQUEST,
})
export class GetHeroHandler {
  constructor(
    @Inject(REQUEST) private request: MyRequest, // Inject the request context
  ) {}

  // Handler implementation here
}

```

For events, while you can pass the request provider to `EventBus#publish`, this is less common. Instead, use `EventPublisher` to merge the request provider into a model:

content\_copy

```typescript

const hero = this.publisher.mergeObjectContext(
  await this.repository.findOneById(+heroId),
  this.request, // Inject the request context here
);

```

Request-scoped event handlers subscribing to these events will have access to the request provider.

Sagas are always singleton instances because they manage long-running processes. However, you can retrieve the request provider from event objects:

content\_copy

```typescript

@Saga()
dragonKilled = (events$: Observable<any>): Observable<ICommand> => {
  return events$.pipe(
    ofType(HeroKilledDragonEvent),
    map((event) => {
      const request = AsyncContext.of(event); // Retrieve the request context
      const command = new DropAncientItemCommand(event.heroId, fakeItemID);

      AsyncContext.merge(request, command); // Merge the request context into the command
      return command;
    }),
  );
}

```

Alternatively, use the `request.attachTo(command)` method to tie the request context to the command.

#### Example [\#](https://docs.nestjs.com/recipes/cqrs\#example)

A working example is available [here](https://github.com/kamilmysliwiec/nest-cqrs-example).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Kafka Microservices
- [Kafka](https://docs.nestjs.com/microservices/kafka#kafka)
- [Installation](https://docs.nestjs.com/microservices/kafka#installation)
- [Overview](https://docs.nestjs.com/microservices/kafka#overview)
- [Options](https://docs.nestjs.com/microservices/kafka#options)
- [Client](https://docs.nestjs.com/microservices/kafka#client)
- [Message pattern](https://docs.nestjs.com/microservices/kafka#message-pattern)
- [Message response subscription](https://docs.nestjs.com/microservices/kafka#message-response-subscription)
- [Incoming](https://docs.nestjs.com/microservices/kafka#incoming)
- [Outgoing](https://docs.nestjs.com/microservices/kafka#outgoing)
- [Event-based](https://docs.nestjs.com/microservices/kafka#event-based)
- [Context](https://docs.nestjs.com/microservices/kafka#context)
- [Naming conventions](https://docs.nestjs.com/microservices/kafka#naming-conventions)
- [Retriable exceptions](https://docs.nestjs.com/microservices/kafka#retriable-exceptions)
- [Custom exception handling](https://docs.nestjs.com/microservices/kafka#custom-exception-handling)
- [Commit offsets](https://docs.nestjs.com/microservices/kafka#commit-offsets)
- [Instance status updates](https://docs.nestjs.com/microservices/kafka#instance-status-updates)
- [Underlying producer and consumer](https://docs.nestjs.com/microservices/kafka#underlying-producer-and-consumer)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/kafka.md "Suggest Edits")

### Kafka

[Kafka](https://kafka.apache.org/) is an open source, distributed streaming platform which has three key capabilities:

- Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system.
- Store streams of records in a fault-tolerant durable way.
- Process streams of records as they occur.

The Kafka project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds. It integrates very well with Apache Storm and Spark for real-time streaming data analysis.

#### Installation [\#](https://docs.nestjs.com/microservices/kafka\#installation)

To start building Kafka-based microservices, first install the required package:

```bash

$ npm i --save kafkajs

```

#### Overview [\#](https://docs.nestjs.com/microservices/kafka\#overview)

Like other Nest microservice transport layer implementations, you select the Kafka transporter mechanism using the `transport` property of the options object passed to the `createMicroservice()` method, along with an optional `options` property, as shown below:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      brokers: ['localhost:9092'],
    }
  }
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      brokers: ['localhost:9092'],
    }
  }
});

```

> **Hint** The `Transport` enum is imported from the `@nestjs/microservices` package.

#### Options [\#](https://docs.nestjs.com/microservices/kafka\#options)

The `options` property is specific to the chosen transporter. The **Kafka** transporter exposes the properties described below.

|     |     |
| --- | --- |
| `client` | Client configuration options (read more [here](https://kafka.js.org/docs/configuration)) |
| `consumer` | Consumer configuration options (read more [here](https://kafka.js.org/docs/consuming#a-name-options-a-options)) |
| `run` | Run configuration options (read more [here](https://kafka.js.org/docs/consuming)) |
| `subscribe` | Subscribe configuration options (read more [here](https://kafka.js.org/docs/consuming#frombeginning)) |
| `producer` | Producer configuration options (read more [here](https://kafka.js.org/docs/producing#options)) |
| `send` | Send configuration options (read more [here](https://kafka.js.org/docs/producing#options)) |
| `producerOnlyMode` | Feature flag to skip consumer group registration and only act as a producer ( `boolean`) |
| `postfixId` | Change suffix of clientId value ( `string`) |

#### Client [\#](https://docs.nestjs.com/microservices/kafka\#client)

There is a small difference in Kafka compared to other microservice transporters. Instead of the `ClientProxy` class, we use the `ClientKafkaProxy` class.

Like other microservice transporters, you have [several options](https://docs.nestjs.com/microservices/basics#client) for creating a `ClientKafkaProxy` instance.

One method for creating an instance is to use the `ClientsModule`. To create a client instance with the `ClientsModule`, import it and use the `register()` method to pass an options object with the same properties shown above in the `createMicroservice()` method, as well as a `name` property to be used as the injection token. Read more about `ClientsModule` [here](https://docs.nestjs.com/microservices/basics#client).

content\_copy

```typescript

@Module({
  imports: [\
    ClientsModule.register([\
      {\
        name: 'HERO_SERVICE',\
        transport: Transport.KAFKA,\
        options: {\
          client: {\
            clientId: 'hero',\
            brokers: ['localhost:9092'],\
          },\
          consumer: {\
            groupId: 'hero-consumer'\
          }\
        }\
      },\
    ]),\
  ]
  ...
})

```

Other options to create a client (either `ClientProxyFactory` or `@Client()`) can be used as well. You can read about them [here](https://docs.nestjs.com/microservices/basics#client).

Use the `@Client()` decorator as follows:

content\_copy

```typescript

@Client({
  transport: Transport.KAFKA,
  options: {
    client: {
      clientId: 'hero',
      brokers: ['localhost:9092'],
    },
    consumer: {
      groupId: 'hero-consumer'
    }
  }
})
client: ClientKafkaProxy;

```

#### Message pattern [\#](https://docs.nestjs.com/microservices/kafka\#message-pattern)

The Kafka microservice message pattern utilizes two topics for the request and reply channels. The `ClientKafkaProxy.send()` method sends messages with a [return address](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html) by associating a [correlation id](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html), reply topic, and reply partition with the request message. This requires the `ClientKafkaProxy` instance to be subscribed to the reply topic and assigned to at least one partition before sending a message.

Subsequently, you need to have at least one reply topic partition for every Nest application running. For example, if you are running 4 Nest applications but the reply topic only has 3 partitions, then 1 of the Nest applications will error out when trying to send a message.

When new `ClientKafkaProxy` instances are launched they join the consumer group and subscribe to their respective topics. This process triggers a rebalance of topic partitions assigned to consumers of the consumer group.

Normally, topic partitions are assigned using the round robin partitioner, which assigns topic partitions to a collection of consumers sorted by consumer names which are randomly set on application launch. However, when a new consumer joins the consumer group, the new consumer can be positioned anywhere within the collection of consumers. This creates a condition where pre-existing consumers can be assigned different partitions when the pre-existing consumer is positioned after the new consumer. As a result, the consumers that are assigned different partitions will lose response messages of requests sent before the rebalance.

To prevent the `ClientKafkaProxy` consumers from losing response messages, a Nest-specific built-in custom partitioner is utilized. This custom partitioner assigns partitions to a collection of consumers sorted by high-resolution timestamps ( `process.hrtime()`) that are set on application launch.

#### Message response subscription [\#](https://docs.nestjs.com/microservices/kafka\#message-response-subscription)

> **Note** This section is only relevant if you use [request-response](https://docs.nestjs.com/microservices/basics#request-response) message style (with the `@MessagePattern` decorator and the `ClientKafkaProxy.send` method). Subscribing to the response topic is not necessary for the [event-based](https://docs.nestjs.com/microservices/basics#event-based) communication ( `@EventPattern` decorator and `ClientKafkaProxy.emit` method).

The `ClientKafkaProxy` class provides the `subscribeToResponseOf()` method. The `subscribeToResponseOf()` method takes a request's topic name as an argument and adds the derived reply topic name to a collection of reply topics. This method is required when implementing the message pattern.

content\_copy heroes.controller.ts

JS  TS

```typescript

onModuleInit() {
  this.client.subscribeToResponseOf('hero.kill.dragon');
}

```

If the `ClientKafkaProxy` instance is created asynchronously, the `subscribeToResponseOf()` method must be called before calling the `connect()` method.

content\_copy heroes.controller.ts

JS  TS

```typescript

async onModuleInit() {
  this.client.subscribeToResponseOf('hero.kill.dragon');
  await this.client.connect();
}

```

#### Incoming [\#](https://docs.nestjs.com/microservices/kafka\#incoming)

Nest receives incoming Kafka messages as an object with `key`, `value`, and `headers` properties that have values of type `Buffer`. Nest then parses these values by transforming the buffers into strings. If the string is "object like", Nest attempts to parse the string as `JSON`. The `value` is then passed to its associated handler.

#### Outgoing [\#](https://docs.nestjs.com/microservices/kafka\#outgoing)

Nest sends outgoing Kafka messages after a serialization process when publishing events or sending messages. This occurs on arguments passed to the `ClientKafkaProxy` `emit()` and `send()` methods or on values returned from a `@MessagePattern` method. This serialization "stringifies" objects that are not strings or buffers by using `JSON.stringify()` or the `toString()` prototype method.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesController {
  @MessagePattern('hero.kill.dragon')
  killDragon(@Payload() message: KillDragonMessage): any {
    const dragonId = message.dragonId;
    const items = [\
      { id: 1, name: 'Mythical Sword' },\
      { id: 2, name: 'Key to Dungeon' },\
    ];
    return items;
  }
}

```

> **Hint** `@Payload()` is imported from the `@nestjs/microservices` package.

Outgoing messages can also be keyed by passing an object with the `key` and `value` properties. Keying messages is important for meeting the [co-partitioning requirement](https://docs.confluent.io/current/ksql/docs/developer-guide/partition-data.html#co-partitioning-requirements).

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesController {
  @MessagePattern('hero.kill.dragon')
  killDragon(@Payload() message: KillDragonMessage): any {
    const realm = 'Nest';
    const heroId = message.heroId;
    const dragonId = message.dragonId;

    const items = [\
      { id: 1, name: 'Mythical Sword' },\
      { id: 2, name: 'Key to Dungeon' },\
    ];

    return {
      headers: {
        realm
      },
      key: heroId,
      value: items
    }
  }
}

```

Additionally, messages passed in this format can also contain custom headers set in the `headers` hash property. Header hash property values must be either of type `string` or type `Buffer`.

content\_copy heroes.controller.ts

JS  TS

```typescript

@Controller()
export class HeroesController {
  @MessagePattern('hero.kill.dragon')
  killDragon(@Payload() message: KillDragonMessage): any {
    const realm = 'Nest';
    const heroId = message.heroId;
    const dragonId = message.dragonId;

    const items = [\
      { id: 1, name: 'Mythical Sword' },\
      { id: 2, name: 'Key to Dungeon' },\
    ];

    return {
      headers: {
        kafka_nestRealm: realm
      },
      key: heroId,
      value: items
    }
  }
}

```

#### Event-based [\#](https://docs.nestjs.com/microservices/kafka\#event-based)

While the request-response method is ideal for exchanging messages between services, it is less suitable when your message style is event-based (which in turn is ideal for Kafka) - when you just want to publish events **without waiting for a response**. In that case, you do not want the overhead required by request-response for maintaining two topics.

Check out these two sections to learn more about this: [Overview: Event-based](https://docs.nestjs.com/microservices/basics#event-based) and [Overview: Publishing events](https://docs.nestjs.com/microservices/basics#publishing-events).

#### Context [\#](https://docs.nestjs.com/microservices/kafka\#context)

In more complex scenarios, you may need to access additional information about the incoming request. When using the Kafka transporter, you can access the `KafkaContext` object.

content\_copy

JS  TS

```typescript

@MessagePattern('hero.kill.dragon')
killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('hero.kill.dragon')
killDragon(message, context) {
  console.log(`Topic: ${context.getTopic()}`);
}

```

> **Hint** `@Payload()`, `@Ctx()` and `KafkaContext` are imported from the `@nestjs/microservices` package.

To access the original Kafka `IncomingMessage` object, use the `getMessage()` method of the `KafkaContext` object, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('hero.kill.dragon')
killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {
  const originalMessage = context.getMessage();
  const partition = context.getPartition();
  const { headers, timestamp } = originalMessage;
}

```

```typescript

@Bind(Payload(), Ctx())
@MessagePattern('hero.kill.dragon')
killDragon(message, context) {
  const originalMessage = context.getMessage();
  const partition = context.getPartition();
  const { headers, timestamp } = originalMessage;
}

```

Where the `IncomingMessage` fulfills the following interface:

content\_copy

```typescript

interface IncomingMessage {
  topic: string;
  partition: number;
  timestamp: string;
  size: number;
  attributes: number;
  offset: string;
  key: any;
  value: any;
  headers: Record<string, any>;
}

```

If your handler involves a slow processing time for each received message you should consider using the `heartbeat` callback. To retrieve the `heartbeat` function, use the `getHeartbeat()` method of the `KafkaContext`, as follows:

content\_copy

JS  TS

```typescript

@MessagePattern('hero.kill.dragon')
async killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {
  const heartbeat = context.getHeartbeat();

  // Do some slow processing
  await doWorkPart1();

  // Send heartbeat to not exceed the sessionTimeout
  await heartbeat();

  // Do some slow processing again
  await doWorkPart2();
}

```

#### Naming conventions [\#](https://docs.nestjs.com/microservices/kafka\#naming-conventions)

The Kafka microservice components append a description of their respective role onto the `client.clientId` and `consumer.groupId` options to prevent collisions between Nest microservice client and server components. By default the `ClientKafkaProxy` components append `-client` and the `ServerKafka` components append `-server` to both of these options. Note how the provided values below are transformed in that way (as shown in the comments).

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      clientId: 'hero', // hero-server
      brokers: ['localhost:9092'],
    },
    consumer: {
      groupId: 'hero-consumer' // hero-consumer-server
    },
  }
});

```

And for the client:

content\_copy heroes.controller.ts

JS  TS

```typescript

@Client({
  transport: Transport.KAFKA,
  options: {
    client: {
      clientId: 'hero', // hero-client
      brokers: ['localhost:9092'],
    },
    consumer: {
      groupId: 'hero-consumer' // hero-consumer-client
    }
  }
})
client: ClientKafkaProxy;

```

> **Hint** Kafka client and consumer naming conventions can be customized by extending `ClientKafkaProxy` and `KafkaServer` in your own custom provider and overriding the constructor.

Since the Kafka microservice message pattern utilizes two topics for the request and reply channels, a reply pattern should be derived from the request topic. By default, the name of the reply topic is the composite of the request topic name with `.reply` appended.

content\_copy heroes.controller.ts

JS  TS

```typescript

onModuleInit() {
  this.client.subscribeToResponseOf('hero.get'); // hero.get.reply
}

```

> **Hint** Kafka reply topic naming conventions can be customized by extending `ClientKafkaProxy` in your own custom provider and overriding the `getResponsePatternName` method.

#### Retriable exceptions [\#](https://docs.nestjs.com/microservices/kafka\#retriable-exceptions)

Similar to other transporters, all unhandled exceptions are automatically wrapped into an `RpcException` and converted to a "user-friendly" format. However, there are edge-cases when you might want to bypass this mechanism and let exceptions be consumed by the `kafkajs` driver instead. Throwing an exception when processing a message instructs `kafkajs` to **retry** it (redeliver it) which means that even though the message (or event) handler was triggered, the offset won't be committed to Kafka.

> **Warning** For event handlers (event-based communication), all unhandled exceptions are considered **retriable exceptions** by default.

For this, you can use a dedicated class called `KafkaRetriableException`, as follows:

content\_copy

```typescript

throw new KafkaRetriableException('...');

```

> **Hint** `KafkaRetriableException` class is exported from the `@nestjs/microservices` package.

### Custom exception handling

Along with the default error handling mechanisms, you can create a custom Exception Filter for Kafka events to manage retry logic. For instance, the example below demonstrates how to skip a problematic event after a configurable number of retries:

content\_copy

```typescript

import { Catch, ArgumentsHost, Logger } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { KafkaContext } from '../ctx-host';

@Catch()
export class KafkaMaxRetryExceptionFilter extends BaseExceptionFilter {
  private readonly logger = new Logger(KafkaMaxRetryExceptionFilter.name);

  constructor(
    private readonly maxRetries: number,
    // Optional custom function executed when max retries are exceeded
    private readonly skipHandler?: (message: any) => Promise<void>,
  ) {
    super();
  }

  async catch(exception: unknown, host: ArgumentsHost) {
    const kafkaContext = host.switchToRpc().getContext<KafkaContext>();
    const message = kafkaContext.getMessage();
    const currentRetryCount = this.getRetryCountFromContext(kafkaContext);

    if (currentRetryCount >= this.maxRetries) {
      this.logger.warn(
        `Max retries (${
          this.maxRetries
        }) exceeded for message: ${JSON.stringify(message)}`,
      );

      if (this.skipHandler) {
        try {
          await this.skipHandler(message);
        } catch (err) {
          this.logger.error('Error in skipHandler:', err);
        }
      }

      try {
        await this.commitOffset(kafkaContext);
      } catch (commitError) {
        this.logger.error('Failed to commit offset:', commitError);
      }
      return; // Stop propagating the exception
    }

    // If retry count is below the maximum, proceed with the default Exception Filter logic
    super.catch(exception, host);
  }

  private getRetryCountFromContext(context: KafkaContext): number {
    const headers = context.getMessage().headers || {};
    const retryHeader = headers['retryCount'] || headers['retry-count'];
    return retryHeader ? Number(retryHeader) : 0;
  }

  private async commitOffset(context: KafkaContext): Promise<void> {
    const consumer = context.getConsumer && context.getConsumer();
    if (!consumer) {
      throw new Error('Consumer instance is not available from KafkaContext.');
    }

    const topic = context.getTopic && context.getTopic();
    const partition = context.getPartition && context.getPartition();
    const message = context.getMessage();
    const offset = message.offset;

    if (!topic || partition === undefined || offset === undefined) {
      throw new Error(
        'Incomplete Kafka message context for committing offset.',
      );
    }

    await consumer.commitOffsets([\
      {\
        topic,\
        partition,\
        // When committing an offset, commit the next number (i.e., current offset + 1)\
        offset: (Number(offset) + 1).toString(),\
      },\
    ]);
  }
}

```

This filter offers a way to retry processing a Kafka event up to a configurable number of times. Once the maximum retries are reached, it triggers a custom `skipHandler` (if provided) and commits the offset, effectively skipping the problematic event. This allows subsequent events to be processed without interruption.

You can integrate this filter by adding it to your event handlers:

content\_copy

```typescript

@UseFilters(new KafkaMaxRetryExceptionFilter(5))
export class MyEventHandler {
  @EventPattern('your-topic')
  async handleEvent(@Payload() data: any, @Ctx() context: KafkaContext) {
    // Your event processing logic...
  }
}

```

#### Commit offsets [\#](https://docs.nestjs.com/microservices/kafka\#commit-offsets)

Committing offsets is essential when working with Kafka. Per default, messages will be automatically committed after a specific time. For more information visit [KafkaJS docs](https://kafka.js.org/docs/consuming#autocommit). `KafkaContext` offers a way to access the active consumer for manually committing offsets. The consumer is the KafkaJS consumer and works as the [native KafkaJS implementation](https://kafka.js.org/docs/consuming#manual-committing).

content\_copy

JS  TS

```typescript

@EventPattern('user.created')
async handleUserCreated(@Payload() data: IncomingMessage, @Ctx() context: KafkaContext) {
  // business logic

  const { offset } = context.getMessage();
  const partition = context.getPartition();
  const topic = context.getTopic();
  const consumer = context.getConsumer();
  await consumer.commitOffsets([{ topic, partition, offset }])
}

```

```typescript

@Bind(Payload(), Ctx())
@EventPattern('user.created')
async handleUserCreated(data, context) {
  // business logic

  const { offset } = context.getMessage();
  const partition = context.getPartition();
  const topic = context.getTopic();
  const consumer = context.getConsumer();
  await consumer.commitOffsets([{ topic, partition, offset }])
}

```

To disable auto-committing of messages set `autoCommit: false` in the `run` configuration, as follows:

content\_copy main.ts

JS  TS

```typescript

const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      brokers: ['localhost:9092'],
    },
    run: {
      autoCommit: false
    }
  }
});

```

```typescript

const app = await NestFactory.createMicroservice(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      brokers: ['localhost:9092'],
    },
    run: {
      autoCommit: false
    }
  }
});

```

#### Instance status updates [\#](https://docs.nestjs.com/microservices/kafka\#instance-status-updates)

To get real-time updates on the connection and the state of the underlying driver instance, you can subscribe to the `status` stream. This stream provides status updates specific to the chosen driver. For the Kafka driver, the `status` stream emits `connected`, `disconnected`, `rebalancing`, `crashed`, and `stopped` events.

content\_copy

```typescript

this.client.status.subscribe((status: KafkaStatus) => {
  console.log(status);
});

```

> **Hint** The `KafkaStatus` type is imported from the `@nestjs/microservices` package.

Similarly, you can subscribe to the server's `status` stream to receive notifications about the server's status.

content\_copy

```typescript

const server = app.connectMicroservice<MicroserviceOptions>(...);
server.status.subscribe((status: KafkaStatus) => {
  console.log(status);
});

```

#### Underlying producer and consumer [\#](https://docs.nestjs.com/microservices/kafka\#underlying-producer-and-consumer)

For more advanced use cases, you may need to access the underlying producer and consumer instances. This can be useful for scenarios like manually closing the connection or using driver-specific methods. However, keep in mind that for most cases, you **shouldn't need** to access the driver directly.

To do so, you can use `producer` and `consumer` getters exposed by the `ClientKafkaProxy` instance.

content\_copy

```typescript

const producer = this.client.producer;
const consumer = this.client.consumer;

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Nest Libraries Guide
- [Libraries](https://docs.nestjs.com/cli/libraries#libraries)
- [Nest libraries](https://docs.nestjs.com/cli/libraries#nest-libraries)
- [Creating libraries](https://docs.nestjs.com/cli/libraries#creating-libraries)
- [Using libraries](https://docs.nestjs.com/cli/libraries#using-libraries)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/cli/libraries.md "Suggest Edits")

### Libraries

Many applications need to solve the same general problems, or re-use a modular component in several different contexts. Nest has a few ways of addressing this, but each works at a different level to solve the problem in a way that helps meet different architectural and organizational objectives.

Nest [modules](https://docs.nestjs.com/modules) are useful for providing an execution context that enables sharing components within a single application. Modules can also be packaged with [npm](https://npmjs.com/) to create a reusable library that can be installed in different projects. This can be an effective way to distribute configurable, re-usable libraries that can be used by different, loosely connected or unaffiliated organizations (e.g., by distributing/installing 3rd party libraries).

For sharing code within closely organized groups (e.g., within company/project boundaries), it can be useful to have a more lightweight approach to sharing components. Monorepos have arisen as a construct to enable that, and within a monorepo, a **library** provides a way to share code in an easy, lightweight fashion. In a Nest monorepo, using libraries enables easy assembly of applications that share components. In fact, this encourages decomposition of monolithic applications and development processes to focus on building and composing modular components.

#### Nest libraries [\#](https://docs.nestjs.com/cli/libraries\#nest-libraries)

A Nest library is a Nest project that differs from an application in that it cannot run on its own. A library must be imported into a containing application in order for its code to execute. The built-in support for libraries described in this section is only available for **monorepos** (standard mode projects can achieve similar functionality using npm packages).

For example, an organization may develop an `AuthModule` that manages authentication by implementing company policies that govern all internal applications. Rather than build that module separately for each application, or physically packaging the code with npm and requiring each project to install it, a monorepo can define this module as a library. When organized this way, all consumers of the library module can see an up-to-date version of the `AuthModule` as it is committed. This can have significant benefits for coordinating component development and assembly, and simplifying end-to-end testing.

#### Creating libraries [\#](https://docs.nestjs.com/cli/libraries\#creating-libraries)

Any functionality that is suitable for re-use is a candidate for being managed as a library. Deciding what should be a library, and what should be part of an application, is an architectural design decision. Creating libraries involves more than simply copying code from an existing application to a new library. When packaged as a library, the library code must be decoupled from the application. This may require **more** time up front and force some design decisions that you may not face with more tightly coupled code. But this additional effort can pay off when the library can be used to enable more rapid application assembly across multiple applications.

To get started with creating a library, run the following command:

```bash

$ nest g library my-library

```

When you run the command, the `library` schematic prompts you for a prefix (AKA alias) for the library:

```bash

What prefix would you like to use for the library (default: @app)?

```

This creates a new project in your workspace called `my-library`.
A library-type project, like an application-type project, is generated into a named folder using a schematic. Libraries are managed under the `libs` folder of the monorepo root. Nest creates the `libs` folder the first time a library is created.

The files generated for a library are slightly different from those generated for an application. Here is the contents of the `libs` folder after executing the command above:

libs

my-library

src

index.ts

my-library.module.ts

my-library.service.ts

tsconfig.lib.json

The `nest-cli.json` file will have a new entry for the library under the `"projects"` key:

```javascript

...
{
    "my-library": {
      "type": "library",
      "root": "libs/my-library",
      "entryFile": "index",
      "sourceRoot": "libs/my-library/src",
      "compilerOptions": {
        "tsConfigPath": "libs/my-library/tsconfig.lib.json"
      }
}
...

```

There are two differences in `nest-cli.json` metadata between libraries and applications:

- the `"type"` property is set to `"library"` instead of `"application"`
- the `"entryFile"` property is set to `"index"` instead of `"main"`

These differences key the build process to handle libraries appropriately. For example, a library exports its functions through the `index.js` file.

As with application-type projects, libraries each have their own `tsconfig.lib.json` file that extends the root (monorepo-wide) `tsconfig.json` file. You can modify this file, if necessary, to provide library-specific compiler options.

You can build the library with the CLI command:

```bash

$ nest build my-library

```

#### Using libraries [\#](https://docs.nestjs.com/cli/libraries\#using-libraries)

With the automatically generated configuration files in place, using libraries is straightforward. How would we import `MyLibraryService` from the `my-library` library into the `my-project` application?

First, note that using library modules is the same as using any other Nest module. What the monorepo does is manage paths in a way that importing libraries and generating builds is now transparent. To use `MyLibraryService`, we need to import its declaring module. We can modify `my-project/src/app.module.ts` as follows to import `MyLibraryModule`.

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { MyLibraryModule } from '@app/my-library';

@Module({
  imports: [MyLibraryModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

Notice above that we've used a path alias of `@app` in the ES module `import` line, which was the `prefix` we supplied with the `nest g library` command above. Under the covers, Nest handles this through tsconfig path mapping. When adding a library, Nest updates the global (monorepo) `tsconfig.json` file's `"paths"` key like this:

```javascript

"paths": {
    "@app/my-library": [\
        "libs/my-library/src"\
    ],
    "@app/my-library/*": [\
        "libs/my-library/src/*"\
    ]
}

```

So, in a nutshell, the combination of the monorepo and library features has made it easy and intuitive to include library modules into applications.

This same mechanism enables building and deploying applications that compose libraries. Once you've imported the `MyLibraryModule`, running `nest build` handles all the module resolution automatically and bundles the app along with any library dependencies, for deployment. The default compiler for a monorepo is **webpack**, so the resulting distribution file is a single file that bundles all of the transpiled JavaScript files into a single file. You can also switch to `tsc` as described [here](https://docs.nestjs.com/cli/monorepo#global-compiler-options).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS GraphQL Extensions
- [Extensions](https://docs.nestjs.com/graphql/extensions#extensions)
- [Adding custom metadata](https://docs.nestjs.com/graphql/extensions#adding-custom-metadata)
- [Using custom metadata](https://docs.nestjs.com/graphql/extensions#using-custom-metadata)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/extensions.md "Suggest Edits")

### Extensions

> **Warning** This chapter applies only to the code first approach.

Extensions is an **advanced, low-level feature** that lets you define arbitrary data in the types configuration. Attaching custom metadata to certain fields allows you to create more sophisticated, generic solutions. For example, with extensions, you can define field-level roles required to access particular fields. Such roles can be reflected at runtime to determine whether the caller has sufficient permissions to retrieve a specific field.

#### Adding custom metadata [\#](https://docs.nestjs.com/graphql/extensions\#adding-custom-metadata)

To attach custom metadata for a field, use the `@Extensions()` decorator exported from the `@nestjs/graphql` package.

content\_copy

```typescript

@Field()
@Extensions({ role: Role.ADMIN })
password: string;

```

In the example above, we assigned the `role` metadata property the value of `Role.ADMIN`. `Role` is a simple TypeScript enum that groups all the user roles available in our system.

Note, in addition to setting metadata on fields, you can use the `@Extensions()` decorator at the class level and method level (e.g., on the query handler).

#### Using custom metadata [\#](https://docs.nestjs.com/graphql/extensions\#using-custom-metadata)

Logic that leverages the custom metadata can be as complex as needed. For example, you can create a simple interceptor that stores/logs events per method invocation, or a [field middleware](https://docs.nestjs.com/graphql/field-middleware) that matches roles required to retrieve a field with the caller permissions (field-level permissions system).

For illustration purposes, let's define a `checkRoleMiddleware` that compares a user's role (hardcoded here) with a role required to access a target field:

content\_copy

```typescript

export const checkRoleMiddleware: FieldMiddleware = async (
  ctx: MiddlewareContext,
  next: NextFn,
) => {
  const { info } = ctx;
  const { extensions } = info.parentType.getFields()[info.fieldName];

  /**
   * In a real-world application, the "userRole" variable
   * should represent the caller's (user) role (for example, "ctx.user.role").
   */
  const userRole = Role.USER;
  if (userRole === extensions.role) {
    // or just "return null" to ignore
    throw new ForbiddenException(
      `User does not have sufficient permissions to access "${info.fieldName}" field.`,
    );
  }
  return next();
};

```

With this in place, we can register a middleware for the `password` field, as follows:

content\_copy

```typescript

@Field({ middleware: [checkRoleMiddleware] })
@Extensions({ role: Role.ADMIN })
password: string;

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Testing Guide
- [Testing](https://docs.nestjs.com/fundamentals/testing#testing)
- [Installation](https://docs.nestjs.com/fundamentals/testing#installation)
- [Unit testing](https://docs.nestjs.com/fundamentals/testing#unit-testing)
- [Testing utilities](https://docs.nestjs.com/fundamentals/testing#testing-utilities)
- [Auto mocking](https://docs.nestjs.com/fundamentals/testing#auto-mocking)
- [End-to-end testing](https://docs.nestjs.com/fundamentals/testing#end-to-end-testing)
- [Overriding globally registered enhancers](https://docs.nestjs.com/fundamentals/testing#overriding-globally-registered-enhancers)
- [Testing request-scoped instances](https://docs.nestjs.com/fundamentals/testing#testing-request-scoped-instances)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/unit-testing.md "Suggest Edits")

### Testing

Automated testing is considered an essential part of any serious software development effort. Automation makes it easy to repeat individual tests or test suites quickly and easily during development. This helps ensure that releases meet quality and performance goals. Automation helps increase coverage and provides a faster feedback loop to developers. Automation both increases the productivity of individual developers and ensures that tests are run at critical development lifecycle junctures, such as source code control check-in, feature integration, and version release.

Such tests often span a variety of types, including unit tests, end-to-end (e2e) tests, integration tests, and so on. While the benefits are unquestionable, it can be tedious to set them up. Nest strives to promote development best practices, including effective testing, so it includes features such as the following to help developers and teams build and automate tests. Nest:

- automatically scaffolds default unit tests for components and e2e tests for applications
- provides default tooling (such as a test runner that builds an isolated module/application loader)
- provides integration with [Jest](https://github.com/facebook/jest) and [Supertest](https://github.com/visionmedia/supertest) out-of-the-box, while remaining agnostic to testing tools
- makes the Nest dependency injection system available in the testing environment for easily mocking components

As mentioned, you can use any **testing framework** that you like, as Nest doesn't force any specific tooling. Simply replace the elements needed (such as the test runner), and you will still enjoy the benefits of Nest's ready-made testing facilities.

#### Installation [\#](https://docs.nestjs.com/fundamentals/testing\#installation)

To get started, first install the required package:

```bash

$ npm i --save-dev @nestjs/testing

```

#### Unit testing [\#](https://docs.nestjs.com/fundamentals/testing\#unit-testing)

In the following example, we test two classes: `CatsController` and `CatsService`. As mentioned, [Jest](https://github.com/facebook/jest) is provided as the default testing framework. It serves as a test-runner and also provides assert functions and test-double utilities that help with mocking, spying, etc. In the following basic test, we manually instantiate these classes, and ensure that the controller and service fulfill their API contract.

content\_copy cats.controller.spec.ts

JS  TS

```typescript

import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let catsController: CatsController;
  let catsService: CatsService;

  beforeEach(() => {
    catsService = new CatsService();
    catsController = new CatsController(catsService);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test'];
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

      expect(await catsController.findAll()).toBe(result);
    });
  });
});

```

```typescript

import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let catsController;
  let catsService;

  beforeEach(() => {
    catsService = new CatsService();
    catsController = new CatsController(catsService);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test'];
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

      expect(await catsController.findAll()).toBe(result);
    });
  });
});

```

> **Hint** Keep your test files located near the classes they test. Testing files should have a `.spec` or `.test` suffix.

Because the above sample is trivial, we aren't really testing anything Nest-specific. Indeed, we aren't even using dependency injection (notice that we pass an instance of `CatsService` to our `catsController`). This form of testing - where we manually instantiate the classes being tested - is often called **isolated testing** as it is independent from the framework. Let's introduce some more advanced capabilities that help you test applications that make more extensive use of Nest features.

#### Testing utilities [\#](https://docs.nestjs.com/fundamentals/testing\#testing-utilities)

The `@nestjs/testing` package provides a set of utilities that enable a more robust testing process. Let's rewrite the previous example using the built-in `Test` class:

content\_copy cats.controller.spec.ts

JS  TS

```typescript

import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let catsController: CatsController;
  let catsService: CatsService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
        controllers: [CatsController],
        providers: [CatsService],
      }).compile();

    catsService = moduleRef.get(CatsService);
    catsController = moduleRef.get(CatsController);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test'];
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

      expect(await catsController.findAll()).toBe(result);
    });
  });
});

```

```typescript

import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let catsController;
  let catsService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
        controllers: [CatsController],
        providers: [CatsService],
      }).compile();

    catsService = moduleRef.get(CatsService);
    catsController = moduleRef.get(CatsController);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test'];
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

      expect(await catsController.findAll()).toBe(result);
    });
  });
});

```

The `Test` class is useful for providing an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The `Test` class has a `createTestingModule()` method that takes a module metadata object as its argument (the same object you pass to the `@Module()` decorator). This method returns a `TestingModule` instance which in turn provides a few methods. For unit tests, the important one is the `compile()` method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional `main.ts` file using `NestFactory.create()`), and returns a module that is ready for testing.

> **Hint** The `compile()` method is **asynchronous** and therefore has to be awaited. Once the module is compiled you can retrieve any **static** instance it declares (controllers and providers) using the `get()` method.

`TestingModule` inherits from the [module reference](https://docs.nestjs.com/fundamentals/module-ref) class, and therefore its ability to dynamically resolve scoped providers (transient or request-scoped). Do this with the `resolve()` method (the `get()` method can only retrieve static instances).

content\_copy

```typescript

const moduleRef = await Test.createTestingModule({
  controllers: [CatsController],
  providers: [CatsService],
}).compile();

catsService = await moduleRef.resolve(CatsService);

```

> **Warning** The `resolve()` method returns a unique instance of the provider, from its own **DI container sub-tree**. Each sub-tree has a unique context identifier. Thus, if you call this method more than once and compare instance references, you will see that they are not equal.

> **Hint** Learn more about the module reference features [here](https://docs.nestjs.com/fundamentals/module-ref).

Instead of using the production version of any provider, you can override it with a [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) for testing purposes. For example, you can mock a database service instead of connecting to a live database. We'll cover overrides in the next section, but they're available for unit tests as well.

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Auto mocking [\#](https://docs.nestjs.com/fundamentals/testing\#auto-mocking)

Nest also allows you to define a mock factory to apply to all of your missing dependencies. This is useful for cases where you have a large number of dependencies in a class and mocking all of them will take a long time and a lot of setup. To make use of this feature, the `createTestingModule()` will need to be chained up with the `useMocker()` method, passing a factory for your dependency mocks. This factory can take in an optional token, which is an instance token, any token which is valid for a Nest provider, and returns a mock implementation. The below is an example of creating a generic mocker using [`jest-mock`](https://www.npmjs.com/package/jest-mock) and a specific mock for `CatsService` using `jest.fn()`.

content\_copy

```typescript

// ...
import { ModuleMocker, MockMetadata } from 'jest-mock';

const moduleMocker = new ModuleMocker(global);

describe('CatsController', () => {
  let controller: CatsController;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [CatsController],
    })
      .useMocker((token) => {
        const results = ['test1', 'test2'];
        if (token === CatsService) {
          return { findAll: jest.fn().mockResolvedValue(results) };
        }
        if (typeof token === 'function') {
          const mockMetadata = moduleMocker.getMetadata(
            token,
          ) as MockMetadata<any, any>;
          const Mock = moduleMocker.generateFromMetadata(
            mockMetadata,
          ) as ObjectConstructor;
          return new Mock();
        }
      })
      .compile();

    controller = moduleRef.get(CatsController);
  });
});

```

You can also retrieve these mocks out of the testing container as you normally would custom providers, `moduleRef.get(CatsService)`.

> **Hint** A general mock factory, like `createMock` from [`@golevelup/ts-jest`](https://github.com/golevelup/nestjs/tree/master/packages/testing) can also be passed directly.

> **Hint** `REQUEST` and `INQUIRER` providers cannot be auto-mocked because they're already pre-defined in the context. However, they can be _overwritten_ using the custom provider syntax or by utilizing the `.overrideProvider` method.

#### End-to-end testing [\#](https://docs.nestjs.com/fundamentals/testing\#end-to-end-testing)

Unlike unit testing, which focuses on individual modules and classes, end-to-end (e2e) testing covers the interaction of classes and modules at a more aggregate level -- closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements. To perform e2e tests we use a similar configuration to the one we just covered in **unit testing**. In addition, Nest makes it easy to use the [Supertest](https://github.com/visionmedia/supertest) library to simulate HTTP requests.

content\_copy cats.e2e-spec.ts

JS  TS

```typescript

import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { CatsModule } from '../../src/cats/cats.module';
import { CatsService } from '../../src/cats/cats.service';
import { INestApplication } from '@nestjs/common';

describe('Cats', () => {
  let app: INestApplication;
  let catsService = { findAll: () => ['test'] };

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [CatsModule],
    })
      .overrideProvider(CatsService)
      .useValue(catsService)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it(`/GET cats`, () => {
    return request(app.getHttpServer())
      .get('/cats')
      .expect(200)
      .expect({
        data: catsService.findAll(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});

```

```typescript

import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { CatsModule } from '../../src/cats/cats.module';
import { CatsService } from '../../src/cats/cats.service';
import { INestApplication } from '@nestjs/common';

describe('Cats', () => {
  let app: INestApplication;
  let catsService = { findAll: () => ['test'] };

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [CatsModule],
    })
      .overrideProvider(CatsService)
      .useValue(catsService)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it(`/GET cats`, () => {
    return request(app.getHttpServer())
      .get('/cats')
      .expect(200)
      .expect({
        data: catsService.findAll(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});

```

> **Hint** If you're using [Fastify](https://docs.nestjs.com/techniques/performance) as your HTTP adapter, it requires a slightly different configuration, and has built-in testing capabilities:
> content\_copy
>
> ```ts
>
> let app: NestFastifyApplication;
>
> beforeAll(async () => {
>   app = moduleRef.createNestApplication<NestFastifyApplication>(
>     new FastifyAdapter(),
>   );
>
>   await app.init();
>   await app.getHttpAdapter().getInstance().ready();
> });
>
> it(`/GET cats`, () => {
>   return app
>     .inject({
>       method: 'GET',
>       url: '/cats',
>     })
>     .then((result) => {
>       expect(result.statusCode).toEqual(200);
>       expect(result.payload).toEqual(/* expectedPayload */);
>     });
> });
>
> afterAll(async () => {
>   await app.close();
> });
>
> ```

In this example, we build on some of the concepts described earlier. In addition to the `compile()` method we used earlier, we now use the `createNestApplication()` method to instantiate a full Nest runtime environment.

One caveat to consider is that when your application is compiled using the `compile()` method, the `HttpAdapterHost#httpAdapter` will be undefined at that time. This is because there isn't an HTTP adapter or server created yet during this compilation phase. If your test requires the `httpAdapter`, you should use the `createNestApplication()` method to create the application instance, or refactor your project to avoid this dependency when initializing the dependencies graph.

Alright, let's break down the example:

We save a reference to the running app in our `app` variable so we can use it to simulate HTTP requests.

We simulate HTTP tests using the `request()` function from Supertest. We want these HTTP requests to route to our running Nest app, so we pass the `request()` function a reference to the HTTP listener that underlies Nest (which, in turn, may be provided by the Express platform). Hence the construction `request(app.getHttpServer())`. The call to `request()` hands us a wrapped HTTP Server, now connected to the Nest app, which exposes methods to simulate an actual HTTP request. For example, using `request(...).get('/cats')` will initiate a request to the Nest app that is identical to an **actual** HTTP request like `get '/cats'` coming in over the network.

In this example, we also provide an alternate (test-double) implementation of the `CatsService` which simply returns a hard-coded value that we can test for. Use `overrideProvider()` to provide such an alternate implementation. Similarly, Nest provides methods to override modules, guards, interceptors, filters and pipes with the `overrideModule()`, `overrideGuard()`, `overrideInterceptor()`, `overrideFilter()`, and `overridePipe()` methods respectively.

Each of the override methods (except for `overrideModule()`) returns an object with 3 different methods that mirror those described for [custom providers](https://docs.nestjs.com/fundamentals/custom-providers):

- `useClass`: you supply a class that will be instantiated to provide the instance to override the object (provider, guard, etc.).
- `useValue`: you supply an instance that will override the object.
- `useFactory`: you supply a function that returns an instance that will override the object.

On the other hand, `overrideModule()` returns an object with the `useModule()` method, which you can use to supply a module that will override the original module, as follows:

content\_copy

```typescript

const moduleRef = await Test.createTestingModule({
  imports: [AppModule],
})
  .overrideModule(CatsModule)
  .useModule(AlternateCatsModule)
  .compile();

```

Each of the override method types, in turn, returns the `TestingModule` instance, and can thus be chained with other methods in the [fluent style](https://en.wikipedia.org/wiki/Fluent_interface). You should use `compile()` at the end of such a chain to cause Nest to instantiate and initialize the module.

Also, sometimes you may want to provide a custom logger e.g. when the tests are run (for example, on a CI server). Use the `setLogger()` method and pass an object that fulfills the `LoggerService` interface to instruct the `TestModuleBuilder` how to log during tests (by default, only "error" logs will be logged to the console).

The compiled module has several useful methods, as described in the following table:

|     |     |
| --- | --- |
| `createNestApplication()` | Creates and returns a Nest application ( `INestApplication` instance) based on the given module. Note that you must manually initialize the application using the `init()` method. |
| `createNestMicroservice()` | Creates and returns a Nest microservice ( `INestMicroservice` instance) based on the given module. |
| `get()` | Retrieves a static instance of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the [module reference](https://docs.nestjs.com/fundamentals/module-ref) class. |
| `resolve()` | Retrieves a dynamically created scoped instance (request or transient) of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the [module reference](https://docs.nestjs.com/fundamentals/module-ref) class. |
| `select()` | Navigates through the module's dependency graph; can be used to retrieve a specific instance from the selected module (used along with strict mode ( `strict: true`) in `get()` method). |

> **Hint** Keep your e2e test files inside the `test` directory. The testing files should have a `.e2e-spec` suffix.

#### Overriding globally registered enhancers [\#](https://docs.nestjs.com/fundamentals/testing\#overriding-globally-registered-enhancers)

If you have a globally registered guard (or pipe, interceptor, or filter), you need to take a few more steps to override that enhancer. To recap the original registration looks like this:

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useClass: JwtAuthGuard,\
  },\
],

```

This is registering the guard as a "multi"-provider through the `APP_*` token. To be able to replace the `JwtAuthGuard` here, the registration needs to use an existing provider in this slot:

content\_copy

```typescript

providers: [\
  {\
    provide: APP_GUARD,\
    useExisting: JwtAuthGuard,\
    // ^^^^^^^^ notice the use of 'useExisting' instead of 'useClass'\
  },\
  JwtAuthGuard,\
],

```

> **Hint** Change the `useClass` to `useExisting` to reference a registered provider instead of having Nest instantiate it behind the token.

Now the `JwtAuthGuard` is visible to Nest as a regular provider that can be overridden when creating the `TestingModule`:

content\_copy

```typescript

const moduleRef = await Test.createTestingModule({
  imports: [AppModule],
})
  .overrideProvider(JwtAuthGuard)
  .useClass(MockAuthGuard)
  .compile();

```

Now all your tests will use the `MockAuthGuard` on every request.

#### Testing request-scoped instances [\#](https://docs.nestjs.com/fundamentals/testing\#testing-request-scoped-instances)

[Request-scoped](https://docs.nestjs.com/fundamentals/injection-scopes) providers are created uniquely for each incoming **request**. The instance is garbage-collected after the request has completed processing. This poses a problem, because we can't access a dependency injection sub-tree generated specifically for a tested request.

We know (based on the sections above) that the `resolve()` method can be used to retrieve a dynamically instantiated class. Also, as described [here](https://docs.nestjs.com/fundamentals/module-ref#resolving-scoped-providers), we know we can pass a unique context identifier to control the lifecycle of a DI container sub-tree. How do we leverage this in a testing context?

The strategy is to generate a context identifier beforehand and force Nest to use this particular ID to create a sub-tree for all incoming requests. In this way we'll be able to retrieve instances created for a tested request.

To accomplish this, use `jest.spyOn()` on the `ContextIdFactory`:

content\_copy

```typescript

const contextId = ContextIdFactory.create();
jest
  .spyOn(ContextIdFactory, 'getByRequest')
  .mockImplementation(() => contextId);

```

Now we can use the `contextId` to access a single generated DI container sub-tree for any subsequent request.

content\_copy

```typescript

catsService = await moduleRef.resolve(CatsService, contextId);

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## GraphQL Interfaces Overview
- [Interfaces](https://docs.nestjs.com/graphql/interfaces#interfaces)
- [Code first](https://docs.nestjs.com/graphql/interfaces#code-first)
- [Interface resolvers](https://docs.nestjs.com/graphql/interfaces#interface-resolvers)
- [Schema first](https://docs.nestjs.com/graphql/interfaces#schema-first)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/interfaces.md "Suggest Edits")

### Interfaces

Like many type systems, GraphQL supports interfaces. An **Interface** is an abstract type that includes a certain set of fields that a type must include to implement the interface (read more [here](https://graphql.org/learn/schema/#interfaces)).

#### Code first [\#](https://docs.nestjs.com/graphql/interfaces\#code-first)

When using the code first approach, you define a GraphQL interface by creating an abstract class annotated with the `@InterfaceType()` decorator exported from the `@nestjs/graphql`.

content\_copy

```typescript

import { Field, ID, InterfaceType } from '@nestjs/graphql';

@InterfaceType()
export abstract class Character {
  @Field(() => ID)
  id: string;

  @Field()
  name: string;
}

```

> **Warning** TypeScript interfaces cannot be used to define GraphQL interfaces.

This will result in generating the following part of the GraphQL schema in SDL:

```graphql

interface Character {
  id: ID!
  name: String!
}

```

Now, to implement the `Character` interface, use the `implements` key:

content\_copy

```typescript

@ObjectType({
  implements: () => [Character],
})
export class Human implements Character {
  id: string;
  name: string;
}

```

> **Hint** The `@ObjectType()` decorator is exported from the `@nestjs/graphql` package.

The default `resolveType()` function generated by the library extracts the type based on the value returned from the resolver method. This means that you must return class instances (you cannot return literal JavaScript objects).

To provide a customized `resolveType()` function, pass the `resolveType` property to the options object passed into the `@InterfaceType()` decorator, as follows:

content\_copy

```typescript

@InterfaceType({
  resolveType(book) {
    if (book.colors) {
      return ColoringBook;
    }
    return TextBook;
  },
})
export abstract class Book {
  @Field(() => ID)
  id: string;

  @Field()
  title: string;
}

```

#### Interface resolvers [\#](https://docs.nestjs.com/graphql/interfaces\#interface-resolvers)

So far, using interfaces, you could only share field definitions with your objects. If you also want to share the actual field resolvers implementation, you can create a dedicated interface resolver, as follows:

content\_copy

```typescript

import { Resolver, ResolveField, Parent, Info } from '@nestjs/graphql';

@Resolver((type) => Character) // Reminder: Character is an interface
export class CharacterInterfaceResolver {
  @ResolveField(() => [Character])
  friends(
    @Parent() character, // Resolved object that implements Character
    @Info() { parentType }, // Type of the object that implements Character
    @Args('search', { type: () => String }) searchTerm: string,
  ) {
    // Get character's friends
    return [];
  }
}

```

Now the `friends` field resolver is auto-registered for all object types that implement the `Character` interface.

> **Warning** This requires the `inheritResolversFromInterfaces` property set to be true in the `GraphQLModule` configuration.

#### Schema first [\#](https://docs.nestjs.com/graphql/interfaces\#schema-first)

To define an interface in the schema first approach, simply create a GraphQL interface with SDL.

```graphql

interface Character {
  id: ID!
  name: String!
}

```

Then, you can use the typings generation feature (as shown in the [quick start](https://docs.nestjs.com/graphql/quick-start) chapter) to generate corresponding TypeScript definitions:

content\_copy

```typescript

export interface Character {
  id: string;
  name: string;
}

```

Interfaces require an extra `__resolveType` field in the resolver map to determine which type the interface should resolve to. Let's create a `CharactersResolver` class and define the `__resolveType` method:

content\_copy

```typescript

@Resolver('Character')
export class CharactersResolver {
  @ResolveField()
  __resolveType(value) {
    if ('age' in value) {
      return Person;
    }
    return null;
  }
}

```

> **Hint** All decorators are exported from the `@nestjs/graphql` package.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Companies Using NestJS
- [Who is using Nest?](https://docs.nestjs.com/discover/companies#who-is-using-nest)
- [Companies](https://docs.nestjs.com/discover/companies#companies)

### Who is using Nest?

We are proudly helping various companies building their products at scale.
If you are using Nest and would you like to be listed here, see this [thread](https://github.com/nestjs/nest/issues/1006).
We are willing to put your logo here!

#### Companies [\#](https://docs.nestjs.com/discover/companies\#companies)

According to our knowledge, all the following companies have built awesome projects on top of our framework:

[![](https://docs.nestjs.com/assets/logo/roche-logo.png)](https://roche.com/)[![](https://docs.nestjs.com/assets/logo/adidas.svg)](https://adidas.com/)[![](https://docs.nestjs.com/assets/logo/capgemini.svg)](https://capgemini.com/)[![](https://docs.nestjs.com/assets/logo/societe-generale-logo.png)](https://www.societegenerale.fr/)[![](https://docs.nestjs.com/assets/logo/rewe.svg)](https://rewe-digital.com/)[![](https://docs.nestjs.com/assets/logo/decathlon.png)](https://www.decathlon.com/)[![](https://docs.nestjs.com/assets/logo/autodesk.png)](https://www.autodesk.com/)[![](https://docs.nestjs.com/assets/logo/neo4j.png)](https://www.neo4j.com/)[![](https://docs.nestjs.com/assets/logo/bmw.svg)](https://bmw.com/)[![](https://docs.nestjs.com/assets/logo/gitlab.png)](https://gitlab.com/)[![](https://docs.nestjs.com/assets/logo/ibm.svg)](https://www.ibm.com/)[![](https://docs.nestjs.com/assets/logo/jetbrains.svg)](https://www.jetbrains.com/)[![](https://docs.nestjs.com/assets/logo/mercedes.png)](https://www.mercedes-benz.com/)[![](https://docs.nestjs.com/assets/logo/totalenergies.svg)](https://totalenergies.com/)[![](https://docs.nestjs.com/assets/logo/bytedance.png)](https://www.bytedance.com/)[![](https://docs.nestjs.com/assets/logo/shipt.png)](https://www.shipt.com/)[![](https://docs.nestjs.com/assets/logo/sanofi.png)](https://github.com/Sanofi-IADC)[![](https://docs.nestjs.com/assets/logo/sitepen.svg)](https://sitepen.com/)[![](https://nestjs.com/img/trilon.png)](https://trilon.io/)[![](https://docs.nestjs.com/assets/logo/vue-storefront.png)](https://www.vuestorefront.io/)[![](https://docs.nestjs.com/assets/logo/hingehealth.png)](https://hingehealth.com/)[![](https://docs.nestjs.com/assets/logo/whiskey-house.svg)](https://whiskeyhouse.com/)

|     |
| --- |
| [https://gorrion.io/](https://gorrion.io/) |
| [http://balticdatascience.com/](http://balticdatascience.com/) |
| [https://prohabits.com/](https://prohabits.com/) |
| [https://komed-health.com/](https://komed-health.com/) |
| [https://kerberus.com.co/](https://kerberus.com.co/) |
| [http://xtremis.com/](http://xtremis.com/) |
| [https://notadd.com/](https://notadd.com/) |
| [http://jsdaddy.io/](http://jsdaddy.io/) |
| [https://yumpingo.com/](https://yumpingo.com/) |
| [https://analytics-importer.cz/](https://analytics-importer.cz/) |
| [https://dayzim.com/](https://dayzim.com/) |
| [https://wizkids.co.uk/](https://wizkids.co.uk/) |
| [https://pilvia.com/](https://pilvia.com/) |
| [https://wi-q.com/](https://wi-q.com/) |
| [http://agrofel.com.br](http://agrofel.com.br/) |
| [https://societegenerale.com/](https://societegenerale.com/) |
| [https://trashpanda.hulan.nl/](https://trashpanda.hulan.nl/) |
| [https://bytedance.com/](https://bytedance.com/) |
| [https://votercircle.com](https://votercircle.com/) |
| [https://erento.com](https://erento.com/) |
| [https://ideas.manticore-labs.com/](https://ideas.manticore-labs.com/) |
| [https://smartexlab.com/](https://smartexlab.com/) |
| [https://automama.ru/](https://automama.ru/) |
| [https://iflix.com/](https://iflix.com/) |
| [https://frontendwatch.com/](https://frontendwatch.com/) |
| [https://mobilejazz.com/](https://mobilejazz.com/) |
| [https://cgiandi.com/](https://cgiandi.com/) |
| [https://www.titlex.com.au/](https://www.titlex.com.au/) |
| [https://codengage.com/](https://codengage.com/) |
| [https://budacode.com/](https://budacode.com/) |
| [https://blueanchor.io/](https://blueanchor.io/) |
| [https://www.easymetrics.com/](https://www.easymetrics.com/) |
| [https://getapollo.io/](https://getapollo.io/) |
| [https://big-bench.com/](https://big-bench.com/) |
| [https://www.qingtui.cn/](https://www.qingtui.cn/) |
| [https://www.rosebayconsult.com/](https://www.rosebayconsult.com/) |
| [https://www.patrocinium.com/](https://www.patrocinium.com/) |
| [https://creatorsdaily.com](https://creatorsdaily.com/) |
| [https://autoscar.com.br](https://autoscar.com.br/) |
| [https://www.mediktiv.com](https://www.mediktiv.com/) |
| [https://harmonize.health](https://harmonize.health/) |
| [https://accerlery.be](https://accerlery.be/) |
| [https://www.facile.it](https://www.facile.it/) |
| [https://shopback.com](https://shopback.com/) |
| [https://www.ottonova.de](https://www.ottonova.de/) |
| [https://www.radity.com](https://www.radity.com/) |
| [https://globalctoforum.org](https://globalctoforum.org/) |
| [https://halojasa.com](https://halojasa.com/) |
| [https://hexito.com](https://hexito.com/) |
| [https://rivvy.app](https://rivvy.app/) |
| [https://padfever.com/](https://padfever.com/) |
| [https://datenlotse.org](https://datenlotse.org/) |
| [https://bemum.co](https://bemum.co/) |
| [https://weoptimeye.ai](https://weoptimeye.ai/) |
| [https://nemovote.com](https://nemovote.com/) |
| [https://selleo.com](https://selleo.com/) |
| [https://pchas.ir](https://pchas.ir/) |
| [https://tayeh.ir](https://tayeh.ir/) |
| [https://forwardigital.co.uk](https://forwardigital.co.uk/) |
| [https://rozetka.com.ua](https://rozetka.com.ua/) |
| [https://www.itrio.net](https://www.itrio.net/) |
| [https://alexishr.com](https://alexishr.com/) |
| [https://dyrector.io](https://dyrector.io/) |
| [https://stijlbreuk.nl](https://stijlbreuk.nl/) |
| [https://polygon-software.ch](https://polygon-software.ch/) |
| [https://bewith.io](https://bewith.io/) |
| [https://swetrix.com](https://swetrix.com/) |
| [https://swyftlogistics.com](https://swyftlogistics.com/) |
| [https://evershop.io](https://evershop.io/) |
| [https://e-design.ca](https://e-design.ca/) |
| [https://growthmill.com](https://growthmill.com/) |
| [https://tarken.com.br](https://tarken.com.br/) |
| [https://remato.com](https://remato.com/) |
| [https://remberg.de/en](https://remberg.de/en) |
| [https://uninterrupted.tech](https://uninterrupted.tech/) |
| [https://www.digando.com](https://www.digando.com/) |
| [https://novu.co](https://novu.co/) |
| [https://aqreach.com](https://aqreach.com/) |
| [https://phalco.de](https://phalco.de/) |
| [https://www.tesseractpro.io](https://www.tesseractpro.io/) |
| [https://www.kwanso.com](https://www.kwanso.com/) |
| [https://cmdn.io](https://cmdn.io/) |
| [https://ayo.so](https://ayo.so/) |
| [https://devitjobs.com](https://devitjobs.com/) |
| [https://formation.tech](https://formation.tech/) |
| [https://gofirmex.com](https://gofirmex.com/) |
| [https://vbdhub.org](https://vbdhub.org/) |
| [https://www.arven-tech.com](https://www.arven-tech.com/) |

and a lot more but we don't have enough time to update above list. Feel free to create a [pull request](https://github.com/nestjs/docs.nestjs.com/pulls) though!

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS GraphQL Resolvers
- [Resolvers](https://docs.nestjs.com/graphql/resolvers#resolvers)
- [Code first](https://docs.nestjs.com/graphql/resolvers#code-first)
- [Object types](https://docs.nestjs.com/graphql/resolvers#object-types)
- [Code first resolver](https://docs.nestjs.com/graphql/resolvers#code-first-resolver)
- [Query type names](https://docs.nestjs.com/graphql/resolvers#query-type-names)
- [Query decorator options](https://docs.nestjs.com/graphql/resolvers#query-decorator-options)
- [Args decorator options](https://docs.nestjs.com/graphql/resolvers#args-decorator-options)
- [Dedicated arguments class](https://docs.nestjs.com/graphql/resolvers#dedicated-arguments-class)
- [Class inheritance](https://docs.nestjs.com/graphql/resolvers#class-inheritance)
- [Generics](https://docs.nestjs.com/graphql/resolvers#generics)
- [Schema first](https://docs.nestjs.com/graphql/resolvers#schema-first)
- [Schema first resolver](https://docs.nestjs.com/graphql/resolvers#schema-first-resolver)
- [Generating types](https://docs.nestjs.com/graphql/resolvers#generating-types)
- [GraphQL argument decorators](https://docs.nestjs.com/graphql/resolvers#graphql-argument-decorators)
- [Module](https://docs.nestjs.com/graphql/resolvers#module)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/resolvers-map.md "Suggest Edits")

### Resolvers

Resolvers provide the instructions for turning a [GraphQL](https://graphql.org/) operation (a query, mutation, or subscription) into data. They return the same shape of data we specify in our schema -- either synchronously or as a promise that resolves to a result of that shape. Typically, you create a **resolver map** manually. The `@nestjs/graphql` package, on the other hand, generates a resolver map automatically using the metadata provided by decorators you use to annotate classes. To demonstrate the process of using the package features to create a GraphQL API, we'll create a simple authors API.

#### Code first [\#](https://docs.nestjs.com/graphql/resolvers\#code-first)

In the code first approach, we don't follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The `@nestjs/graphql` package reads the metadata defined through the decorators and automatically generates the schema for you.

#### Object types [\#](https://docs.nestjs.com/graphql/resolvers\#object-types)

Most of the definitions in a GraphQL schema are **object types**. Each object type you define should represent a domain object that an application client might need to interact with. For example, our sample API needs to be able to fetch a list of authors and their posts, so we should define the `Author` type and `Post` type to support this functionality.

If we were using the schema first approach, we'd define such a schema with SDL like this:

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post!]!
}

```

In this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:

content\_copy authors/models/author.model.ts

JS  TS

```typescript

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Post } from './post';

@ObjectType()
export class Author {
  @Field(type => Int)
  id: number;

  @Field({ nullable: true })
  firstName?: string;

  @Field({ nullable: true })
  lastName?: string;

  @Field(type => [Post])
  posts: Post[];
}

```

> **Hint** TypeScript's metadata reflection system has several limitations which make it impossible, for instance, to determine what properties a class consists of or recognize whether a given property is optional or required. Because of these limitations, we must either explicitly use the `@Field()` decorator in our schema definition classes to provide metadata about each field's GraphQL type and optionality, or use a [CLI plugin](https://docs.nestjs.com/graphql/cli-plugin) to generate these for us.

The `Author` object type, like any class, is made of a collection of fields, with each field declaring a type. A field's type corresponds to a [GraphQL type](https://graphql.org/learn/schema/). A field's GraphQL type can be either another object type or a scalar type. A GraphQL scalar type is a primitive (like `ID`, `String`, `Boolean`, or `Int`) that resolves to a single value.

> **Hint** In addition to GraphQL's built-in scalar types, you can define custom scalar types (read [more](https://docs.nestjs.com/graphql/scalars)).

The above `Author` object type definition will cause Nest to **generate** the SDL we showed above:

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post!]!
}

```

The `@Field()` decorator accepts an optional type function (e.g., `type => Int`), and optionally an options object.

The type function is required when there's the potential for ambiguity between the TypeScript type system and the GraphQL type system. Specifically: it is **not** required for `string` and `boolean` types; it **is** required for `number` (which must be mapped to either a GraphQL `Int` or `Float`). The type function should simply return the desired GraphQL type (as shown in various examples in these chapters).

The options object can have any of the following key/value pairs:

- `nullable`: for specifying whether a field is nullable (in `@nestjs/graphql`, each field is non-nullable by default); `boolean`
- `description`: for setting a field description; `string`
- `deprecationReason`: for marking a field as deprecated; `string`

For example:

content\_copy

```typescript

@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })
title: string;

```

> **Hint** You can also add a description to, or deprecate, the whole object type: `@ObjectType({ description: 'Author model' })`.

When the field is an array, we must manually indicate the array type in the `Field()` decorator's type function, as shown below:

content\_copy

```typescript

@Field(type => [Post])
posts: Post[];

```

> **Hint** Using array bracket notation ( `[ ]`), we can indicate the depth of the array. For example, using `[[Int]]` would represent an integer matrix.

To declare that an array's items (not the array itself) are nullable, set the `nullable` property to `'items'` as shown below:

content\_copy

```typescript

@Field(type => [Post], { nullable: 'items' })
posts: Post[];

```

> **Hint** If both the array and its items are nullable, set `nullable` to `'itemsAndList'` instead.

Now that the `Author` object type is created, let's define the `Post` object type.

content\_copy posts/models/post.model.ts

JS  TS

```typescript

import { Field, Int, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class Post {
  @Field(type => Int)
  id: number;

  @Field()
  title: string;

  @Field(type => Int, { nullable: true })
  votes?: number;
}

```

The `Post` object type will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Post {
  id: Int!
  title: String!
  votes: Int
}

```

#### Code first resolver [\#](https://docs.nestjs.com/graphql/resolvers\#code-first-resolver)

At this point, we've defined the objects (type definitions) that can exist in our data graph, but clients don't yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, a resolver class both defines resolver functions **and** generates the **Query type**. This will be clear as we work through the example below:

content\_copy authors/authors.resolver.ts

JS  TS

```typescript

@Resolver(() => Author)
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query(() => Author)
  async author(@Args('id', { type: () => Int }) id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField()
  async posts(@Parent() author: Author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}

```

> **Hint** All decorators (e.g., `@Resolver`, `@ResolveField`, `@Args`, etc.) are exported from the `@nestjs/graphql` package.

You can define multiple resolver classes. Nest will combine these at run time. See the [module](https://docs.nestjs.com/graphql/resolvers#module) section below for more on code organization.

> **Note** The logic inside the `AuthorsService` and `PostsService` classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.

In the example above, we created the `AuthorsResolver` which defines one query resolver function and one field resolver function. To create a resolver, we create a class with resolver functions as methods, and annotate the class with the `@Resolver()` decorator.

In this example, we defined a query handler to get the author object based on the `id` sent in the request. To specify that the method is a query handler, use the `@Query()` decorator.

The argument passed to the `@Resolver()` decorator is optional, but comes into play when our graph becomes non-trivial. It's used to supply a parent object used by field resolver functions as they traverse down through an object graph.

In our example, since the class includes a **field resolver** function (for the `posts` property of the `Author` object type), we **must** supply the `@Resolver()` decorator with a value to indicate which class is the parent type (i.e., the corresponding `ObjectType` class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it's necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author's posts array with a field resolver that calls a service which takes the author's `id` as an argument. Hence the need to identify the parent object in the `@Resolver()` decorator. Note the corresponding use of the `@Parent()` method parameter decorator to then extract a reference to that parent object in the field resolver.

We can define multiple `@Query()` resolver functions (both within this class, and in any other resolver class), and they will be aggregated into a single **Query type** definition in the generated SDL along with the appropriate entries in the resolver map. This allows you to define queries close to the models and services that they use, and to keep them well organized in modules.

> **Hint** Nest CLI provides a generator (schematic) that automatically generates **all the boilerplate code** to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature [here](https://docs.nestjs.com/recipes/crud-generator).

#### Query type names [\#](https://docs.nestjs.com/graphql/resolvers\#query-type-names)

In the above examples, the `@Query()` decorator generates a GraphQL schema query type name based on the method name. For example, consider the following construction from the example above:

content\_copy

```typescript

@Query(() => Author)
async author(@Args('id', { type: () => Int }) id: number) {
  return this.authorsService.findOneById(id);
}

```

This generates the following entry for the author query in our schema (the query type uses the same name as the method name):

```graphql

type Query {
  author(id: Int!): Author
}

```

> **Hint** Learn more about GraphQL queries [here](https://graphql.org/learn/queries/).

Conventionally, we prefer to decouple these names; for example, we prefer to use a name like `getAuthor()` for our query handler method, but still use `author` for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the `@Query()` and `@ResolveField()` decorators, as shown below:

content\_copy authors/authors.resolver.ts

JS  TS

```typescript

@Resolver(() => Author)
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query(() => Author, { name: 'author' })
  async getAuthor(@Args('id', { type: () => Int }) id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField('posts', () => [Post])
  async getPosts(@Parent() author: Author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}

```

The `getAuthor` handler method above will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Query {
  author(id: Int!): Author
}

```

#### Query decorator options [\#](https://docs.nestjs.com/graphql/resolvers\#query-decorator-options)

The `@Query()` decorator's options object (where we pass `{name: 'author'}` above) accepts a number of key/value pairs:

- `name`: name of the query; a `string`
- `description`: a description that will be used to generate GraphQL schema documentation (e.g., in GraphQL playground); a `string`
- `deprecationReason`: sets query metadata to show the query as deprecated (e.g., in GraphQL playground); a `string`
- `nullable`: whether the query can return a null data response; `boolean` or `'items'` or `'itemsAndList'` (see above for details of `'items'` and `'itemsAndList'`)

#### Args decorator options [\#](https://docs.nestjs.com/graphql/resolvers\#args-decorator-options)

Use the `@Args()` decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to [REST route parameter argument extraction](https://docs.nestjs.com/controllers#route-parameters).

Usually your `@Args()` decorator will be simple, and not require an object argument as seen with the `getAuthor()` method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument.

content\_copy

```typescript

@Args('id') id: string

```

In the `getAuthor()` case, the `number` type is used, which presents a challenge. The `number` TypeScript type doesn't give us enough information about the expected GraphQL representation (e.g., `Int` vs. `Float`). Thus we have to **explicitly** pass the type reference. We do that by passing a second argument to the `Args()` decorator, containing argument options, as shown below:

content\_copy

```typescript

@Query(() => Author, { name: 'author' })
async getAuthor(@Args('id', { type: () => Int }) id: number) {
  return this.authorsService.findOneById(id);
}

```

The options object allows us to specify the following optional key value pairs:

- `type`: a function returning the GraphQL type
- `defaultValue`: a default value; `any`
- `description`: description metadata; `string`
- `deprecationReason`: to deprecate a field and provide meta data describing why; `string`
- `nullable`: whether the field is nullable

Query handler methods can take multiple arguments. Let's imagine that we want to fetch an author based on its `firstName` and `lastName`. In this case, we can call `@Args` twice:

content\_copy

```typescript

getAuthor(
  @Args('firstName', { nullable: true }) firstName?: string,
  @Args('lastName', { defaultValue: '' }) lastName?: string,
) {}

```

> **Hint** In the case of `firstName`, which is a GraphQL nullable field, it isn't necessary to add the non-value types of `null` or `undefined` to the type of this field. Just be aware, you'll need to type guard for these possible non-value types in your resolvers, because a GraphQL nullable field will allow those types to pass through to your resolver.

#### Dedicated arguments class [\#](https://docs.nestjs.com/graphql/resolvers\#dedicated-arguments-class)

With inline `@Args()` calls, code like the example above becomes bloated. Instead, you can create a dedicated `GetAuthorArgs` arguments class and access it in the handler method as follows:

content\_copy

```typescript

@Args() args: GetAuthorArgs

```

Create the `GetAuthorArgs` class using `@ArgsType()` as shown below:

content\_copy authors/dto/get-author.args.ts

JS  TS

```typescript

import { MinLength } from 'class-validator';
import { Field, ArgsType } from '@nestjs/graphql';

@ArgsType()
class GetAuthorArgs {
  @Field({ nullable: true })
  firstName?: string;

  @Field({ defaultValue: '' })
  @MinLength(3)
  lastName: string;
}

```

> **Hint** Again, due to TypeScript's metadata reflection system limitations, it's required to either use the `@Field` decorator to manually indicate type and optionality, or use a [CLI plugin](https://docs.nestjs.com/graphql/cli-plugin). Also, in the case of `firstName`, which is a GraphQL nullable field, it isn't necessary to add the non-value types of `null` or `undefined` to the type of this field. Just be aware, you'll need to type guard for these possible non-value types in your resolvers, because a GraphQL nullable field will allow those types to pass through to your resolver.

This will result in generating the following part of the GraphQL schema in SDL:

```graphql

type Query {
  author(firstName: String, lastName: String = ''): Author
}

```

> **Hint** Note that arguments classes like `GetAuthorArgs` play very well with the `ValidationPipe` (read [more](https://docs.nestjs.com/techniques/validation)).

#### Class inheritance [\#](https://docs.nestjs.com/graphql/resolvers\#class-inheritance)

You can use standard TypeScript class inheritance to create base classes with generic utility type features (fields and field properties, validations, etc.) that can be extended. For example, you may have a set of pagination related arguments that always include the standard `offset` and `limit` fields, but also other index fields that are type-specific. You can set up a class hierarchy as shown below.

Base `@ArgsType()` class:

content\_copy

```typescript

@ArgsType()
class PaginationArgs {
  @Field(() => Int)
  offset: number = 0;

  @Field(() => Int)
  limit: number = 10;
}

```

Type specific sub-class of the base `@ArgsType()` class:

content\_copy

```typescript

@ArgsType()
class GetAuthorArgs extends PaginationArgs {
  @Field({ nullable: true })
  firstName?: string;

  @Field({ defaultValue: '' })
  @MinLength(3)
  lastName: string;
}

```

The same approach can be taken with `@ObjectType()` objects. Define generic properties on the base class:

content\_copy

```typescript

@ObjectType()
class Character {
  @Field(() => Int)
  id: number;

  @Field()
  name: string;
}

```

Add type-specific properties on sub-classes:

content\_copy

```typescript

@ObjectType()
class Warrior extends Character {
  @Field()
  level: number;
}

```

You can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic `findAll` query, use a construction like this:

content\_copy

```typescript

function BaseResolver<T extends Type<unknown>>(classRef: T): any {
  @Resolver({ isAbstract: true })
  abstract class BaseResolverHost {
    @Query(() => [classRef], { name: `findAll${classRef.name}` })
    async findAll(): Promise<T[]> {
      return [];
    }
  }
  return BaseResolverHost;
}

```

Note the following:

- an explicit return type ( `any` above) is required: otherwise TypeScript complains about the usage of a private class definition. Recommended: define an interface instead of using `any`.
- `Type` is imported from the `@nestjs/common` package
- The `isAbstract: true` property indicates that SDL (Schema Definition Language statements) shouldn't be generated for this class. Note, you can set this property for other types as well to suppress SDL generation.

Here's how you could generate a concrete sub-class of the `BaseResolver`:

content\_copy

```typescript

@Resolver(() => Recipe)
export class RecipesResolver extends BaseResolver(Recipe) {
  constructor(private recipesService: RecipesService) {
    super();
  }
}

```

This construct would generated the following SDL:

```graphql

type Query {
  findAllRecipe: [Recipe!]!
}

```

#### Generics [\#](https://docs.nestjs.com/graphql/resolvers\#generics)

We saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here's a sample cursor-based pagination implementation based on [this documentation](https://graphql.org/learn/pagination/#pagination-and-edges):

content\_copy

```typescript

import { Field, ObjectType, Int } from '@nestjs/graphql';
import { Type } from '@nestjs/common';

interface IEdgeType<T> {
  cursor: string;
  node: T;
}

export interface IPaginatedType<T> {
  edges: IEdgeType<T>[];
  nodes: T[];
  totalCount: number;
  hasNextPage: boolean;
}

export function Paginated<T>(classRef: Type<T>): Type<IPaginatedType<T>> {
  @ObjectType(`${classRef.name}Edge`)
  abstract class EdgeType {
    @Field(() => String)
    cursor: string;

    @Field(() => classRef)
    node: T;
  }

  @ObjectType({ isAbstract: true })
  abstract class PaginatedType implements IPaginatedType<T> {
    @Field(() => [EdgeType], { nullable: true })
    edges: EdgeType[];

    @Field(() => [classRef], { nullable: true })
    nodes: T[];

    @Field(() => Int)
    totalCount: number;

    @Field()
    hasNextPage: boolean;
  }
  return PaginatedType as Type<IPaginatedType<T>>;
}

```

With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:

content\_copy

```typescript

@ObjectType()
class PaginatedAuthor extends Paginated(Author) {}

```

#### Schema first [\#](https://docs.nestjs.com/graphql/resolvers\#schema-first)

As mentioned in the [previous](https://docs.nestjs.com/graphql/quick-start) chapter, in the schema first approach we start by manually defining schema types in SDL (read [more](https://graphql.org/learn/schema/#type-language)). Consider the following SDL type definitions.

> **Hint** For convenience in this chapter, we've aggregated all of the SDL in one location (e.g., one `.graphql` file, as shown below). In practice, you may find it appropriate to organize your code in a modular fashion. For example, it can be helpful to create individual SDL files with type definitions representing each domain entity, along with related services, resolver code, and the Nest module definition class, in a dedicated directory for that entity. Nest will aggregate all the individual schema type definitions at run time.

```graphql

type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}

type Post {
  id: Int!
  title: String!
  votes: Int
}

type Query {
  author(id: Int!): Author
}

```

#### Schema first resolver [\#](https://docs.nestjs.com/graphql/resolvers\#schema-first-resolver)

The schema above exposes a single query - `author(id: Int!): Author`.

> **Hint** Learn more about GraphQL queries [here](https://graphql.org/learn/queries/).

Let's now create an `AuthorsResolver` class that resolves author queries:

content\_copy authors/authors.resolver.ts

JS  TS

```typescript

@Resolver('Author')
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query()
  async author(@Args('id') id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField()
  async posts(@Parent() author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}

```

> **Hint** All decorators (e.g., `@Resolver`, `@ResolveField`, `@Args`, etc.) are exported from the `@nestjs/graphql` package.

> **Note** The logic inside the `AuthorsService` and `PostsService` classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.

The `@Resolver()` decorator is required. It takes an optional string argument with the name of a class. This class name is required whenever the class includes `@ResolveField()` decorators to inform Nest that the decorated method is associated with a parent type (the `Author` type in our current example). Alternatively, instead of setting `@Resolver()` at the top of the class, this can be done for each method:

content\_copy

```typescript

@Resolver('Author')
@ResolveField()
async posts(@Parent() author) {
  const { id } = author;
  return this.postsService.findAll({ authorId: id });
}

```

In this case ( `@Resolver()` decorator at the method level), if you have multiple `@ResolveField()` decorators inside a class, you must add `@Resolver()` to all of them. This is not considered the best practice (as it creates extra overhead).

> **Hint** Any class name argument passed to `@Resolver()` **does not** affect queries ( `@Query()` decorator) or mutations ( `@Mutation()` decorator).

> **Warning** Using the `@Resolver` decorator at the method level is not supported with the **code first** approach.

In the above examples, the `@Query()` and `@ResolveField()` decorators are associated with GraphQL schema types based on the method name. For example, consider the following construction from the example above:

content\_copy

```typescript

@Query()
async author(@Args('id') id: number) {
  return this.authorsService.findOneById(id);
}

```

This generates the following entry for the author query in our schema (the query type uses the same name as the method name):

```graphql

type Query {
  author(id: Int!): Author
}

```

Conventionally, we would prefer to decouple these, using names like `getAuthor()` or `getPosts()` for our resolver methods. We can easily do this by passing the mapping name as an argument to the decorator, as shown below:

content\_copy authors/authors.resolver.ts

JS  TS

```typescript

@Resolver('Author')
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query('author')
  async getAuthor(@Args('id') id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField('posts')
  async getPosts(@Parent() author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}

```

> **Hint** Nest CLI provides a generator (schematic) that automatically generates **all the boilerplate code** to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature [here](https://docs.nestjs.com/recipes/crud-generator).

#### Generating types [\#](https://docs.nestjs.com/graphql/resolvers\#generating-types)

Assuming that we use the schema first approach and have enabled the typings generation feature (with `outputAs: 'class'` as shown in the [previous](https://docs.nestjs.com/graphql/quick-start) chapter), once you run the application it will generate the following file (in the location you specified in the `GraphQLModule.forRoot()` method). For example, in `src/graphql.ts`:

content\_copy graphql.ts

JS  TS

```typescript

export class Author {
  id: number;
  firstName?: string;
  lastName?: string;
  posts?: Post[];
}
export class Post {
  id: number;
  title: string;
  votes?: number;
}

export abstract class IQuery {
  abstract author(id: number): Author | Promise<Author>;
}

```

By generating classes (instead of the default technique of generating interfaces), you can use declarative validation **decorators** in combination with the schema first approach, which is an extremely useful technique (read [more](https://docs.nestjs.com/techniques/validation)). For example, you could add `class-validator` decorators to the generated `CreatePostInput` class as shown below to enforce minimum and maximum string lengths on the `title` field:

content\_copy

```typescript

import { MinLength, MaxLength } from 'class-validator';

export class CreatePostInput {
  @MinLength(3)
  @MaxLength(50)
  title: string;
}

```

> **Notice** To enable auto-validation of your inputs (and parameters), use `ValidationPipe`. Read more about validation [here](https://docs.nestjs.com/techniques/validation) and more specifically about pipes [here](https://docs.nestjs.com/pipes).

However, if you add decorators directly to the automatically generated file, they will be **overwritten** each time the file is generated. Instead, create a separate file and simply extend the generated class.

content\_copy

```typescript

import { MinLength, MaxLength } from 'class-validator';
import { Post } from '../../graphql.ts';

export class CreatePostInput extends Post {
  @MinLength(3)
  @MaxLength(50)
  title: string;
}

```

#### GraphQL argument decorators [\#](https://docs.nestjs.com/graphql/resolvers\#graphql-argument-decorators)

We can access the standard GraphQL resolver arguments using dedicated decorators. Below is a comparison of the Nest decorators and the plain Apollo parameters they represent.

|     |     |
| --- | --- |
| `@Root()` and `@Parent()` | `root`/ `parent` |
| `@Context(param?: string)` | `context` / `context[param]` |
| `@Info(param?: string)` | `info` / `info[param]` |
| `@Args(param?: string)` | `args` / `args[param]` |

These arguments have the following meanings:

- `root`: an object that contains the result returned from the resolver on the parent field, or, in the case of a top-level `Query` field, the `rootValue` passed from the server configuration.
- `context`: an object shared by all resolvers in a particular query; typically used to contain per-request state.
- `info`: an object that contains information about the execution state of the query.
- `args`: an object with the arguments passed into the field in the query.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

#### Module [\#](https://docs.nestjs.com/graphql/resolvers\#module)

Once we're done with the above steps, we have declaratively specified all the information needed by the `GraphQLModule` to generate a resolver map. The `GraphQLModule` uses reflection to introspect the meta data provided via the decorators, and transforms classes into the correct resolver map automatically.

The only other thing you need to take care of is to **provide** (i.e., list as a `provider` in some module) the resolver class(es) ( `AuthorsResolver`), and importing the module ( `AuthorsModule`) somewhere, so Nest will be able to utilize it.

For example, we can do this in an `AuthorsModule`, which can also provide other services needed in this context. Be sure to import `AuthorsModule` somewhere (e.g., in the root module, or some other module imported by the root module).

content\_copy authors/authors.module.ts

JS  TS

```typescript

@Module({
  imports: [PostsModule],
  providers: [AuthorsService, AuthorsResolver],
})
export class AuthorsModule {}

```

> **Hint** It is helpful to organize your code by your so-called **domain model** (similar to the way you would organize entry points in a REST API). In this approach, keep your models ( `ObjectType` classes), resolvers and services together within a Nest module representing the domain model. Keep all of these components in a single folder per module. When you do this, and use the [Nest CLI](https://docs.nestjs.com/cli/overview) to generate each element, Nest will wire all of these parts together (locating files in appropriate folders, generating entries in `provider` and `imports` arrays, etc.) automatically for you.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Microservices Pipes
- [Pipes](https://docs.nestjs.com/microservices/pipes#pipes)
- [Binding pipes](https://docs.nestjs.com/microservices/pipes#binding-pipes)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/pipes.md "Suggest Edits")

### Pipes

There is no fundamental difference between [regular pipes](https://docs.nestjs.com/pipes) and microservices pipes. The only difference is that instead of throwing `HttpException`, you should use `RpcException`.

> **Hint** The `RpcException` class is exposed from `@nestjs/microservices` package.

#### Binding pipes [\#](https://docs.nestjs.com/microservices/pipes\#binding-pipes)

The following example uses a manually instantiated method-scoped pipe. Just as with HTTP based applications, you can also use controller-scoped pipes (i.e., prefix the controller class with a `@UsePipes()` decorator).

content\_copy

JS  TS

```typescript

@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new RpcException(errors) }))
@MessagePattern({ cmd: 'sum' })
accumulate(data: number[]): number {
  return (data || []).reduce((a, b) => a + b);
}

```

```typescript

@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new RpcException(errors) }))
@MessagePattern({ cmd: 'sum' })
accumulate(data) {
  return (data || []).reduce((a, b) => a + b);
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Session Management
- [Session](https://docs.nestjs.com/techniques/session#session)
- [Use with Express (default)](https://docs.nestjs.com/techniques/session#use-with-express-default)
- [Use with Fastify](https://docs.nestjs.com/techniques/session#use-with-fastify)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/sessions.md "Suggest Edits")

### Session

**HTTP sessions** provide a way to store information about the user across multiple requests, which is particularly useful for [MVC](https://docs.nestjs.com/techniques/mvc) applications.

#### Use with Express (default) [\#](https://docs.nestjs.com/techniques/session\#use-with-express-default)

First install the [required package](https://github.com/expressjs/session) (and its types for TypeScript users):

```shell

$ npm i express-session
$ npm i -D @types/express-session

```

Once the installation is complete, apply the `express-session` middleware as global middleware (for example, in your `main.ts` file).

content\_copy

```typescript

import * as session from 'express-session';
// somewhere in your initialization file
app.use(
  session({
    secret: 'my-secret',
    resave: false,
    saveUninitialized: false,
  }),
);

```

> **Notice** The default server-side session storage is purposely not designed for a production environment. It will leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing. Read more in the [official repository](https://github.com/expressjs/session).

The `secret` is used to sign the session ID cookie. This can be either a string for a single secret, or an array of multiple secrets. If an array of secrets is provided, only the first element will be used to sign the session ID cookie, while all the elements will be considered when verifying the signature in requests. The secret itself should be not easily parsed by a human and would best be a random set of characters.

Enabling the `resave` option forces the session to be saved back to the session store, even if the session was never modified during the request. The default value is `true`, but using the default has been deprecated, as the default will change in the future.

Likewise, enabling the `saveUninitialized` option Forces a session that is "uninitialized" to be saved to the store. A session is uninitialized when it is new but not modified. Choosing `false` is useful for implementing login sessions, reducing server storage usage, or complying with laws that require permission before setting a cookie. Choosing `false` will also help with race conditions where a client makes multiple parallel requests without a session ( [source](https://github.com/expressjs/session#saveuninitialized)).

You can pass several other options to the `session` middleware, read more about them in the [API documentation](https://github.com/expressjs/session#options).

> **Hint** Please note that `secure: true` is a recommended option. However, it requires an https-enabled website, i.e., HTTPS is necessary for secure cookies. If secure is set, and you access your site over HTTP, the cookie will not be set. If you have your node.js behind a proxy and are using `secure: true`, you need to set `"trust proxy"` in express.

With this in place, you can now set and read session values from within the route handlers, as follows:

content\_copy

```typescript

@Get()
findAll(@Req() request: Request) {
  request.session.visits = request.session.visits ? request.session.visits + 1 : 1;
}

```

> **Hint** The `@Req()` decorator is imported from the `@nestjs/common`, while `Request` from the `express` package.

Alternatively, you can use the `@Session()` decorator to extract a session object from the request, as follows:

content\_copy

```typescript

@Get()
findAll(@Session() session: Record<string, any>) {
  session.visits = session.visits ? session.visits + 1 : 1;
}

```

> **Hint** The `@Session()` decorator is imported from the `@nestjs/common` package.

#### Use with Fastify [\#](https://docs.nestjs.com/techniques/session\#use-with-fastify)

First install the required package:

```shell

$ npm i @fastify/secure-session

```

Once the installation is complete, register the `fastify-secure-session` plugin:

content\_copy

```typescript

import secureSession from '@fastify/secure-session';

// somewhere in your initialization file
const app = await NestFactory.create<NestFastifyApplication>(
  AppModule,
  new FastifyAdapter(),
);
await app.register(secureSession, {
  secret: 'averylogphrasebiggerthanthirtytwochars',
  salt: 'mq9hDxBVDbspDR6n',
});

```

> **Hint** You can also pregenerate a key ( [see instructions](https://github.com/fastify/fastify-secure-session)) or use [keys rotation](https://github.com/fastify/fastify-secure-session#using-keys-with-key-rotation).

Read more about the available options in the [official repository](https://github.com/fastify/fastify-secure-session).

With this in place, you can now set and read session values from within the route handlers, as follows:

content\_copy

```typescript

@Get()
findAll(@Req() request: FastifyRequest) {
  const visits = request.session.get('visits');
  request.session.set('visits', visits ? visits + 1 : 1);
}

```

Alternatively, you can use the `@Session()` decorator to extract a session object from the request, as follows:

content\_copy

```typescript

@Get()
findAll(@Session() session: secureSession.Session) {
  const visits = session.get('visits');
  session.set('visits', visits ? visits + 1 : 1);
}

```

> **Hint** The `@Session()` decorator is imported from the `@nestjs/common`, while `secureSession.Session` from the `@fastify/secure-session` package (import statement: `import * as secureSession from '@fastify/secure-session'`).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS WebSocket Guards
- [Guards](https://docs.nestjs.com/websockets/guards#guards)
- [Binding guards](https://docs.nestjs.com/websockets/guards#binding-guards)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/websockets/guards.md "Suggest Edits")

### Guards

There is no fundamental difference between web sockets guards and [regular HTTP application guards](https://docs.nestjs.com/guards). The only difference is that instead of throwing `HttpException`, you should use `WsException`.

> **Hint** The `WsException` class is exposed from `@nestjs/websockets` package.

#### Binding guards [\#](https://docs.nestjs.com/websockets/guards\#binding-guards)

The following example uses a method-scoped guard. Just as with HTTP based applications, you can also use gateway-scoped guards (i.e., prefix the gateway class with a `@UseGuards()` decorator).

content\_copy

JS  TS

```typescript

@UseGuards(AuthGuard)
@SubscribeMessage('events')
handleEvent(client: Client, data: unknown): WsResponse<unknown> {
  const event = 'events';
  return { event, data };
}

```

```typescript

@UseGuards(AuthGuard)
@SubscribeMessage('events')
handleEvent(client, data) {
  const event = 'events';
  return { event, data };
}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Devtools Overview
- [Overview](https://docs.nestjs.com/devtools/overview#overview)
- [Investigating the "Cannot resolve dependency" error](https://docs.nestjs.com/devtools/overview#investigating-the-cannot-resolve-dependency-error)
- [Routes explorer](https://docs.nestjs.com/devtools/overview#routes-explorer)
- [Sandbox](https://docs.nestjs.com/devtools/overview#sandbox)
- [Bootstrap performance analyzer](https://docs.nestjs.com/devtools/overview#bootstrap-performance-analyzer)
- [Audit](https://docs.nestjs.com/devtools/overview#audit)
- [Preview static files](https://docs.nestjs.com/devtools/overview#preview-static-files)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/devtools/overview.md "Suggest Edits")

### Overview

> **Hint** This chapter covers the Nest Devtools integration with the Nest framework. If you are looking for the Devtools application, please visit the [Devtools](https://devtools.nestjs.com/) website.

To start debugging your local application, open up the `main.ts` file and make sure to set the `snapshot` attribute to `true` in the application options object, as follows:

content\_copy

```typescript

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    snapshot: true,
  });
  await app.listen(process.env.PORT ?? 3000);
}

```

This will instruct the framework to collect necessary metadata that will let Nest Devtools visualize your application's graph.

Next up, let's install the required dependency:

```bash

$ npm i @nestjs/devtools-integration

```

> **Warning** If you're using `@nestjs/graphql` package in your application, make sure to install the latest version ( `npm i @nestjs/graphql@11`).

With this dependency in place, let's open up the `app.module.ts` file and import the `DevtoolsModule` that we just installed:

content\_copy

```typescript

@Module({
  imports: [\
    DevtoolsModule.register({\
      http: process.env.NODE_ENV !== 'production',\
    }),\
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

> **Warning** The reason we are checking the `NODE_ENV` environment variable here is that you should never use this module in production!

Once the `DevtoolsModule` is imported and your application is up and running ( `npm run start:dev`), you should be able to navigate to [Devtools](https://devtools.nestjs.com/) URL and see the instrospected graph.

![](https://docs.nestjs.com/assets/devtools/modules-graph.png)

> **Hint** As you can see on the screenshot above, every module connects to the `InternalCoreModule`. `InternalCoreModule` is a global module that is always imported into the root module. Since it's registered as a global node, Nest automatically creates edges between all of the modules and the `InternalCoreModule` node. Now, if you want to hide global modules from the graph, you can use the " **Hide global modules**" checkbox (in the sidebar).

So as we can see, `DevtoolsModule` makes your application expose an additional HTTP server (on port 8000) that the Devtools application will use to introspect your app.

Just to double-check that everything works as expected, change the graph view to "Classes". You should see the following screen:

![](https://docs.nestjs.com/assets/devtools/classes-graph.png)

To focus on a specific node, click on the rectangle and the graph will show a popup window with the **"Focus"** button. You can also use the search bar (located in the sidebar) to find a specific node.

> **Hint** If you click on the **Inspect** button, application will take you to the `/debug` page with that specific node selected.

![](https://docs.nestjs.com/assets/devtools/node-popup.png)

> **Hint** To export a graph as an image, click on the **Export as PNG** button in the right corner of the graph.

Using the form controls located in the sidebar (on the left), you can control edges proximity to, for example, visualize a specific application sub-tree:

![](https://docs.nestjs.com/assets/devtools/subtree-view.png)

This can be particularly useful when you have **new developers** on your team and you want to show them how your application is structured. You can also use this feature to visualize a specific module (e.g. `TasksModule`) and all of its dependencies, which can come in handy when you're breaking down a large application into smaller modules (for example, individual micro-services).

You can watch this video to see the **Graph Explorer** feature in action:

NestJS Devtools: Graph Explorer Use Cases with Kamil Mysliwiec - YouTube

[Photo image of NestJS](https://www.youtube.com/channel/UCNuGHuz7gG91Q01nFWZPFvg?embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

NestJS

2.16K subscribers

[NestJS Devtools: Graph Explorer Use Cases with Kamil Mysliwiec](https://www.youtube.com/watch?v=bW8V-ssfnvM)

NestJS

Search

Watch later

Share

Copy link

Info

Shopping

Tap to unmute

If playback doesn't begin shortly, try restarting your device.

More videos

## More videos

You're signed out

Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer.

CancelConfirm

Share

Include playlist

An error occurred while retrieving sharing information. Please try again later.

[Watch on](https://www.youtube.com/watch?v=bW8V-ssfnvM&embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

0:00

0:00 / 2:18
•Live

•

#### Investigating the "Cannot resolve dependency" error [\#](https://docs.nestjs.com/devtools/overview\#investigating-the-cannot-resolve-dependency-error)

> **Note** This feature is supported for `@nestjs/core` >= `v9.3.10`.

Probably the most common error message you might have seen is about Nest not being able to resolve dependencies of a provider. Using Nest Devtools, you can effortlessly identify the issue and learn how to resolve it.

First, open up the `main.ts` file and update the `bootstrap()` call, as follows:

content\_copy

```typescript

bootstrap().catch((err) => {
  fs.writeFileSync('graph.json', PartialGraphHost.toString() ?? '');
  process.exit(1);
});

```

Also, make sure to set the `abortOnError` to `false`:

content\_copy

```typescript

const app = await NestFactory.create(AppModule, {
  snapshot: true,
  abortOnError: false, // <--- THIS
});

```

Now every time your application fails to bootstrap due to the **"Cannot resolve dependency"** error, you'll find the `graph.json` (that represents a partial graph) file in the root directory. You can then drag & drop this file into Devtools (make sure to switch the current mode from "Interactive" to "Preview"):

![](https://docs.nestjs.com/assets/devtools/drag-and-drop.png)

Upon successful upload, you should see the following graph & dialog window:

![](https://docs.nestjs.com/assets/devtools/partial-graph-modules-view.png)

As you can see, the highlighted `TasksModule` is the one we should look into. Also, in the dialog window you can already see some instructions on how to fix this issue.

If we switch to the "Classes" view instead, that's what we'll see:

![](https://docs.nestjs.com/assets/devtools/partial-graph-classes-view.png)

This graph illustrates that the `DiagnosticsService` which we want to inject into the `TasksService` was not found in the context of the `TasksModule` module, and we should likely just import the `DiagnosticsModule` into the `TasksModule` module to fix this up!

#### Routes explorer [\#](https://docs.nestjs.com/devtools/overview\#routes-explorer)

When you navigate to the **Routes explorer** page, you should see all of the registered entrypoints:

![](https://docs.nestjs.com/assets/devtools/routes.png)

> **Hint** This page shows not only HTTP routes, but also all of the other entrypoints (e.g. WebSockets, gRPC, GraphQL resolvers etc.).

Entrypoints are grouped by their host controllers. You can also use the search bar to find a specific entrypoint.

If you click on a specific entrypoint, **a flow graph** will be displayed. This graph shows the execution flow of the entrypoint (e.g. guards, interceptors, pipes, etc. bound to this route). This is particularly useful when you want to understand how the request/response cycle looks for a specific route, or when troubleshooting why a specific guard/interceptor/pipe is not being executed.

#### Sandbox [\#](https://docs.nestjs.com/devtools/overview\#sandbox)

To execute JavaScript code on the fly & interact with your application in real-time, navigate to the **Sandbox** page:

![](https://docs.nestjs.com/assets/devtools/sandbox.png)

The playground can be used to test and debug API endpoints in **real-time**, allowing developers to quickly identify and fix issues without using, for example, an HTTP client. We can also bypass the authentication layer, and so we no longer need that extra step of logging in, or even a special user account for testing purposes. For event-driven applications, we can also trigger events directly from the playground, and see how the application reacts to them.

Anything that gets logged down is streamlined to the playground's console, so we can easily see what's going on.

Just execute the code **on the fly** and see the results instantly, without having to rebuild the application and restart the server.

![](https://docs.nestjs.com/assets/devtools/sandbox-table.png)

> **Hint** To pretty display an array of objects, use the `console.table()` (or just `table()`) function.

You can watch this video to see the **Interactive Playground** feature in action:

NestJS Devtools: Interactive Playground Use Cases with Kamil Mysliwiec - YouTube

[Photo image of NestJS](https://www.youtube.com/channel/UCNuGHuz7gG91Q01nFWZPFvg?embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

NestJS

2.16K subscribers

[NestJS Devtools: Interactive Playground Use Cases with Kamil Mysliwiec](https://www.youtube.com/watch?v=liSxEN_VXKM)

NestJS

Search

Watch later

Share

Copy link

Info

Shopping

Tap to unmute

If playback doesn't begin shortly, try restarting your device.

More videos

## More videos

You're signed out

Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer.

CancelConfirm

Share

Include playlist

An error occurred while retrieving sharing information. Please try again later.

[Watch on](https://www.youtube.com/watch?v=liSxEN_VXKM&embeds_referring_euri=https%3A%2F%2Fdocs.nestjs.com%2F)

0:00

0:00 / 1:20
•Live

•

#### Bootstrap performance analyzer [\#](https://docs.nestjs.com/devtools/overview\#bootstrap-performance-analyzer)

To see a list of all class nodes (controllers, providers, enhancers, etc.) and their corresponding instantiation times, navigate to the **Bootstrap performance** page:

![](https://docs.nestjs.com/assets/devtools/bootstrap-performance.png)

This page is particularly useful when you want to identify the slowest parts of your application's bootstrap process (e.g. when you want to optimize the application's startup time which is crucial for, for example, serverless environments).

#### Audit [\#](https://docs.nestjs.com/devtools/overview\#audit)

To see the auto-generated audit - errors/warnings/hints that the application came up with while analyzing your serialized graph, navigate to the **Audit** page:

![](https://docs.nestjs.com/assets/devtools/audit.png)

> **Hint** The screenshot above doesn't show all of the available audit rules.

This page comes in handy when you want to identify potential issues in your application.

#### Preview static files [\#](https://docs.nestjs.com/devtools/overview\#preview-static-files)

To save a serialized graph to a file, use the following code:

content\_copy

```typescript

await app.listen(process.env.PORT ?? 3000); // OR await app.init()
fs.writeFileSync('./graph.json', app.get(SerializedGraph).toString());

```

> **Hint** `SerializedGraph` is exported from the `@nestjs/core` package.

Then you can drag and drop/upload this file:

![](https://docs.nestjs.com/assets/devtools/drag-and-drop.png)

This is helpful when you want to share your graph with someone else (e.g., co-worker), or when you want to analyze it offline.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS OpenAPI Decorators
- [Decorators](https://docs.nestjs.com/openapi/decorators#decorators)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/decorators.md "Suggest Edits")

### Decorators

All of the available OpenAPI decorators have an `Api` prefix to distinguish them from the core decorators. Below is a full list of the exported decorators along with a designation of the level at which the decorator may be applied.

| `@ApiBasicAuth()` | Method / Controller |
| `@ApiBearerAuth()` | Method / Controller |
| `@ApiBody()` | Method |
| `@ApiConsumes()` | Method / Controller |
| `@ApiCookieAuth()` | Method / Controller |
| `@ApiExcludeController()` | Controller |
| `@ApiExcludeEndpoint()` | Method |
| `@ApiExtension()` | Method |
| `@ApiExtraModels()` | Method / Controller |
| `@ApiHeader()` | Method / Controller |
| `@ApiHideProperty()` | Model |
| `@ApiOAuth2()` | Method / Controller |
| `@ApiOperation()` | Method |
| `@ApiParam()` | Method / Controller |
| `@ApiProduces()` | Method / Controller |
| `@ApiSchema()` | Model |
| `@ApiProperty()` | Model |
| `@ApiPropertyOptional()` | Model |
| `@ApiQuery()` | Method / Controller |
| `@ApiResponse()` | Method / Controller |
| `@ApiSecurity()` | Method / Controller |
| `@ApiTags()` | Method / Controller |
| `@ApiCallbacks()` | Method / Controller |

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS First Steps
- [First steps](https://docs.nestjs.com/first-steps#first-steps)
- [Language](https://docs.nestjs.com/first-steps#language)
- [Prerequisites](https://docs.nestjs.com/first-steps#prerequisites)
- [Setup](https://docs.nestjs.com/first-steps#setup)
- [Platform](https://docs.nestjs.com/first-steps#platform)
- [Running the application](https://docs.nestjs.com/first-steps#running-the-application)
- [Linting and formatting](https://docs.nestjs.com/first-steps#linting-and-formatting)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/first-steps.md "Suggest Edits")

### First steps

In this set of articles, you'll learn the **core fundamentals** of Nest. To get familiar with the essential building blocks of Nest applications, we'll build a basic CRUD application with features that cover a lot of ground at an introductory level.

#### Language [\#](https://docs.nestjs.com/first-steps\#language)

We're in love with [TypeScript](https://www.typescriptlang.org/), but above all - we love [Node.js](https://nodejs.org/en/). That's why Nest is compatible with both TypeScript and pure JavaScript. Nest takes advantage of the latest language features, so to use it with vanilla JavaScript we need a [Babel](https://babeljs.io/) compiler.

We'll mostly use TypeScript in the examples we provide, but you can always **switch the code snippets** to vanilla JavaScript syntax (simply click to toggle the language button in the upper right hand corner of each snippet).

#### Prerequisites [\#](https://docs.nestjs.com/first-steps\#prerequisites)

Please make sure that [Node.js](https://nodejs.org/) (version >= 20) is installed on your operating system.

#### Setup [\#](https://docs.nestjs.com/first-steps\#setup)

Setting up a new project is quite simple with the [Nest CLI](https://docs.nestjs.com/cli/overview). With [npm](https://www.npmjs.com/) installed, you can create a new Nest project with the following commands in your OS terminal:

```bash

$ npm i -g @nestjs/cli
$ nest new project-name

```

> **Hint** To create a new project with TypeScript's [stricter](https://www.typescriptlang.org/tsconfig#strict) feature set, pass the `--strict` flag to the `nest new` command.

The `project-name` directory will be created, node modules and a few other boilerplate files will be installed, and a `src/` directory will be created and populated with several core files.

src

app.controller.spec.ts

app.controller.ts

app.module.ts

app.service.ts

main.ts

Here's a brief overview of those core files:

| `app.controller.ts` | A basic controller with a single route. |
| `app.controller.spec.ts` | The unit tests for the controller. |
| `app.module.ts` | The root module of the application. |
| `app.service.ts` | A basic service with a single method. |
| `main.ts` | The entry file of the application which uses the core function `NestFactory` to create a Nest application instance. |

The `main.ts` includes an async function, which will **bootstrap** our application:

content\_copy main.ts

JS  TS

```typescript

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

```typescript

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

```

To create a Nest application instance, we use the core `NestFactory` class. `NestFactory` exposes a few static methods that allow creating an application instance. The `create()` method returns an application object, which fulfills the `INestApplication` interface. This object provides a set of methods which are described in the coming chapters. In the `main.ts` example above, we simply start up our HTTP listener, which lets the application await inbound HTTP requests.

Note that a project scaffolded with the Nest CLI creates an initial project structure that encourages developers to follow the convention of keeping each module in its own dedicated directory.

> **Hint** By default, if any error happens while creating the application your app will exit with the code `1`. If you want to make it throw an error instead disable the option `abortOnError` (e.g., `NestFactory.create(AppModule, { abortOnError: false })`).

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Platform [\#](https://docs.nestjs.com/first-steps\#platform)

Nest aims to be a platform-agnostic framework. Platform independence makes it possible to create reusable logical parts that developers can take advantage of across several different types of applications. Technically, Nest is able to work with any Node HTTP framework once an adapter is created. There are two HTTP platforms supported out-of-the-box: [express](https://expressjs.com/) and [fastify](https://www.fastify.io/). You can choose the one that best suits your needs.

| `platform-express` | [Express](https://expressjs.com/) is a well-known minimalist web framework for node. It's a battle tested, production-ready library with lots of resources implemented by the community. The `@nestjs/platform-express` package is used by default. Many users are well served with Express, and need take no action to enable it. |
| `platform-fastify` | [Fastify](https://www.fastify.io/) is a high performance and low overhead framework highly focused on providing maximum efficiency and speed. Read how to use it [here](https://docs.nestjs.com/techniques/performance). |

Whichever platform is used, it exposes its own application interface. These are seen respectively as `NestExpressApplication` and `NestFastifyApplication`.

When you pass a type to the `NestFactory.create()` method, as in the example below, the `app` object will have methods available exclusively for that specific platform. Note, however, you don't **need** to specify a type **unless** you actually want to access the underlying platform API.

content\_copy

```typescript

const app = await NestFactory.create<NestExpressApplication>(AppModule);

```

#### Running the application [\#](https://docs.nestjs.com/first-steps\#running-the-application)

Once the installation process is complete, you can run the following command at your OS command prompt to start the application listening for inbound HTTP requests:

```bash

$ npm run start

```

> **Hint** To speed up the development process (x20 times faster builds), you can use the [SWC builder](https://docs.nestjs.com/recipes/swc) by passing the `-b swc` flag to the `start` script, as follows `npm run start -- -b swc`.

This command starts the app with the HTTP server listening on the port defined in the `src/main.ts` file. Once the application is running, open your browser and navigate to `http://localhost:3000/`. You should see the `Hello World!` message.

To watch for changes in your files, you can run the following command to start the application:

```bash

$ npm run start:dev

```

This command will watch your files, automatically recompiling and reloading the server.

#### Linting and formatting [\#](https://docs.nestjs.com/first-steps\#linting-and-formatting)

[CLI](https://docs.nestjs.com/cli/overview) provides best effort to scaffold a reliable development workflow at scale. Thus, a generated Nest project comes with both a code **linter** and **formatter** preinstalled (respectively [eslint](https://eslint.org/) and [prettier](https://prettier.io/)).

> **Hint** Not sure about the role of formatters vs linters? Learn the difference [here](https://prettier.io/docs/en/comparison.html).

To ensure maximum stability and extensibility, we use the base [`eslint`](https://www.npmjs.com/package/eslint) and [`prettier`](https://www.npmjs.com/package/prettier) cli packages. This setup allows neat IDE integration with official extensions by design.

For headless environments where an IDE is not relevant (Continuous Integration, Git hooks, etc.) a Nest project comes with ready-to-use `npm` scripts.

```bash

# Lint and autofix with eslint
$ npm run lint

# Format with prettier
$ npm run format

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Database Integration
- [Database](https://docs.nestjs.com/techniques/database#database)
- [TypeORM Integration](https://docs.nestjs.com/techniques/database#typeorm-integration)
- [Repository pattern](https://docs.nestjs.com/techniques/database#repository-pattern)
- [Relations](https://docs.nestjs.com/techniques/database#relations)
- [Auto-load entities](https://docs.nestjs.com/techniques/database#auto-load-entities)
- [Separating entity definition](https://docs.nestjs.com/techniques/database#separating-entity-definition)
- [TypeORM Transactions](https://docs.nestjs.com/techniques/database#typeorm-transactions)
- [Subscribers](https://docs.nestjs.com/techniques/database#subscribers)
- [Migrations](https://docs.nestjs.com/techniques/database#migrations)
- [Multiple databases](https://docs.nestjs.com/techniques/database#multiple-databases)
- [Testing](https://docs.nestjs.com/techniques/database#testing)
- [Async configuration](https://docs.nestjs.com/techniques/database#async-configuration)
- [Custom DataSource Factory](https://docs.nestjs.com/techniques/database#custom-datasource-factory)
- [Example](https://docs.nestjs.com/techniques/database#example)
- [Sequelize Integration](https://docs.nestjs.com/techniques/database#sequelize-integration)
- [Models](https://docs.nestjs.com/techniques/database#models)
- [Relations](https://docs.nestjs.com/techniques/database#relations-1)
- [Auto-load models](https://docs.nestjs.com/techniques/database#auto-load-models)
- [Sequelize Transactions](https://docs.nestjs.com/techniques/database#sequelize-transactions)
- [Migrations](https://docs.nestjs.com/techniques/database#migrations-1)
- [Multiple databases](https://docs.nestjs.com/techniques/database#multiple-databases-1)
- [Testing](https://docs.nestjs.com/techniques/database#testing-1)
- [Async configuration](https://docs.nestjs.com/techniques/database#async-configuration-1)
- [Example](https://docs.nestjs.com/techniques/database#example-1)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/sql.md "Suggest Edits")

### Database

Nest is database agnostic, allowing you to easily integrate with any SQL or NoSQL database. You have a number of options available to you, depending on your preferences. At the most general level, connecting Nest to a database is simply a matter of loading an appropriate Node.js driver for the database, just as you would with [Express](https://expressjs.com/en/guide/database-integration.html) or Fastify.

You can also directly use any general purpose Node.js database integration **library** or ORM, such as [MikroORM](https://mikro-orm.io/) (see [MikroORM recipe](https://docs.nestjs.com/recipes/mikroorm)), [Sequelize](https://sequelize.org/) (see [Sequelize integration](https://docs.nestjs.com/techniques/database#sequelize-integration)), [Knex.js](https://knexjs.org/) (see [Knex.js tutorial](https://dev.to/nestjs/build-a-nestjs-module-for-knex-js-or-other-resource-based-libraries-in-5-minutes-12an)), [TypeORM](https://github.com/typeorm/typeorm), and [Prisma](https://www.github.com/prisma/prisma) (see [Prisma recipe](https://docs.nestjs.com/recipes/prisma)), to operate at a higher level of abstraction.

For convenience, Nest provides tight integration with TypeORM and Sequelize out-of-the-box with the `@nestjs/typeorm` and `@nestjs/sequelize` packages respectively, which we'll cover in the current chapter, and Mongoose with `@nestjs/mongoose`, which is covered in [this chapter](https://docs.nestjs.com/techniques/mongodb). These integrations provide additional NestJS-specific features, such as model/repository injection, testability, and asynchronous configuration to make accessing your chosen database even easier.

### TypeORM Integration

For integrating with SQL and NoSQL databases, Nest provides the `@nestjs/typeorm` package. [TypeORM](https://github.com/typeorm/typeorm) is the most mature Object Relational Mapper (ORM) available for TypeScript. Since it's written in TypeScript, it integrates well with the Nest framework.

To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular [MySQL](https://www.mysql.com/) Relational DBMS, but TypeORM provides support for many relational databases, such as PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. The procedure we walk through in this chapter will be the same for any database supported by TypeORM. You'll simply need to install the associated client API libraries for your selected database.

```bash

$ npm install --save @nestjs/typeorm typeorm mysql2

```

Once the installation process is complete, we can import the `TypeOrmModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      type: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      entities: [],\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

> **Warning** Setting `synchronize: true` shouldn't be used in production - otherwise you can lose production data.

The `forRoot()` method supports all the configuration properties exposed by the `DataSource` constructor from the [TypeORM](https://typeorm.io/data-source-options#common-data-source-options) package. In addition, there are several extra configuration properties described below.

|     |     |
| --- | --- |
| `retryAttempts` | Number of attempts to connect to the database (default: `10`) |
| `retryDelay` | Delay between connection retry attempts (ms) (default: `3000`) |
| `autoLoadEntities` | If `true`, entities will be loaded automatically (default: `false`) |

> **Hint** Learn more about the data source options [here](https://typeorm.io/data-source-options).

Once this is done, the TypeORM `DataSource` and `EntityManager` objects will be available to inject across the entire project (without needing to import any modules), for example:

content\_copy app.module.ts

JS  TS

```typescript

import { DataSource } from 'typeorm';

@Module({
  imports: [TypeOrmModule.forRoot(), UsersModule],
})
export class AppModule {
  constructor(private dataSource: DataSource) {}
}

```

```typescript

import { DataSource } from 'typeorm';

@Dependencies(DataSource)
@Module({
  imports: [TypeOrmModule.forRoot(), UsersModule],
})
export class AppModule {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
}

```

#### Repository pattern [\#](https://docs.nestjs.com/techniques/database\#repository-pattern)

[TypeORM](https://github.com/typeorm/typeorm) supports the **repository design pattern**, so each entity has its own repository. These repositories can be obtained from the database data source.

To continue the example, we need at least one entity. Let's define the `User` entity.

content\_copy user.entity.ts

JS  TS

```typescript

import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;
}

```

> **Hint** Learn more about entities in the [TypeORM documentation](https://typeorm.io/docs/entity/entities/).

The `User` entity file sits in the `users` directory. This directory contains all files related to the `UsersModule`. You can decide where to keep your model files, however, we recommend creating them near their **domain**, in the corresponding module directory.

To begin using the `User` entity, we need to let TypeORM know about it by inserting it into the `entities` array in the module `forRoot()` method options (unless you use a static glob path):

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './users/user.entity';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      type: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      entities: [User],\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

Next, let's look at the `UsersModule`:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User } from './user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

This module uses the `forFeature()` method to define which repositories are registered in the current scope. With that in place, we can inject the `UsersRepository` into the `UsersService` using the `@InjectRepository()` decorator:

content\_copy users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  findAll(): Promise<User[]> {
    return this.usersRepository.find();
  }

  findOne(id: number): Promise<User | null> {
    return this.usersRepository.findOneBy({ id });
  }

  async remove(id: number): Promise<void> {
    await this.usersRepository.delete(id);
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { getRepositoryToken } from '@nestjs/typeorm';
import { User } from './user.entity';

@Injectable()
@Dependencies(getRepositoryToken(User))
export class UsersService {
  constructor(usersRepository) {
    this.usersRepository = usersRepository;
  }

  findAll() {
    return this.usersRepository.find();
  }

  findOne(id) {
    return this.usersRepository.findOneBy({ id });
  }

  async remove(id) {
    await this.usersRepository.delete(id);
  }
}

```

> **Notice** Don't forget to import the `UsersModule` into the root `AppModule`.

If you want to use the repository outside of the module which imports `TypeOrmModule.forFeature`, you'll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  exports: [TypeOrmModule]
})
export class UsersModule {}

```

Now if we import `UsersModule` in `UserHttpModule`, we can use `@InjectRepository(User)` in the providers of the latter module.

content\_copy users-http.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersModule } from './users.module';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserHttpModule {}

```

#### Relations [\#](https://docs.nestjs.com/techniques/database\#relations)

Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.

There are three types of relations:

|     |     |
| --- | --- |
| `One-to-one` | Every row in the primary table has one and only one associated row in the foreign table. Use the `@OneToOne()` decorator to define this type of relation. |
| `One-to-many / Many-to-one` | Every row in the primary table has one or more related rows in the foreign table. Use the `@OneToMany()` and `@ManyToOne()` decorators to define this type of relation. |
| `Many-to-many` | Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table. Use the `@ManyToMany()` decorator to define this type of relation. |

To define relations in entities, use the corresponding **decorators**. For example, to define that each `User` can have multiple photos, use the `@OneToMany()` decorator.

content\_copy user.entity.ts

JS  TS

```typescript

import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';
import { Photo } from '../photos/photo.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;

  @OneToMany(type => Photo, photo => photo.user)
  photos: Photo[];
}

```

> **Hint** To learn more about relations in TypeORM, visit the [TypeORM documentation](https://typeorm.io/#/relations).

#### Auto-load entities [\#](https://docs.nestjs.com/techniques/database\#auto-load-entities)

Manually adding entities to the `entities` array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the `autoLoadEntities` property of the configuration object (passed into the `forRoot()` method) to `true`, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      ...\
      autoLoadEntities: true,\
    }),\
  ],
})
export class AppModule {}

```

With that option specified, every entity registered through the `forFeature()` method will be automatically added to the `entities` array of the configuration object.

> **Warning** Note that entities that aren't registered through the `forFeature()` method, but are only referenced from the entity (via a relationship), won't be included by way of the `autoLoadEntities` setting.

#### Separating entity definition [\#](https://docs.nestjs.com/techniques/database\#separating-entity-definition)

You can define an entity and its columns right in the model, using decorators. But some people prefer to define entities and their columns inside separate files using the ["entity schemas"](https://typeorm.io/#/separating-entity-definition).

content\_copy

```typescript

import { EntitySchema } from 'typeorm';
import { User } from './user.entity';

export const UserSchema = new EntitySchema<User>({
  name: 'User',
  target: User,
  columns: {
    id: {
      type: Number,
      primary: true,
      generated: true,
    },
    firstName: {
      type: String,
    },
    lastName: {
      type: String,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  relations: {
    photos: {
      type: 'one-to-many',
      target: 'Photo', // the name of the PhotoSchema
    },
  },
});

```

> **Warning** If you provide the `target` option, the `name` option value has to be the same as the name of the target class.
> If you do not provide the `target` you can use any name.

Nest allows you to use an `EntitySchema` instance wherever an `Entity` is expected, for example:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserSchema } from './user.schema';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [TypeOrmModule.forFeature([UserSchema])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

#### TypeORM Transactions [\#](https://docs.nestjs.com/techniques/database\#typeorm-transactions)

A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database ( [learn more](https://en.wikipedia.org/wiki/Database_transaction)).

There are many different strategies to handle [TypeORM transactions](https://typeorm.io/docs/advanced-topics/transactions/). We recommend using the `QueryRunner` class because it gives full control over the transaction.

First, we need to inject the `DataSource` object into a class in the normal way:

content\_copy

```typescript

@Injectable()
export class UsersService {
  constructor(private dataSource: DataSource) {}
}

```

> **Hint** The `DataSource` class is imported from the `typeorm` package.

Now, we can use this object to create a transaction.

content\_copy

```typescript

async createMany(users: User[]) {
  const queryRunner = this.dataSource.createQueryRunner();

  await queryRunner.connect();
  await queryRunner.startTransaction();
  try {
    await queryRunner.manager.save(users[0]);
    await queryRunner.manager.save(users[1]);

    await queryRunner.commitTransaction();
  } catch (err) {
    // since we have errors lets rollback the changes we made
    await queryRunner.rollbackTransaction();
  } finally {
    // you need to release a queryRunner which was manually instantiated
    await queryRunner.release();
  }
}

```

> **Hint** Note that the `dataSource` is used only to create the `QueryRunner`. However, to test this class would require mocking the entire `DataSource` object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., `QueryRunnerFactory`) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.

## Explore your graph with NestJS Devtools

- Graph visualizer
- Routes navigator
- Interactive playground
- CI/CD integration

[Sign up](https://devtools.nestjs.com/ "Devtools | NestJS - A node.js framework built on top of TypeScript")

Alternatively, you can use the callback-style approach with the `transaction` method of the `DataSource` object ( [read more](https://typeorm.io/docs/advanced-topics/transactions/#creating-and-using-transactions)).

content\_copy

```typescript

async createMany(users: User[]) {
  await this.dataSource.transaction(async manager => {
    await manager.save(users[0]);
    await manager.save(users[1]);
  });
}

```

#### Subscribers [\#](https://docs.nestjs.com/techniques/database\#subscribers)

With TypeORM [subscribers](https://typeorm.io/docs/advanced-topics/listeners-and-subscribers#what-is-a-subscriber), you can listen to specific entity events.

content\_copy

```typescript

import {
  DataSource,
  EntitySubscriberInterface,
  EventSubscriber,
  InsertEvent,
} from 'typeorm';
import { User } from './user.entity';

@EventSubscriber()
export class UserSubscriber implements EntitySubscriberInterface<User> {
  constructor(dataSource: DataSource) {
    dataSource.subscribers.push(this);
  }

  listenTo() {
    return User;
  }

  beforeInsert(event: InsertEvent<User>) {
    console.log(`BEFORE USER INSERTED: `, event.entity);
  }
}

```

> **Warning** Event subscribers can not be [request-scoped](https://docs.nestjs.com/fundamentals/injection-scopes).

Now, add the `UserSubscriber` class to the `providers` array:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { UserSubscriber } from './user.subscriber';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService, UserSubscriber],
  controllers: [UsersController],
})
export class UsersModule {}

```

#### Migrations [\#](https://docs.nestjs.com/techniques/database\#migrations)

[Migrations](https://typeorm.io/#/migrations) provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated [CLI](https://typeorm.io/#/migrations/creating-a-new-migration).

Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the TypeORM CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the [TypeORM documentation](https://typeorm.io/#/migrations/creating-a-new-migration).

#### Multiple databases [\#](https://docs.nestjs.com/techniques/database\#multiple-databases)

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, data source naming becomes **mandatory**.

Suppose you have an `Album` entity stored in its own database.

content\_copy

```typescript

const defaultOptions = {
  type: 'postgres',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'db',
  synchronize: true,
};

@Module({
  imports: [\
    TypeOrmModule.forRoot({\
      ...defaultOptions,\
      host: 'user_db_host',\
      entities: [User],\
    }),\
    TypeOrmModule.forRoot({\
      ...defaultOptions,\
      name: 'albumsConnection',\
      host: 'album_db_host',\
      entities: [Album],\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** If you don't set the `name` for a data source, its name is set to `default`. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.

> **Notice** If you are using `TypeOrmModule.forRootAsync`, you have to **also** set the data source name outside `useFactory`. For example:
> content\_copy
>
> ```typescript
>
> TypeOrmModule.forRootAsync({
>   name: 'albumsConnection',
>   useFactory: ...,
>   inject: ...,
> }),
>
> ```
>
> See [this issue](https://github.com/nestjs/typeorm/issues/86) for more details.

At this point, you have `User` and `Album` entities registered with their own data source. With this setup, you have to tell the `TypeOrmModule.forFeature()` method and the `@InjectRepository()` decorator which data source should be used. If you do not pass any data source name, the `default` data source is used.

content\_copy

```typescript

@Module({
  imports: [\
    TypeOrmModule.forFeature([User]),\
    TypeOrmModule.forFeature([Album], 'albumsConnection'),\
  ],
})
export class AppModule {}

```

You can also inject the `DataSource` or `EntityManager` for a given data source:

content\_copy

```typescript

@Injectable()
export class AlbumsService {
  constructor(
    @InjectDataSource('albumsConnection')
    private dataSource: DataSource,
    @InjectEntityManager('albumsConnection')
    private entityManager: EntityManager,
  ) {}
}

```

It's also possible to inject any `DataSource` to the providers:

content\_copy

```typescript

@Module({
  providers: [\
    {\
      provide: AlbumsService,\
      useFactory: (albumsConnection: DataSource) => {\
        return new AlbumsService(albumsConnection);\
      },\
      inject: [getDataSourceToken('albumsConnection')],\
    },\
  ],
})
export class AlbumsModule {}

```

#### Testing [\#](https://docs.nestjs.com/techniques/database\#testing)

When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on repositories that are pulled from the data source (connection) instance. How do we handle that? The solution is to create mock repositories. In order to achieve that, we set up [custom providers](https://docs.nestjs.com/fundamentals/custom-providers). Each registered repository is automatically represented by an `<EntityName>Repository` token, where `EntityName` is the name of your entity class.

The `@nestjs/typeorm` package exposes the `getRepositoryToken()` function which returns a prepared token based on a given entity.

content\_copy

```typescript

@Module({
  providers: [\
    UsersService,\
    {\
      provide: getRepositoryToken(User),\
      useValue: mockRepository,\
    },\
  ],
})
export class UsersModule {}

```

Now a substitute `mockRepository` will be used as the `UsersRepository`. Whenever any class asks for `UsersRepository` using an `@InjectRepository()` decorator, Nest will use the registered `mockRepository` object.

#### Async configuration [\#](https://docs.nestjs.com/techniques/database\#async-configuration)

You may want to pass your repository module options asynchronously instead of statically. In this case, use the `forRootAsync()` method, which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  useFactory: () => ({
    type: 'mysql',
    host: 'localhost',
    port: 3306,
    username: 'root',
    password: 'root',
    database: 'test',
    entities: [],
    synchronize: true,
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    entities: [],
    synchronize: true,
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  useClass: TypeOrmConfigService,
});

```

The construction above will instantiate `TypeOrmConfigService` inside `TypeOrmModule` and use it to provide an options object by calling `createTypeOrmOptions()`. Note that this means that the `TypeOrmConfigService` has to implement the `TypeOrmOptionsFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  createTypeOrmOptions(): TypeOrmModuleOptions {
    return {
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [],
      synchronize: true,
    };
  }
}

```

In order to prevent the creation of `TypeOrmConfigService` inside `TypeOrmModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `TypeOrmModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

> **Hint** Make sure that the `name` property is defined at the same level as the `useFactory`, `useClass`, or `useValue` property. This will allow Nest to properly register the data source under the appropriate injection token.

#### Custom DataSource Factory [\#](https://docs.nestjs.com/techniques/database\#custom-datasource-factory)

In conjunction with async configuration using `useFactory`, `useClass`, or `useExisting`, you can optionally specify a `dataSourceFactory` function which will allow you to provide your own TypeORM data source rather than allowing `TypeOrmModule` to create the data source.

`dataSourceFactory` receives the TypeORM `DataSourceOptions` configured during async configuration using `useFactory`, `useClass`, or `useExisting` and returns a `Promise` that resolves a TypeORM `DataSource`.

content\_copy

```typescript

TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  // Use useFactory, useClass, or useExisting
  // to configure the DataSourceOptions.
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    entities: [],
    synchronize: true,
  }),
  // dataSource receives the configured DataSourceOptions
  // and returns a Promise<DataSource>.
  dataSourceFactory: async (options) => {
    const dataSource = await new DataSource(options).initialize();
    return dataSource;
  },
});

```

> **Hint** The `DataSource` class is imported from the `typeorm` package.

#### Example [\#](https://docs.nestjs.com/techniques/database\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/05-sql-typeorm).

## Official enterprise support

- Providing technical guidance
- Performing in-depth code reviews
- Mentoring team members
- Advising best practices

[Explore more](https://enterprise.nestjs.com/ "Enterprise | NestJS - A progressive Node.js framework")

### Sequelize Integration

An alternative to using TypeORM is to use the [Sequelize](https://sequelize.org/) ORM with the `@nestjs/sequelize` package. In addition, we leverage the [sequelize-typescript](https://github.com/RobinBuschmann/sequelize-typescript) package which provides a set of additional decorators to declaratively define entities.

To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular [MySQL](https://www.mysql.com/) Relational DBMS, but Sequelize provides support for many relational databases, such as PostgreSQL, MySQL, Microsoft SQL Server, SQLite, and MariaDB. The procedure we walk through in this chapter will be the same for any database supported by Sequelize. You'll simply need to install the associated client API libraries for your selected database.

```bash

$ npm install --save @nestjs/sequelize sequelize sequelize-typescript mysql2
$ npm install --save-dev @types/sequelize

```

Once the installation process is complete, we can import the `SequelizeModule` into the root `AppModule`.

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      dialect: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      models: [],\
    }),\
  ],
})
export class AppModule {}

```

The `forRoot()` method supports all the configuration properties exposed by the Sequelize constructor ( [read more](https://sequelize.org/docs/v6/getting-started/#connecting-to-a-database)). In addition, there are several extra configuration properties described below.

|     |     |
| --- | --- |
| `retryAttempts` | Number of attempts to connect to the database (default: `10`) |
| `retryDelay` | Delay between connection retry attempts (ms) (default: `3000`) |
| `autoLoadModels` | If `true`, models will be loaded automatically (default: `false`) |
| `keepConnectionAlive` | If `true`, connection will not be closed on the application shutdown (default: `false`) |
| `synchronize` | If `true`, automatically loaded models will be synchronized (default: `true`) |

Once this is done, the `Sequelize` object will be available to inject across the entire project (without needing to import any modules), for example:

content\_copy app.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { Sequelize } from 'sequelize-typescript';

@Injectable()
export class AppService {
  constructor(private sequelize: Sequelize) {}
}

```

```typescript

import { Injectable } from '@nestjs/common';
import { Sequelize } from 'sequelize-typescript';

@Dependencies(Sequelize)
@Injectable()
export class AppService {
  constructor(sequelize) {
    this.sequelize = sequelize;
  }
}

```

#### Models [\#](https://docs.nestjs.com/techniques/database\#models)

Sequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database. To continue the example, we need at least one model. Let's define the `User` model.

content\_copy user.model.ts

JS  TS

```typescript

import { Column, Model, Table } from 'sequelize-typescript';

@Table
export class User extends Model {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;
}

```

> **Hint** Learn more about the available decorators [here](https://github.com/RobinBuschmann/sequelize-typescript#column).

The `User` model file sits in the `users` directory. This directory contains all files related to the `UsersModule`. You can decide where to keep your model files, however, we recommend creating them near their **domain**, in the corresponding module directory.

To begin using the `User` model, we need to let Sequelize know about it by inserting it into the `models` array in the module `forRoot()` method options:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './users/user.model';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      dialect: 'mysql',\
      host: 'localhost',\
      port: 3306,\
      username: 'root',\
      password: 'root',\
      database: 'test',\
      models: [User],\
    }),\
  ],
})
export class AppModule {}

```

Next, let's look at the `UsersModule`:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.model';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}

```

This module uses the `forFeature()` method to define which models are registered in the current scope. With that in place, we can inject the `UserModel` into the `UsersService` using the `@InjectModel()` decorator:

content\_copy users.service.ts

JS  TS

```typescript

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { User } from './user.model';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User)
    private userModel: typeof User,
  ) {}

  async findAll(): Promise<User[]> {
    return this.userModel.findAll();
  }

  findOne(id: string): Promise<User> {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await user.destroy();
  }
}

```

```typescript

import { Injectable, Dependencies } from '@nestjs/common';
import { getModelToken } from '@nestjs/sequelize';
import { User } from './user.model';

@Injectable()
@Dependencies(getModelToken(User))
export class UsersService {
  constructor(usersRepository) {
    this.usersRepository = usersRepository;
  }

  async findAll() {
    return this.userModel.findAll();
  }

  findOne(id) {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id) {
    const user = await this.findOne(id);
    await user.destroy();
  }
}

```

> **Notice** Don't forget to import the `UsersModule` into the root `AppModule`.

If you want to use the model outside of the module which imports `SequelizeModule.forFeature`, you'll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:

content\_copy users.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.entity';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  exports: [SequelizeModule]
})
export class UsersModule {}

```

Now if we import `UsersModule` in `UserHttpModule`, we can use `@InjectModel(User)` in the providers of the latter module.

content\_copy users-http.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { UsersModule } from './users.module';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserHttpModule {}

```

#### Relations [\#](https://docs.nestjs.com/techniques/database\#relations-1)

Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.

There are three types of relations:

|     |     |
| --- | --- |
| `One-to-one` | Every row in the primary table has one and only one associated row in the foreign table |
| `One-to-many / Many-to-one` | Every row in the primary table has one or more related rows in the foreign table |
| `Many-to-many` | Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table |

To define relations in models, use the corresponding **decorators**. For example, to define that each `User` can have multiple photos, use the `@HasMany()` decorator.

content\_copy user.model.ts

JS  TS

```typescript

import { Column, Model, Table, HasMany } from 'sequelize-typescript';
import { Photo } from '../photos/photo.model';

@Table
export class User extends Model {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;

  @HasMany(() => Photo)
  photos: Photo[];
}

```

> **Hint** To learn more about associations in Sequelize, read [this](https://github.com/RobinBuschmann/sequelize-typescript#model-association) chapter.

#### Auto-load models [\#](https://docs.nestjs.com/techniques/database\#auto-load-models)

Manually adding models to the `models` array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both `autoLoadModels` and `synchronize` properties of the configuration object (passed into the `forRoot()` method) to `true`, as shown below:

content\_copy app.module.ts

JS  TS

```typescript

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      ...\
      autoLoadModels: true,\
      synchronize: true,\
    }),\
  ],
})
export class AppModule {}

```

With that option specified, every model registered through the `forFeature()` method will be automatically added to the `models` array of the configuration object.

> **Warning** Note that models that aren't registered through the `forFeature()` method, but are only referenced from the model (via an association), won't be included.

#### Sequelize Transactions [\#](https://docs.nestjs.com/techniques/database\#sequelize-transactions)

A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database ( [learn more](https://en.wikipedia.org/wiki/Database_transaction)).

There are many different strategies to handle [Sequelize transactions](https://sequelize.org/docs/v6/other-topics/transactions/). Below is a sample implementation of a managed transaction (auto-callback).

First, we need to inject the `Sequelize` object into a class in the normal way:

content\_copy

```typescript

@Injectable()
export class UsersService {
  constructor(private sequelize: Sequelize) {}
}

```

> **Hint** The `Sequelize` class is imported from the `sequelize-typescript` package.

Now, we can use this object to create a transaction.

content\_copy

```typescript

async createMany() {
  try {
    await this.sequelize.transaction(async t => {
      const transactionHost = { transaction: t };

      await this.userModel.create(
          { firstName: 'Abraham', lastName: 'Lincoln' },
          transactionHost,
      );
      await this.userModel.create(
          { firstName: 'John', lastName: 'Boothe' },
          transactionHost,
      );
    });
  } catch (err) {
    // Transaction has been rolled back
    // err is whatever rejected the promise chain returned to the transaction callback
  }
}

```

> **Hint** Note that the `Sequelize` instance is used only to start the transaction. However, to test this class would require mocking the entire `Sequelize` object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., `TransactionRunner`) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.

#### Migrations [\#](https://docs.nestjs.com/techniques/database\#migrations-1)

[Migrations](https://sequelize.org/docs/v6/other-topics/migrations/) provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, Sequelize provides a dedicated [CLI](https://sequelize.org/docs/v6/other-topics/migrations/#installing-the-cli).

Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the [Sequelize documentation](https://sequelize.org/docs/v6/other-topics/migrations/#installing-the-cli).

## Learn the right way!

- 80+ chapters
- 5+ hours of videos
- Official certificate
- Deep-dive sessions

[Explore official courses](https://courses.nestjs.com/ "Courses | NestJS - A node.js framework built on top of TypeScript")

#### Multiple databases [\#](https://docs.nestjs.com/techniques/database\#multiple-databases-1)

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes **mandatory**.

Suppose you have an `Album` entity stored in its own database.

content\_copy

```typescript

const defaultOptions = {
  dialect: 'postgres',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'db',
  synchronize: true,
};

@Module({
  imports: [\
    SequelizeModule.forRoot({\
      ...defaultOptions,\
      host: 'user_db_host',\
      models: [User],\
    }),\
    SequelizeModule.forRoot({\
      ...defaultOptions,\
      name: 'albumsConnection',\
      host: 'album_db_host',\
      models: [Album],\
    }),\
  ],
})
export class AppModule {}

```

> **Notice** If you don't set the `name` for a connection, its name is set to `default`. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.

At this point, you have `User` and `Album` models registered with their own connection. With this setup, you have to tell the `SequelizeModule.forFeature()` method and the `@InjectModel()` decorator which connection should be used. If you do not pass any connection name, the `default` connection is used.

content\_copy

```typescript

@Module({
  imports: [\
    SequelizeModule.forFeature([User]),\
    SequelizeModule.forFeature([Album], 'albumsConnection'),\
  ],
})
export class AppModule {}

```

You can also inject the `Sequelize` instance for a given connection:

content\_copy

```typescript

@Injectable()
export class AlbumsService {
  constructor(
    @InjectConnection('albumsConnection')
    private sequelize: Sequelize,
  ) {}
}

```

It's also possible to inject any `Sequelize` instance to the providers:

content\_copy

```typescript

@Module({
  providers: [\
    {\
      provide: AlbumsService,\
      useFactory: (albumsSequelize: Sequelize) => {\
        return new AlbumsService(albumsSequelize);\
      },\
      inject: [getDataSourceToken('albumsConnection')],\
    },\
  ],
})
export class AlbumsModule {}

```

#### Testing [\#](https://docs.nestjs.com/techniques/database\#testing-1)

When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up [custom providers](https://docs.nestjs.com/fundamentals/custom-providers). Each registered model is automatically represented by a `<ModelName>Model` token, where `ModelName` is the name of your model class.

The `@nestjs/sequelize` package exposes the `getModelToken()` function which returns a prepared token based on a given model.

content\_copy

```typescript

@Module({
  providers: [\
    UsersService,\
    {\
      provide: getModelToken(User),\
      useValue: mockModel,\
    },\
  ],
})
export class UsersModule {}

```

Now a substitute `mockModel` will be used as the `UserModel`. Whenever any class asks for `UserModel` using an `@InjectModel()` decorator, Nest will use the registered `mockModel` object.

#### Async configuration [\#](https://docs.nestjs.com/techniques/database\#async-configuration-1)

You may want to pass your `SequelizeModule` options asynchronously instead of statically. In this case, use the `forRootAsync()` method, which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

SequelizeModule.forRootAsync({
  useFactory: () => ({
    dialect: 'mysql',
    host: 'localhost',
    port: 3306,
    username: 'root',
    password: 'root',
    database: 'test',
    models: [],
  }),
});

```

Our factory behaves like any other [asynchronous provider](https://docs.nestjs.com/fundamentals/async-providers) (e.g., it can be `async` and it's able to inject dependencies through `inject`).

content\_copy

```typescript

SequelizeModule.forRootAsync({
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) => ({
    dialect: 'mysql',
    host: configService.get('HOST'),
    port: +configService.get('PORT'),
    username: configService.get('USERNAME'),
    password: configService.get('PASSWORD'),
    database: configService.get('DATABASE'),
    models: [],
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` syntax:

content\_copy

```typescript

SequelizeModule.forRootAsync({
  useClass: SequelizeConfigService,
});

```

The construction above will instantiate `SequelizeConfigService` inside `SequelizeModule` and use it to provide an options object by calling `createSequelizeOptions()`. Note that this means that the `SequelizeConfigService` has to implement the `SequelizeOptionsFactory` interface, as shown below:

content\_copy

```typescript

@Injectable()
class SequelizeConfigService implements SequelizeOptionsFactory {
  createSequelizeOptions(): SequelizeModuleOptions {
    return {
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      models: [],
    };
  }
}

```

In order to prevent the creation of `SequelizeConfigService` inside `SequelizeModule` and use a provider imported from a different module, you can use the `useExisting` syntax.

content\_copy

```typescript

SequelizeModule.forRootAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This construction works the same as `useClass` with one critical difference - `SequelizeModule` will lookup imported modules to reuse an existing `ConfigService` instead of instantiating a new one.

#### Example [\#](https://docs.nestjs.com/techniques/database\#example-1)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/07-sequelize).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Caching Techniques
- [Caching](https://docs.nestjs.com/techniques/caching#caching)
- [Installation](https://docs.nestjs.com/techniques/caching#installation)
- [In-memory cache](https://docs.nestjs.com/techniques/caching#in-memory-cache)
- [Interacting with the Cache store](https://docs.nestjs.com/techniques/caching#interacting-with-the-cache-store)
- [Auto-caching responses](https://docs.nestjs.com/techniques/caching#auto-caching-responses)
- [Time-to-live (TTL)](https://docs.nestjs.com/techniques/caching#time-to-live-ttl)
- [Use module globally](https://docs.nestjs.com/techniques/caching#use-module-globally)
- [Global cache overrides](https://docs.nestjs.com/techniques/caching#global-cache-overrides)
- [WebSockets and Microservices](https://docs.nestjs.com/techniques/caching#websockets-and-microservices)
- [Adjust tracking](https://docs.nestjs.com/techniques/caching#adjust-tracking)
- [Using alternative Cache stores](https://docs.nestjs.com/techniques/caching#using-alternative-cache-stores)
- [Async configuration](https://docs.nestjs.com/techniques/caching#async-configuration)
- [Example](https://docs.nestjs.com/techniques/caching#example)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/caching.md "Suggest Edits")

### Caching

Caching is a powerful and straightforward **technique** for enhancing your application's performance. By acting as a temporary storage layer, it allows for quicker access to frequently used data, reducing the need to repeatedly fetch or compute the same information. This results in faster response times and improved overall efficiency.

#### Installation [\#](https://docs.nestjs.com/techniques/caching\#installation)

To get started with caching in Nest, you need to install the `@nestjs/cache-manager` package along with the `cache-manager` package.

```bash

$ npm install @nestjs/cache-manager cache-manager

```

By default, everything is stored in memory; Since `cache-manager` uses [Keyv](https://keyv.org/docs/) under the hood, you can easily switch to a more advanced storage solution, such as Redis, by installing the appropriate package. We'll cover this in more detail later.

#### In-memory cache [\#](https://docs.nestjs.com/techniques/caching\#in-memory-cache)

To enable caching in your application, import the `CacheModule` and configure it using the `register()` method:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { AppController } from './app.controller';

@Module({
  imports: [CacheModule.register()],
  controllers: [AppController],
})
export class AppModule {}

```

This setup initializes in-memory caching with default settings, allowing you to start caching data immediately.

#### Interacting with the Cache store [\#](https://docs.nestjs.com/techniques/caching\#interacting-with-the-cache-store)

To interact with the cache manager instance, inject it to your class using the `CACHE_MANAGER` token, as follows:

content\_copy

```typescript

constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}

```

> **Hint** The `Cache` class and the `CACHE_MANAGER` token are both imported from the `@nestjs/cache-manager` package.

The `get` method on the `Cache` instance (from the `cache-manager` package) is used to retrieve items from the cache. If the item does not exist in the cache, `null` will be returned.

content\_copy

```typescript

const value = await this.cacheManager.get('key');

```

To add an item to the cache, use the `set` method:

content\_copy

```typescript

await this.cacheManager.set('key', 'value');

```

> **Note** The in-memory cache storage can only store values of types that are supported by [the structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#javascript_types).

You can manually specify a TTL (expiration time in milliseconds) for this specific key, as follows:

content\_copy

```typescript

await this.cacheManager.set('key', 'value', 1000);

```

Where `1000` is the TTL in milliseconds - in this case, the cache item will expire after one second.

To disable expiration of the cache, set the `ttl` configuration property to `0`:

content\_copy

```typescript

await this.cacheManager.set('key', 'value', 0);

```

To remove an item from the cache, use the `del` method:

content\_copy

```typescript

await this.cacheManager.del('key');

```

To clear the entire cache, use the `clear` method:

content\_copy

```typescript

await this.cacheManager.clear();

```

#### Auto-caching responses [\#](https://docs.nestjs.com/techniques/caching\#auto-caching-responses)

> **Warning** In [GraphQL](https://docs.nestjs.com/graphql/quick-start) applications, interceptors are executed separately for each field resolver. Thus, `CacheModule` (which uses interceptors to cache responses) will not work properly.

To enable auto-caching responses, just tie the `CacheInterceptor` where you want to cache data.

content\_copy

```typescript

@Controller()
@UseInterceptors(CacheInterceptor)
export class AppController {
  @Get()
  findAll(): string[] {
    return [];
  }
}

```

> **Warning** Only `GET` endpoints are cached. Also, HTTP server routes that inject the native response object ( `@Res()`) cannot use the Cache Interceptor. See
> [response mapping](https://docs.nestjs.com/interceptors#response-mapping) for more details.

To reduce the amount of required boilerplate, you can bind `CacheInterceptor` to all endpoints globally:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { CacheModule, CacheInterceptor } from '@nestjs/cache-manager';
import { AppController } from './app.controller';
import { APP_INTERCEPTOR } from '@nestjs/core';

@Module({
  imports: [CacheModule.register()],
  controllers: [AppController],
  providers: [\
    {\
      provide: APP_INTERCEPTOR,\
      useClass: CacheInterceptor,\
    },\
  ],
})
export class AppModule {}

```

#### Time-to-live (TTL) [\#](https://docs.nestjs.com/techniques/caching\#time-to-live-ttl)

The default value for `ttl` is `0`, meaning the cache will never expire. To specify a custom [TTL](https://en.wikipedia.org/wiki/Time_to_live), you can provide the `ttl` option in the `register()` method, as demonstrated below:

content\_copy

```typescript

CacheModule.register({
  ttl: 5000, // milliseconds
});

```

#### Use module globally [\#](https://docs.nestjs.com/techniques/caching\#use-module-globally)

When you want to use `CacheModule` in other modules, you'll need to import it (as is standard with any Nest module). Alternatively, declare it as a [global module](https://docs.nestjs.com/modules#global-modules) by setting the options object's `isGlobal` property to `true`, as shown below. In that case, you will not need to import `CacheModule` in other modules once it's been loaded in the root module (e.g., `AppModule`).

content\_copy

```typescript

CacheModule.register({
  isGlobal: true,
});

```

#### Global cache overrides [\#](https://docs.nestjs.com/techniques/caching\#global-cache-overrides)

While global cache is enabled, cache entries are stored under a `CacheKey` that is auto-generated based on the route path. You may override certain cache settings ( `@CacheKey()` and `@CacheTTL()`) on a per-method basis, allowing customized caching strategies for individual controller methods. This may be most relevant while using [different cache stores.](https://docs.nestjs.com/techniques/caching#different-stores)

You can apply the `@CacheTTL()` decorator on a per-controller basis to set a caching TTL for the entire controller. In situations where both controller-level and method-level cache TTL settings are defined, the cache TTL settings specified at the method level will take priority over the ones set at the controller level.

content\_copy

```typescript

@Controller()
@CacheTTL(50)
export class AppController {
  @CacheKey('custom_key')
  @CacheTTL(20)
  findAll(): string[] {
    return [];
  }
}

```

> **Hint** The `@CacheKey()` and `@CacheTTL()` decorators are imported from the `@nestjs/cache-manager` package.

The `@CacheKey()` decorator may be used with or without a corresponding `@CacheTTL()` decorator and vice versa. One may choose to override only the `@CacheKey()` or only the `@CacheTTL()`. Settings that are not overridden with a decorator will use the default values as registered globally (see [Customize caching](https://docs.nestjs.com/techniques/caching#customize-caching)).

#### WebSockets and Microservices [\#](https://docs.nestjs.com/techniques/caching\#websockets-and-microservices)

You can also apply the `CacheInterceptor` to WebSocket subscribers as well as Microservice's patterns (regardless of the transport method that is being used).

content\_copy

JS  TS

```typescript

@CacheKey('events')
@UseInterceptors(CacheInterceptor)
@SubscribeMessage('events')
handleEvent(client: Client, data: string[]): Observable<string[]> {
  return [];
}

```

```typescript

@CacheKey('events')
@UseInterceptors(CacheInterceptor)
@SubscribeMessage('events')
handleEvent(client, data) {
  return [];
}

```

However, the additional `@CacheKey()` decorator is required in order to specify a key used to subsequently store and retrieve cached data. Also, please note that you **shouldn't cache everything**. Actions which perform some business operations rather than simply querying the data should never be cached.

Additionally, you may specify a cache expiration time (TTL) by using the `@CacheTTL()` decorator, which will override the global default TTL value.

content\_copy

JS  TS

```typescript

@CacheTTL(10)
@UseInterceptors(CacheInterceptor)
@SubscribeMessage('events')
handleEvent(client: Client, data: string[]): Observable<string[]> {
  return [];
}

```

```typescript

@CacheTTL(10)
@UseInterceptors(CacheInterceptor)
@SubscribeMessage('events')
handleEvent(client, data) {
  return [];
}

```

> **Hint** The `@CacheTTL()` decorator may be used with or without a corresponding `@CacheKey()` decorator.

#### Adjust tracking [\#](https://docs.nestjs.com/techniques/caching\#adjust-tracking)

By default, Nest uses the request URL (in an HTTP app) or cache key (in websockets and microservices apps, set through the `@CacheKey()` decorator) to associate cache records with your endpoints. Nevertheless, sometimes you might want to set up tracking based on different factors, for example, using HTTP headers (e.g. `Authorization` to properly identify `profile` endpoints).

In order to accomplish that, create a subclass of `CacheInterceptor` and override the `trackBy()` method.

content\_copy

```typescript

@Injectable()
class HttpCacheInterceptor extends CacheInterceptor {
  trackBy(context: ExecutionContext): string | undefined {
    return 'key';
  }
}

```

#### Using alternative Cache stores [\#](https://docs.nestjs.com/techniques/caching\#using-alternative-cache-stores)

Switching to a different cache store is straightforward. First, install the appropriate package. For example, to use Redis, install the `@keyv/redis` package:

```bash

$ npm install @keyv/redis

```

With this in place, you can register the `CacheModule` with multiple stores as shown below:

content\_copy

```typescript

import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { AppController } from './app.controller';
import KeyvRedis from '@keyv/redis';
import { Keyv } from 'keyv';
import { CacheableMemory } from 'cacheable';

@Module({
  imports: [\
    CacheModule.registerAsync({\
      useFactory: async () => {\
        return {\
          stores: [\
            new Keyv({\
              store: new CacheableMemory({ ttl: 60000, lruSize: 5000 }),\
            }),\
            new KeyvRedis('redis://localhost:6379'),\
          ],\
        };\
      },\
    }),\
  ],
  controllers: [AppController],
})
export class AppModule {}

```

In this example, we've registered two stores: `CacheableMemory` and `KeyvRedis`. The `CacheableMemory` store is a simple in-memory store, while `KeyvRedis` is a Redis store. The `stores` array is used to specify the stores you want to use. The first store in the array is the default store, and the rest are fallback stores.

Check out the [Keyv documentation](https://keyv.org/docs/) for more information on available stores.

#### Async configuration [\#](https://docs.nestjs.com/techniques/caching\#async-configuration)

You may want to asynchronously pass in module options instead of passing them statically at compile time. In this case, use the `registerAsync()` method, which provides several ways to deal with async configuration.

One approach is to use a factory function:

content\_copy

```typescript

CacheModule.registerAsync({
  useFactory: () => ({
    ttl: 5,
  }),
});

```

Our factory behaves like all other asynchronous module factories (it can be `async` and is able to inject dependencies through `inject`).

content\_copy

```typescript

CacheModule.registerAsync({
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) => ({
    ttl: configService.get('CACHE_TTL'),
  }),
  inject: [ConfigService],
});

```

Alternatively, you can use the `useClass` method:

content\_copy

```typescript

CacheModule.registerAsync({
  useClass: CacheConfigService,
});

```

The above construction will instantiate `CacheConfigService` inside `CacheModule` and will use it to get the options object. The `CacheConfigService` has to implement the `CacheOptionsFactory` interface in order to provide the configuration options:

content\_copy

```typescript

@Injectable()
class CacheConfigService implements CacheOptionsFactory {
  createCacheOptions(): CacheModuleOptions {
    return {
      ttl: 5,
    };
  }
}

```

If you wish to use an existing configuration provider imported from a different module, use the `useExisting` syntax:

content\_copy

```typescript

CacheModule.registerAsync({
  imports: [ConfigModule],
  useExisting: ConfigService,
});

```

This works the same as `useClass` with one critical difference - `CacheModule` will lookup imported modules to reuse any already-created `ConfigService`, instead of instantiating its own.

> **Hint** `CacheModule#register`, `CacheModule#registerAsync` and `CacheOptionsFactory` have an optional generic (type argument) to narrow down store-specific configuration options, making it type safe.

You can also pass so-called `extraProviders` to the `registerAsync()` method. These providers will be merged with the module providers.

content\_copy

```typescript

CacheModule.registerAsync({
  imports: [ConfigModule],
  useClass: ConfigService,
  extraProviders: [MyAdditionalProvider],
});

```

This is useful when you want to provide additional dependencies to the factory function or the class constructor.

#### Example [\#](https://docs.nestjs.com/techniques/caching\#example)

A working example is available [here](https://github.com/nestjs/nest/tree/master/sample/20-cache).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Testing Suites
- [Suites (formerly Automock)](https://docs.nestjs.com/recipes/suites#suites-formerly-automock)
- [Introduction](https://docs.nestjs.com/recipes/suites#introduction)
- [Installation](https://docs.nestjs.com/recipes/suites#installation)
- [Example and module setup](https://docs.nestjs.com/recipes/suites#example-and-module-setup)
- [Testing CatsApiService with TestingModule](https://docs.nestjs.com/recipes/suites#testing-catsapiservice-with-testingmodule)
- [Sociable Testing Example](https://docs.nestjs.com/recipes/suites#sociable-testing-example)
- [Integration Testing and Database](https://docs.nestjs.com/recipes/suites#integration-testing-and-database)
- [Sociable Unit Tests, Integration Tests, and Mocking](https://docs.nestjs.com/recipes/suites#sociable-unit-tests-integration-tests-and-mocking)
- [Testing IoC Container Registration](https://docs.nestjs.com/recipes/suites#testing-ioc-container-registration)
- [Comparison Between Solitary, Sociable, Integration, and E2E Testing](https://docs.nestjs.com/recipes/suites#comparison-between-solitary-sociable-integration-and-e2e-testing)
- [Solitary Unit Tests](https://docs.nestjs.com/recipes/suites#solitary-unit-tests)
- [Sociable Unit Tests](https://docs.nestjs.com/recipes/suites#sociable-unit-tests)
- [Integration Tests](https://docs.nestjs.com/recipes/suites#integration-tests)
- [E2E Tests](https://docs.nestjs.com/recipes/suites#e2e-tests)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/suites.md "Suggest Edits")

### Suites (formerly Automock)

Suites is an opinionated and flexible testing meta-framework designed to enhance the software testing experience for backend systems. By bringing together a variety of testing tools into a unified framework, Suites streamlines the creation of reliable tests, helping to ensure the development of high-quality software.

> **Hint** `Suites` is a third-party package and is not maintained by the NestJS core team. Please report any issues with the library to the [appropriate repository](https://github.com/suites-dev/suites).

#### Introduction [\#](https://docs.nestjs.com/recipes/suites\#introduction)

Inversion of Control (IoC) is a fundamental principle in the NestJS framework, enabling a modular, testable architecture. While NestJS offers built-in tools for creating testing modules, Suites provides an alternative approach that emphasizes testing isolated units or small groups of units together. Suites uses a virtual container for dependencies, where mocks are automatically generated, eliminating the need to manually replace each provider with a mock in the IoC (or DI) container. This approach can be used either in place of or alongside NestJS’s `Test.createTestingModule` method, offering more flexibility for unit testing based on your needs.

#### Installation [\#](https://docs.nestjs.com/recipes/suites\#installation)

To use Suites with NestJS, install the necessary packages:

```bash

$ npm i -D @suites/unit @suites/di.nestjs @suites/doubles.jest

```

> **Hint** `Suites` supports Vitest and Sinon as test doubles as well, `@suites/doubles.vitest` and `@suites/doubles.sinon` respectively.

#### Example and module setup [\#](https://docs.nestjs.com/recipes/suites\#example-and-module-setup)

Consider a module setup for `CatsService` that includes `CatsApiService`, `CatsDAL`, `HttpClient`, and `Logger`. This
will be our base for the examples in this recipe:

content\_copy cats.module.ts

JS  TS

```typescript

import { HttpModule } from '@nestjs/axios';
import { PrismaModule } from '../prisma.module';

@Module({
  imports: [HttpModule.register({ baseUrl: 'https://api.cats.com/' }), PrismaModule],
  providers: [CatsService, CatsApiService, CatsDAL, Logger],
  exports: [CatsService],
})
export class CatsModule {}

```

Both the `HttpModule` and `PrismaModule` are exporting providers to the host module.

Let's start by testing the `CatsHttpService` in isolation. This service is responsible for fetching cat data from an API and logging the operation.

content\_copy cats-http.service.ts

JS  TS

```typescript

@Injectable()
export class CatsHttpService {
  constructor(private httpClient: HttpClient, private logger: Logger) {}

  async fetchCats(): Promise<Cat[]> {
    this.logger.log('Fetching cats from the API');
    const response = await this.httpClient.get('/cats');
    return response.data;
  }
}

```

We want to isolate `CatsHttpService` and mock its dependencies, `HttpClient` and `Logger`. Suites allows us to do this
easily using the `.solitary()` method from `TestBed`.

content\_copy cats-http.service.spec.ts

JS  TS

```typescript

import { TestBed, Mocked } from '@suites/unit';

describe('Cats Http Service Unit Test', () => {
  let catsHttpService: CatsHttpService;
  let httpClient: Mocked<HttpClient>;
  let logger: Mocked<Logger>;

  beforeAll(async () => {
    // Isolate CatsHttpService and mock HttpClient and Logger
    const { unit, unitRef } = await TestBed.solitary(CatsHttpService).compile();

    catsHttpService = unit;
    httpClient = unitRef.get(HttpClient);
    logger = unitRef.get(Logger);
  });

  it('should fetch cats from the API and log the operation', async () => {
    const catsFixtures: Cat[] = [{ id: 1, name: 'Catty' }, { id: 2, name: 'Mitzy' }];
    httpClient.get.mockResolvedValue({ data: catsFixtures });

    const cats = await catsHttpService.fetchCats();

    expect(logger.log).toHaveBeenCalledWith('Fetching cats from the API');
    expect(httpClient.get).toHaveBeenCalledWith('/cats');
    expect(cats).toEqual<Cat[]>(catsFixtures);
  });
});

```

In the example above, Suites automatically mocks the dependencies of `CatsHttpService` using `TestBed.solitary()`. This makes the setup easier since you don’t have to manually mock each dependency.

- Auto-Mocking of Dependencies: Suites generates mocks for all dependencies of the unit being tested.
- Empty Behavior of Mocks: Initially, these mocks don’t have any predefined behavior. You’ll need to specify their behavior as needed for your tests.
- `unit` and `unitRef` properties:
  - `unit` refers to the actual instance of the class being tested, complete with its mocked dependencies.
  - `unitRef` is a reference that allows you to access the mocked dependencies.

#### Testing `CatsApiService` with `TestingModule` [\#](https://docs.nestjs.com/recipes/suites\#testing-catsapiservice-with-testingmodule)

For `CatsApiService`, we want to ensure that the `HttpModule` is properly imported and configured in the `CatsModule` host module. This includes verifying that the base URL (and other configurations) for `Axios` is set correctly.

In this case, we won’t use Suites; instead, we’ll use Nest’s `TestingModule` to test the actual configuration of `HttpModule`. We’ll utilize `nock` to mock HTTP requests without mocking the `HttpClient` in this scenario.

content\_copy cats-api.service.ts

JS  TS

```typescript

import { HttpClient } from '@nestjs/axios';

@Injectable()
export class CatsApiService {
  constructor(private httpClient: HttpClient) {}

  async getCatById(id: number): Promise<Cat> {
    const response = await this.httpClient.get(`/cats/${id}`);
    return response.data;
  }
}

```

We need to test `CatsApiService` with a real, unmocked `HttpClient` to ensure the DI and configuration of `Axios` (http)
are correct. This involves importing the `CatsModule` and using `nock` for HTTP request mocking.

content\_copy cats-api.service.integration.test.ts

JS  TS

```typescript

import { Test } from '@nestjs/testing';
import * as nock from 'nock';

describe('Cats Api Service Integration Test', () => {
  let catsApiService: CatsApiService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [CatsModule],
    }).compile();

    catsApiService = moduleRef.get(CatsApiService);
  });

  afterEach(() => {
    nock.cleanAll();
  });

  it('should fetch cat by id using real HttpClient', async () => {
    const catFixture: Cat = { id: 1, name: 'Catty' };

    nock('https://api.cats.com') // Making this URL identical to the one in HttpModule registration
      .get('/cats/1')
      .reply(200, catFixture);

    const cat = await catsApiService.getCatById(1);
    expect(cat).toEqual<Cat>(catFixture);
  });
});

```

#### Sociable Testing Example [\#](https://docs.nestjs.com/recipes/suites\#sociable-testing-example)

Next, let's test `CatsService`, which depends on `CatsApiService` and `CatsDAL`. We'll mock `CatsApiService` and
expose `CatsDAL`.

content\_copy cats.dal.ts

JS  TS

```typescript

import { PrismaClient } from '@prisma/client';

@Injectable()
export class CatsDAL {
  constructor(private prisma: PrismaClient) {}

  async saveCat(cat: Cat): Promise<Cat> {
    return this.prisma.cat.create({data: cat});
  }
}

```

Next up, we have the `CatsService`, which depends on `CatsApiService` and `CatsDAL`:

content\_copy cats.service.ts

JS  TS

```typescript

@Injectable()
export class CatsService {
  constructor(
    private catsApiService: CatsApiService,
    private catsDAL: CatsDAL
  ) {}

  async getAndSaveCat(id: number): Promise<Cat> {
    const cat = await this.catsApiService.getCatById(id);
    return this.catsDAL.saveCat(cat);
  }
}

```

And now, let's test `CatsService` using sociable testing with Suites:

content\_copy cats.service.spec.ts

JS  TS

```typescript

import { TestBed, Mocked } from '@suites/unit';
import { PrismaClient } from '@prisma/client';

describe('Cats Service Sociable Unit Test', () => {
  let catsService: CatsService;
  let prisma: Mocked<PrismaClient>;
  let catsApiService: Mocked<CatsApiService>;

  beforeAll(async () => {
    // Sociable test setup, exposing CatsDAL and mocking CatsApiService
    const { unit, unitRef } = await TestBed.sociable(CatsService)
      .expose(CatsDAL)
      .mock(CatsApiService)
      .final({ getCatById: async () => ({ id: 1, name: 'Catty' })})
      .compile();

    catsService = unit;
    prisma = unitRef.get(PrismaClient);
  });

  it('should get cat by id and save it', async () => {
    const catFixture: Cat = { id: 1, name: 'Catty' };
    prisma.cat.create.mockResolvedValue(catFixture);

    const savedCat = await catsService.getAndSaveCat(1);

    expect(prisma.cat.create).toHaveBeenCalledWith({ data: catFixture });
    expect(savedCat).toEqual(catFixture);
  });
});

```

In this example, we use the `.sociable()` method to set up the test environment. We utilize the `.expose()` method to allow real interactions with `CatsDAL`, while mocking `CatsApiService` with the `.mock()` method. The `.final()` method establishes fixed behavior for `CatsApiService`, ensuring consistent outcomes across tests.

This approach emphasizes testing `CatsService` with genuine interactions with `CatsDAL`, which involves handling `Prisma`. Suites will use `CatsDAL` as is, and only its dependencies, like `Prisma`, will be mocked in this case.

It's important to note that this approach is **solely for verifying behavior** and differs from loading the entire testing module. Sociable tests are valuable for confirming the behavior of units in isolation from their direct dependencies, especially when you want to focus on the behavior and interactions of units.

#### Integration Testing and Database [\#](https://docs.nestjs.com/recipes/suites\#integration-testing-and-database)

For `CatsDAL`, it's possible to test against a real database such as SQLite or PostgreSQL (for instance, using Docker Compose). However, for this example, we will mock `Prisma` and focus on sociable testing. The reason for mocking `Prisma` is to avoid I/O operations and concentrate on the behavior of `CatsService` in isolation. That said, you can also conduct tests with real I/O operations and a live database.

#### Sociable Unit Tests, Integration Tests, and Mocking [\#](https://docs.nestjs.com/recipes/suites\#sociable-unit-tests-integration-tests-and-mocking)

- Sociable Unit Tests: These focus on testing the interactions and behaviors between units while mocking their deeper dependencies. In this example, we mock `Prisma` and expose `CatsDAL`.

- Integration Tests: These involve real I/O operations and a fully configured dependency injection (DI) setup. Testing `CatsApiService` with `HttpModule` and `nock` is considered an integration test, as it verifies the real configuration and interactions of `HttpClient`. In this scenario, we will use Nest's `TestingModule` to load the actual module configuration.


**Exercise caution when using mocks.** Be sure to test I/O operations and DI configurations (especially when HTTP or database interactions are involved). After validating these components with integration tests, you can confidently mock them for sociable unit tests to focus on behavior and interactions. Suites sociable tests are geared towards verifying the behavior of units in isolation from their direct dependencies, while integration tests ensure that the overall system configuration and I/O operations function correctly.

#### Testing IoC Container Registration [\#](https://docs.nestjs.com/recipes/suites\#testing-ioc-container-registration)

It's essential to verify that your DI container is properly configured to prevent runtime errors. This includes ensuring that all providers, services, and modules are registered and injected correctly. Testing the DI container configuration helps catch misconfigurations early, preventing issues that might only arise at runtime.

To confirm that the IoC container is set up correctly, let's create an integration test that loads the actual module configuration and verifies that all providers are registered and injected properly.

content\_copy

```typescript

import { Test, TestingModule } from '@nestjs/testing';
import { CatsModule } from './cats.module';
import { CatsService } from './cats.service';

describe('Cats Module Integration Test', () => {
  let moduleRef: TestingModule;

  beforeAll(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [CatsModule],
    }).compile();
  });

  it('should resolve exported providers from the ioc container', () => {
    const catsService = moduleRef.get(CatsService);
    expect(catsService).toBeDefined();
  });
});

```

#### Comparison Between Solitary, Sociable, Integration, and E2E Testing [\#](https://docs.nestjs.com/recipes/suites\#comparison-between-solitary-sociable-integration-and-e2e-testing)

#### Solitary Unit Tests [\#](https://docs.nestjs.com/recipes/suites\#solitary-unit-tests)

- **Focus**: Test single unit (class) in full isolation.
- **Use Case**: Testing `CatsHttpService`.
- **Tools**: Suites' `TestBed.solitary()` method.
- **Example**: Mocking `HttpClient` and testing `CatsHttpService`.

#### Sociable Unit Tests [\#](https://docs.nestjs.com/recipes/suites\#sociable-unit-tests)

- **Focus**: Verify interactions between units while mocking deeper dependencies.
- **Use Case**: Testing `CatsService` with a mocked `CatsApiService` and exposing `CatsDAL`.
- **Tools**: Suites' `TestBed.sociable()` method.
- **Example**: Mocking `Prisma` and testing `CatsService`.

#### Integration Tests [\#](https://docs.nestjs.com/recipes/suites\#integration-tests)

- **Focus**: Involve real I/O operations and fully configured modules (IoC container).
- **Use Case**: Testing `CatsApiService` with `HttpModule` and `nock`.
- **Tools**: Nest's `TestingModule`.
- **Example**: Testing the real configuration and interaction of `HttpClient`.

#### E2E Tests [\#](https://docs.nestjs.com/recipes/suites\#e2e-tests)

- **Focus**: Cover the interaction of classes and modules at a more aggregate level.
- **Use Case**: Testing the full behavior of the system from the perspective of the end-user.
- **Tools**: Nest's `TestingModule`, `supertest`.
- **Example**: Testing the `CatsModule` using `supertest` to simulate HTTP requests.

Refer to the [NestJS official testing guide](https://docs.nestjs.com/fundamentals/testing#end-to-end-testing) for more
details on setting up and running E2E tests.

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## Sharing Models in NestJS
- [Sharing models](https://docs.nestjs.com/graphql/sharing-models#sharing-models)
- [Using the model shim](https://docs.nestjs.com/graphql/sharing-models#using-the-model-shim)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/sharing-models.md "Suggest Edits")

### Sharing models

> **Warning** This chapter applies only to the code first approach.

One of the biggest advantages of using Typescript for the backend of your project is the ability to reuse the same models in a Typescript-based frontend application, by using a common Typescript package.

But there's a problem: the models created using the code first approach are heavily decorated with GraphQL related decorators. Those decorators are irrelevant in the frontend, negatively impacting performance.

#### Using the model shim [\#](https://docs.nestjs.com/graphql/sharing-models\#using-the-model-shim)

To solve this issue, NestJS provides a "shim" which allows you to replace the original decorators with inert code by using a `webpack` (or similar) configuration.
To use this shim, configure an alias between the `@nestjs/graphql` package and the shim.

For example, for webpack this is resolved this way:

content\_copy

```typescript

resolve: { // see: https://webpack.js.org/configuration/resolve/
  alias: {
      "@nestjs/graphql": path.resolve(__dirname, "../node_modules/@nestjs/graphql/dist/extra/graphql-model-shim")
  }
}

```

> **Hint** The [TypeORM](https://docs.nestjs.com/techniques/database) package has a similar shim that can be found [here](https://github.com/typeorm/typeorm/blob/master/extra/typeorm-model-shim.js).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Mapped Types
- [Mapped types](https://docs.nestjs.com/openapi/mapped-types#mapped-types)
- [Partial](https://docs.nestjs.com/openapi/mapped-types#partial)
- [Pick](https://docs.nestjs.com/openapi/mapped-types#pick)
- [Omit](https://docs.nestjs.com/openapi/mapped-types#omit)
- [Intersection](https://docs.nestjs.com/openapi/mapped-types#intersection)
- [Composition](https://docs.nestjs.com/openapi/mapped-types#composition)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/mapped-types.md "Suggest Edits")

### Mapped types

As you build out features like **CRUD** (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.

#### Partial [\#](https://docs.nestjs.com/openapi/mapped-types\#partial)

When building input validation types (also called DTOs), it's often useful to build **create** and **update** variations on the same type. For example, the **create** variant may require all fields, while the **update** variant may make all fields optional.

Nest provides the `PartialType()` utility function to make this task easier and minimize boilerplate.

The `PartialType()` function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a **create** type as follows:

content\_copy

```typescript

import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
}

```

By default, all of these fields are required. To create a type with the same fields, but with each one optional, use `PartialType()` passing the class reference ( `CreateCatDto`) as an argument:

content\_copy

```typescript

export class UpdateCatDto extends PartialType(CreateCatDto) {}

```

> **Hint** The `PartialType()` function is imported from the `@nestjs/swagger` package.

#### Pick [\#](https://docs.nestjs.com/openapi/mapped-types\#pick)

The `PickType()` function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:

content\_copy

```typescript

import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
}

```

We can pick a set of properties from this class using the `PickType()` utility function:

content\_copy

```typescript

export class UpdateCatAgeDto extends PickType(CreateCatDto, ['age'] as const) {}

```

> **Hint** The `PickType()` function is imported from the `@nestjs/swagger` package.

#### Omit [\#](https://docs.nestjs.com/openapi/mapped-types\#omit)

The `OmitType()` function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:

content\_copy

```typescript

import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
}

```

We can generate a derived type that has every property **except** `name` as shown below. In this construct, the second argument to `OmitType` is an array of property names.

content\_copy

```typescript

export class UpdateCatDto extends OmitType(CreateCatDto, ['name'] as const) {}

```

> **Hint** The `OmitType()` function is imported from the `@nestjs/swagger` package.

#### Intersection [\#](https://docs.nestjs.com/openapi/mapped-types\#intersection)

The `IntersectionType()` function combines two types into one new type (class). For example, suppose we start with two types like:

content\_copy

```typescript

import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty()
  name: string;

  @ApiProperty()
  breed: string;
}

export class AdditionalCatInfo {
  @ApiProperty()
  color: string;
}

```

We can generate a new type that combines all properties in both types.

content\_copy

```typescript

export class UpdateCatDto extends IntersectionType(
  CreateCatDto,
  AdditionalCatInfo,
) {}

```

> **Hint** The `IntersectionType()` function is imported from the `@nestjs/swagger` package.

#### Composition [\#](https://docs.nestjs.com/openapi/mapped-types\#composition)

The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the `CreateCatDto` type except for `name`, and those properties will be set to optional:

content\_copy

```typescript

export class UpdateCatDto extends PartialType(
  OmitType(CreateCatDto, ['name'] as const),
) {}

```

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

## NestJS Global Prefix
- [Global prefix](https://docs.nestjs.com/faq/global-prefix#global-prefix)

[Suggest Edits](https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/global-prefix.md "Suggest Edits")

### Global prefix

To set a prefix for **every route** registered in an HTTP application, use the `setGlobalPrefix()` method of the `INestApplication` instance.

content\_copy

```typescript

const app = await NestFactory.create(AppModule);
app.setGlobalPrefix('v1');

```

You can exclude routes from the global prefix using the following construction:

content\_copy

```typescript

app.setGlobalPrefix('v1', {
  exclude: [{ path: 'health', method: RequestMethod.GET }],
});

```

Alternatively, you can specify route as a string (it will apply to every request method):

content\_copy

```typescript

app.setGlobalPrefix('v1', { exclude: ['cats'] });

```

> **Hint** The `path` property supports wildcard parameters using the [path-to-regexp](https://github.com/pillarjs/path-to-regexp#parameters) package. Note: this does not accept wildcard asterisks `*`. Instead, you must use parameters ( `:param`) or named wildcards ( `*splat`).

### Support us

Nest is an MIT-licensed open source project. It can grow thanks to the support of these awesome people. If you'd like to join them, please read more [here](https://docs.nestjs.com/support).

#### Principal Sponsors

[![Trilon Logo](https://docs.nestjs.com/assets/sponsors/trilon.svg)](https://trilon.io/) [![Mojam Logo](https://docs.nestjs.com/assets/sponsors/mojam-logo.png)](https://mojam.co/)

#### Sponsors / Partners

[Become a sponsor](https://opencollective.com/nest)

### Join our Newsletter

Subscribe to stay up to date with the latest Nest updates, features, and videos!

